(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2333],{32333:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>u});var r=t(59713),o=t.n(r),s=t(6479),a=t.n(s),p=(t(67294),t(3905));function c(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?c(Object(t),!0).forEach((function(n){o()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var i={};function u(e){var n=e.components,t=a()(e,["components"]);return(0,p.kt)("wrapper",l(l(l({},i),t),{},{components:n,mdxType:"MDXLayout"}),(0,p.kt)("h3",null,"express"),(0,p.kt)("p",null,"express 是一个基于 node.js 封装的框架。"),(0,p.kt)("p",null,"该 ",(0,p.kt)("a",l({parentName:"p"},{href:"https://github.com/MuYunyun/blog/blob/master/Basic%20Skill/node.js/express/index.js"}),"express demo")," 主要实现的功能点:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"路由模块"),(0,p.kt)("li",{parentName:"ul"},"中间件模块"),(0,p.kt)("li",{parentName:"ul"},"正则匹配路由"),(0,p.kt)("li",{parentName:"ul"},"静态文件处理")),(0,p.kt)("h3",null,"路由和中间件"),(0,p.kt)("h4",null,"版本一"),(0,p.kt)("pre",null,(0,p.kt)("code",l({parentName:"pre"},{className:"language-js"}),"// 测试用例\nconst app = express()\n\n// 测试路由\napp.get('/', function (req, res) {\n  res.end('hello express')\n})\n\n// 测试中间件\napp.use((req, res, next) => {\n  console.log('this is middleware1')\n  next()\n})\n\napp.use((req, res, next) => {\n  console.log('this is middleware2')\n  next()\n})\n\napp.listen(3000, function (req, res) {\n  console.log('server is listening port 3000')\n})\n\n// this is middleware1\n// this is middleware2\n// hello express\n")),(0,p.kt)("pre",null,(0,p.kt)("code",l({parentName:"pre"},{className:"language-js"}),"const http = require('http')\nconst url = require('url')\n\nconst core = function(req, res) {\n  const method = req.method.toLocaleLowerCase()\n  const obj = url.parse(req.url, true)\n  const pathname = obj.pathname\n  const cb = hitRouting(method, pathname)\n  // 这里插入中间件\n  next(req, res)\n  cb(req, res)\n}\n\ncore.listen = function(port, fn) {                      // 挂载到 core 函数上\n  http.createServer(core).listen(port, '127.0.0.1', fn) // 核心还是这条语句, 即对 node 的封装\n}\n\nconst methods = ['post', 'get', 'delete', 'options', 'head']\nmethods.map(method => {\n  core[method] = (path, cb) => core.routes.push({ method, path, cb })\n})\n\ncore.routes = []      // 路由队列\ncore.middlewares = [] // 中间件队列\n\n// 命中路由, 获取回调\nconst hitRouting = function(method, pathname) {\n  let cb = (req, res) => res.end('no hit routing')\n  core.routes.map((r, index) => {\n    if (r.method === method && r.path === pathname) {\n      cb = r.cb\n      return\n    }\n  })\n  return cb\n}\n\ncore.use = function(middlewareFn) {\n  core.middlewares.push(middlewareFn)\n}\n\nlet i = 0\nconst next = function(req, res) {   // express 中间件的核心实现\n  const handler = core.middlewares[i++]\n  if (!handler) {\n    return\n  }\n  handler(req, res, next)\n}\n\nconst express = function() {\n  return core\n}\n")),(0,p.kt)("p",null,"版本一的路由和中间件是分为两个数组分别进行管理的；但是当看到 next() 函数又联想到可以借助 generator 函数来实现路由和中间件的集中管理(把中间件也当成是一个路由), 所以有了版本二的实现。"),(0,p.kt)("h4",null,"版本二"),(0,p.kt)("p",null,"版本二相较于版本一最主要是遍历方式的改变, 改为迭代器方式。"),(0,p.kt)("pre",null,(0,p.kt)("code",l({parentName:"pre"},{className:"language-js"}),"// 测试路由\napp.get('/test/abc', function(req, res) {\n  res.end('hello express')\n})\n\n// 测试中间件\napp.use('/test', function(req, res, next) {\n  console.log('this is middleware')\n  next()\n})\n\napp.listen(3000, function(req, res) {\n  console.log('server is listening port 3000')\n})\n")),(0,p.kt)("p",null,"测试用例进行了改动, 比如当访问 ",(0,p.kt)("inlineCode",{parentName:"p"},"/test/abc")," 路由的时候, 其实也命中了 ",(0,p.kt)("inlineCode",{parentName:"p"},"/test")," 中间件, 所以此时中间件内的代码也会执行。"),(0,p.kt)("pre",null,(0,p.kt)("code",l({parentName:"pre"},{className:"language-js"}),"const http = require('http')\nconst url = require('url')\n\nconst core = function(req, res) {\n  const method = req.method.toLocaleLowerCase()\n  const obj = url.parse(req.url, true)\n  const pathname = obj.pathname\n  hitRouting(core.routes, method, pathname)(req, res)\n}\n\ncore.listen = function(port, fn) {                      // 挂载到 core 函数上\n  http.createServer(core).listen(port, '127.0.0.1', fn) // 核心还是这条语句, 即对 node 的封装\n}\n\ncore.routes = []      // 路由队列\nconst methods = ['post', 'get', 'delete', 'options', 'head', 'use']\nmethods.map(method => {\n  core[method] = (path, cb) => core.routes.push({ method, path, cb })\n})\n\nfunction* generator(arr) {  // 引人 Generator 函数\n  yield* arr\n}\n\nconst hitRouting = function(routes, method, pathname) { // 将中间件也当作是路由\n  const lazy = generator(routes)\n  return function(req, res) {\n    (function next() {\n      const tmp = lazy.next().value\n      if (!tmp) {\n        return\n      }\n      if (tmp.method === method && tmp.path === pathname) {                                     // 命中路由\n        tmp.cb(req, res)\n        next()\n      } else if (tmp.method === 'use' && (tmp.path === '/' || pathname.startsWith(tmp.path))) { // 命中中间件\n        tmp.cb(req, res, next)\n      } else {\n        next() // 跳过\n      }\n    }())\n  }\n}\n\nconst express = function() {\n  return core\n}\n")),(0,p.kt)("h3",null,"路由正则匹配"),(0,p.kt)("pre",null,(0,p.kt)("code",l({parentName:"pre"},{className:"language-js"}),"// 测试用例\napp.get('/blog/:id', function (req, res) { // 扩展功能①: 希望能匹配 /blog/123\n  console.log(req.param.id)                // 扩展功能②: 希望能通过 req.param.id 获取到相应参数\n  res.end('test /blog/:id')\n})\n")),(0,p.kt)("p",null,"上述功能简要实现如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",l({parentName:"pre"},{className:"language-js"}),"const hitRouting = function(routes, method, pathname) { // 将中间件也当作是路由\n  const lazy = generator(routes)\n  return function(req, res) {\n    (function next() {\n      const tmp = lazy.next().value\n      const reg = new RegExp(tmp.path.replace(/:id/g, '\\\\d+'))\n      if (tmp.method === method && reg.test(pathname)) {        // 匹配 /blog/:id, 这里仅仅举个例子\n        const arr = tmp.path.split(':')\n        const pathNameArr = pathname.split('/')\n        const obj = {}\n        obj[arr[1]] = pathNameArr[pathNameArr.length - 1]\n        req.param = obj   // 实现 req.param.id 获取 id\n        tmp.cb(req, res)\n        next()\n      }\n      ...\n    }())\n  }\n}\n")),(0,p.kt)("h3",null,"静态资源的访问"),(0,p.kt)("p",null,"如果在浏览器中输入 ",(0,p.kt)("inlineCode",{parentName:"p"},"http://127.0.0.1:3000/index.html"),", 此时并不能处理这种情况, 接着加上访问静态资源的逻辑, 代码如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",l({parentName:"pre"},{className:"language-js"}),'const core = function(req, res) {\n  const method = req.method.toLocaleLowerCase()\n  const obj = url.parse(req.url, true)\n  const pathname = obj.pathname\n  const ext = path.extname(pathname).slice(1)\n  if (ext) { // 处理静态文件请求\n    handleStaticFile(res, staticPath, ext)\n  }\n  ...\n}\n\n// 处理静态文件类型\nconst handleStaticFile = function (res, staticPath, ext) {\n  const mime = {\n    "html": "text/html",\n    "css": "text/css",\n    "js": "text/javascript",\n    "json": "application/json",\n    "gif": "image/gif",\n    "ico": "image/x-icon",\n    "jpeg": "image/jpeg",\n    "jpg": "image/jpeg",\n    "png": "image/png"\n  }\n  fs.exists(staticPath, (exist) => {\n    if (!exist) {\n      res.writeHead(404, {\'Content-Type\': \'text/plain\'})\n      res.write(\'The request failed\')\n      res.end()\n    } else {\n      fs.readFile(staticPath, (err, data) => {\n        if (err) throw err\n        res.writeHead(200, {\'Content-Type\': mime[ext] || \'text/plain\'})\n        res.write(\'The request success\')\n        res.end()\n      })\n    }\n  })\n}\n')))}u.isMDXComponent=!0}}]);