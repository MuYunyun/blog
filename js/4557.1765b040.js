(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4557],{54557:e=>{e.exports='### Suspense 设计模式\n\n* `fetch on render`: 目前一般数据获取写在 componentDidMount 阶段, 其获取数据的过程中, 执行顺序如下所示:\n\n1. start fetchA\n2. ...`wait Time1`...\n3. finish fetchA\n4. start fetchB\n5. ...`wait Time2`...\n6. finish fetchB\n\n这么做存在的问题: 在 B 组件中开始请求数据时至少要等上 `Time1` 时间, 是一种 `network waterfall` 而非`并发请求`;\n\n* `fetch then render`: `调用 setState 之前先获取数据`, 比如在 A 组件的 componentDidMount 中使用 `Promise.all()` 同时执行 `fetchA, fetchB`\n\n1. start fetchA\n2. start fetchB\n3. finish fetchA\n4. finish fetchB\n5. `render`\n\n这么做存在的问题: A 组件和 B 组件上的数据显示时间取决于请求时间更长的接口, 所以`页面上渲染数据必然会存在延时`;\n\n* `render as fetch`: 使用 Suspense 后的效果呢?\n\n1. start fetchA\n2. start fetchB\n3. `render`\n4. finish fetchA\n5. finish fetchB\n\n它很好地规避了上述遇到的两个问题:\n\n1. 解决接口根据 render 走导致`不能并发请求接口`的痛点;\n2. 解决使用 Promise.all 带来的`页面数据内容存在延时`的问题;\n\n### Concurrent UI patterns\n\n* `Default Mode`: Receded → Skeleton → Complete\n* `Preferred Mode`: Pending → Skeleton → Complete\n\n总结:\n\n* Receded 不好的原因是因为其把页面现有的内容给弄丢了。\n* 可以使用 `useTransition` 进入 Pending 状态 —— 位于当前页的同时, 加载下一页(想象多元宇宙)\n* 如果不想下一个页面的非核心组件延长 Pending 的时间, 用 Suspense 包裹它;\n\n### useDeferredValue\n\n`useDeferredValue` 的作用: 能让组件中的部分内容`延迟加载`。\n\n```js\nconst deferredText = useDeferredValue(text, {\n  timeoutMs: 5000\n})\n```\n\n这里第二个参数表示, 能确保 5s 之内输入框内的输入是顺滑的。\n\n### SuspenseList\n\nSuspenseList 中的 `revealOrder` 字段能控制其里面 Suspense 节点的输出顺序, `tail` 字段控制当前加载的节点数。\n\n```js\nfunction ProfilePage({ resource }) {\n  return (\n    <SuspenseList revealOrder="forwards" tail="collapsed">\n      <ProfileDetails resource={resource} />\n      <Suspense fallback={<h2>Loading posts...</h2>}>\n        <ProfileTimeline resource={resource} />\n      </Suspense>\n      <Suspense fallback={<h2>Loading fun facts...</h2>}>\n        <ProfileTrivia resource={resource} />\n      </Suspense>\n    </SuspenseList>\n  );\n}\n```\n'}}]);