(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3933],{63933:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>s});var a=t(59713),r=t.n(a),l=t(6479),o=t.n(l),u=(t(67294),t(3905));function p(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function c(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?p(Object(t),!0).forEach((function(e){r()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):p(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var m={};function s(n){var e=n.components,t=o()(n,["components"]);return(0,u.kt)("wrapper",c(c(c({},m),t),{},{components:e,mdxType:"MDXLayout"}),(0,u.kt)("h3",null,"62. Unique Paths"),(0,u.kt)("p",null,"A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below)."),(0,u.kt)("p",null,"The robot can only move either ",(0,u.kt)("inlineCode",{parentName:"p"},"down or right")," at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below)."),(0,u.kt)("p",null,"How many possible unique paths are there?"),(0,u.kt)("p",null,"Example 1:"),(0,u.kt)("p",null,(0,u.kt)("img",c({parentName:"p"},{src:"https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png",alt:null}))),(0,u.kt)("pre",null,(0,u.kt)("code",c({parentName:"pre"},{className:"language-js"}),"Input: m = 3, n = 7\nOutput: 28\n")),(0,u.kt)("p",null,"Example 2:"),(0,u.kt)("pre",null,(0,u.kt)("code",c({parentName:"pre"},{className:"language-js"}),"Input: m = 3, n = 2\nOutput: 3\n")),(0,u.kt)("p",null,"Explanation:\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:"),(0,u.kt)("ol",null,(0,u.kt)("li",{parentName:"ol"},"Right -> Down -> Down"),(0,u.kt)("li",{parentName:"ol"},"Down -> Down -> Right"),(0,u.kt)("li",{parentName:"ol"},"Down -> Right -> Down")),(0,u.kt)("p",null,"Example 3:"),(0,u.kt)("pre",null,(0,u.kt)("code",c({parentName:"pre"},{className:"language-js"}),"Input: m = 7, n = 3\nOutput: 28\n")),(0,u.kt)("p",null,"Example 4:"),(0,u.kt)("pre",null,(0,u.kt)("code",c({parentName:"pre"},{className:"language-js"}),"Input: m = 3, n = 3\nOutput: 6\n")),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},"Constraints:",(0,u.kt)("ul",{parentName:"li"},(0,u.kt)("li",{parentName:"ul"},"1 <= m, n <= 100"),(0,u.kt)("li",{parentName:"ul"},"It's guaranteed that the answer will be less than or equal to 2 * 109.")))),(0,u.kt)("h3",null,"Analyze"),(0,u.kt)("p",null,"记忆递归法:"),(0,u.kt)("pre",null,(0,u.kt)("code",c({parentName:"pre"},{className:"language-js"}),"const cache = {}\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function (m, n) {\n  if (m === 1 || n === 1) {\n    return 1\n  }\n\n  if (cache[`${m}~${n}`]) {\n    return cache[`${m}~${n}`]\n  } else {\n    const nums = uniquePaths(m - 1, n) + uniquePaths(m, n - 1)\n    cache[`${m}~${n}`] = nums\n\n    return nums\n  }\n}\n")),(0,u.kt)("p",null,"动态规划法:"),(0,u.kt)("pre",null,(0,u.kt)("code",c({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function(m, n) {\n  const cache = {\n    [`${m - 1}_${n - 1}`]: 1\n  }\n  for (let x = m - 1; x >= 0; x--) {\n    for (let y = n - 1; y >= 0; y--) {\n      if (x === m - 1 && y === n - 1) {\n        continue\n      }\n      if (y + 1 === n) {\n        cache[`${x}_${y}`] = cache[`${x + 1}_${y}`]\n      } else if (x + 1 === m) {\n        cache[`${x}_${y}`] = cache[`${x}_${y + 1}`]\n      } else {\n        cache[`${x}_${y}`] = cache[`${x}_${y + 1}`] + cache[`${x + 1}_${y}`]\n      }\n    }\n  }\n  return cache['0_0']\n}\n")),(0,u.kt)("h3",null,"Similar Title"),(0,u.kt)("p",null,"63"))}s.isMDXComponent=!0}}]);