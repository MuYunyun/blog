(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3734],{53734:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>o});var r=t(59713),l=t.n(r),i=t(6479),s=t.n(i),u=(t(67294),t(3905));function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function p(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){l()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var m={};function o(n){var e=n.components,t=s()(n,["components"]);return(0,u.kt)("wrapper",p(p(p({},m),t),{},{components:e,mdxType:"MDXLayout"}),(0,u.kt)("h3",null,"题目: 长度最小的子数组"),(0,u.kt)("p",null,"给定一个含有 n 个正整数的数组和一个正整数 s, 找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。"),(0,u.kt)("p",null,"示例: "),(0,u.kt)("pre",null,(0,u.kt)("code",p({parentName:"pre"},{className:"language-js"}),"输入: s = 7, nums = [2,3,1,2,4,3]\n输出: 2\n解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。\n")),(0,u.kt)("p",null,"进阶:"),(0,u.kt)("p",null,"如果你已经完成了 ",(0,u.kt)("inlineCode",{parentName:"p"},"O(n)")," 时间复杂度的解法, 请尝试 ",(0,u.kt)("inlineCode",{parentName:"p"},"O(nlogn)")," 时间复杂度的解法。"),(0,u.kt)("h3",null,"解题"),(0,u.kt)("p",null,"思路: ",(0,u.kt)("inlineCode",{parentName:"p"},"滑动列表"),"。时间复杂度为 ",(0,u.kt)("inlineCode",{parentName:"p"},"O(n)"),", 空间复杂度为 ",(0,u.kt)("inlineCode",{parentName:"p"},"1"),"。"),(0,u.kt)("ol",null,(0,u.kt)("li",{parentName:"ol"},"取滑动列表 ","[left, right]",";"),(0,u.kt)("li",{parentName:"ol"},"若列表 ","[left, right]"," 中的取值之和小于 s, 则列表的有边界 right 往右扩张。"),(0,u.kt)("li",{parentName:"ol"},"若列表 ","[left, right]"," 中的取值之和大于 s, 则列表的左边界 left 往右扩张。")),(0,u.kt)("pre",null,(0,u.kt)("code",p({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number} s\n * @param {number[]} nums\n * @return {number}\n */\nvar minSubArrayLen = function(s, nums) {\n  let left = 0, right = -1 // [left, right], 左闭右闭\n  let minDistance = nums.length + 1 // 存储 left 与 right 间的距离\n  let sum = 0 // [left, right] 间值的总和\n  while (left < nums.length - 1) {\n    if (right < nums.length - 1 && sum < s) {\n      right++\n      sum = sum + nums[right]\n    } else {\n      sum = sum - nums[left]\n      left++\n    }\n    if (sum >= s) {\n      minDistance = Math.min(minDistance, right - left + 1)\n    }\n  }\n\n  if (minDistance === nums.length + 1) return 0\n\n  return minDistance\n}\n")),(0,u.kt)("h3",null,"Sister Title"),(0,u.kt)("p",null,"3、76、209、438"))}o.isMDXComponent=!0}}]);