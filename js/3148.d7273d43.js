(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3148],{43148:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>s});var r=t(59713),l=t.n(r),o=t(6479),a=t.n(o),i=(t(67294),t(3905));function u(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function c(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?u(Object(t),!0).forEach((function(e){l()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):u(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var p={};function s(n){var e=n.components,t=a()(n,["components"]);return(0,i.kt)("wrapper",c(c(c({},p),t),{},{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h2",null,"TypeScript 中使用函数"),(0,i.kt)("h3",null,"Call Signatures"),(0,i.kt)("p",null,"如果我们期望根据属性类型动态选取函数调用，可以书写如下:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-ts"}),'type DescribableFunction = {\n  description: string;\n  (someArg: number): boolean;\n};\nfunction doSomething(fn: DescribableFunction) {\n  console.log(fn.description + " returned " + fn(6));\n}\n')),(0,i.kt)("p",null,"在这里，",(0,i.kt)("inlineCode",{parentName:"p"},"fn(6)")," 中传入了数字 6，因而其命中了对象中 ",(0,i.kt)("inlineCode",{parentName:"p"},"(someArg: number): boolean;")," 该条规则。"),(0,i.kt)("h3",null,"在函数中使用泛型应该注意的点"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"尽可能地直接使用参数类型，而不要去约束它。")),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-ts"}),"function firstElement1<Type>(arr: Type[]) {\n  return arr[0];\n}\n\nfunction firstElement2<Type extends any[]>(arr: Type) {\n  return arr[0];\n}\n\n// ✅ a: number\nconst a = firstElement1([1, 2, 3]);\n// ❎ b: any\nconst b = firstElement2([1, 2, 3]);\n")),(0,i.kt)("p",null,"粗看 firstElement1 与 firstElement2 似乎达到一样的效果，但是结果上 a 的类型是 number，b 的类型是 any。这是因为 TypeScript 必须使用约束类型解析 arr","[0]"," 表达式，而非在调用期间“等待”解析元素。"),(0,i.kt)("h3",null,"不要在 CallBacks 中使用可选参数表达式"),(0,i.kt)("p",null,"在以下代码中，在定义侧对回调函数中的参数作了可选表达式的声明，且在定义侧调用的 callback 函数未传入可选参数，因此在消费者调用可选参数值时报了错误。"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-ts"}),"// ❎ 定义侧错误示范\nfunction myForEach(arr: any[], callback: (arg: any, index?: number) => void) {\n  for (let i = 0; i < arr.length; i++) {\n    callback(arr[i])\n  }\n}\n\n// 消费侧\nmyForEach([1, 2, 3], (a, i) => {\n  // Object is possibly 'undefined'.\n  console.log(i.toFixed())\n})\n")),(0,i.kt)("p",null,"与之对应的，若需要在回调函数中定义参数的类型，尽量不使用可选参数表达式，除非消费该函数时能保证处理好可选参数。"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-ts"}),"// ✅ 定义侧正确示范\nfunction myForEach(arr: any[], callback: (arg: any, index: number) => void) {\n  for (let i = 0; i < arr.length; i++) {\n    callback(arr[i], i)\n  }\n}\n\n// 消费侧\nmyForEach([1, 2, 3], (a, i) => {\n  console.log(i.toFixed())\n})\n")),(0,i.kt)("h3",null,"函数重载"),(0,i.kt)("p",null,"函数实现侧必须与定义重载侧对应。"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"例子一: 参数类型不正确")),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-ts"}),"// 定义侧\nfunction fn(x: boolean): void;\nfunction fn(x: string): void;\n\n// 实现侧\nfunction fn(x: boolean) { }          // ❎\nfunction fn(x: boolean | string) { } // ✅\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"例子二: 返回结果不正确")),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-ts"}),"// 定义侧\nfunction fn(x: string): string;\nfunction fn(x: number): boolean;\n\n// 实现侧\n// ❎\nfunction fn(x: string | number) {\n  return \"oops\"\n}\n\n// ✅\nfunction fn(x: string | number): string | boolean {\n  if (typeof x === 'string') {\n    return 'hhh'\n  } else if (typeof x === 'number') {\n    return true\n  }\n}\n")),(0,i.kt)("h3",null,"类型定义"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"尽量不要使用大写来类型声明")),(0,i.kt)("p",null,"to write: ",(0,i.kt)("a",c({parentName:"p"},{href:"https://www.typescriptlang.org/docs/handbook/2/functions.html#other-types-to-know-about"}),"https://www.typescriptlang.org/docs/handbook/2/functions.html#other-types-to-know-about")),(0,i.kt)("h3",null,"link"),(0,i.kt)("p",null,(0,i.kt)("a",c({parentName:"p"},{href:"https://www.typescriptlang.org/docs/handbook/2/functions.html"}),"More on Functions")))}s.isMDXComponent=!0}}]);