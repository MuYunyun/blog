(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3969],{93969:n=>{n.exports="### 集合\n\n集合是一种`无重复元素, 无顺序`的数据结构。\n\nES6 引入的 Set 就是集合。\n\n### 简易版 Set 实现\n\n我们来动手实现一个简易版的 Set, 它拥有的 api 如下:\n\n```js\nadd(value)\n\ndelete(value)\n\nhas(value)\n\nclear()\n\nsize\n```\n\n```js\n// 代码如下, 仅仅用来理解, 实现得不严谨\nfunction Set() {\n  this.items = {}\n  this.size = 0\n}\n\nSet.prototype.add = function(value) {\n  if (!this.items[value]) {\n    this.items[value] = value // 这样子不能实现存储数组、对象\n    this.size = Object.keys(this.items).length\n  }\n}\n\nSet.prototype.has = function(value) {\n  if (this.items.hasOwnProperty(value)) {\n    return true\n  } else {\n    return false\n  }\n}\n\nSet.prototype.delete = function(value) {\n  for (let i in this.items) {\n    if (this.items.hasOwnProperty(i)) {\n      if (i === value.toString()) {\n        delete(this.items[i])\n        this.size = Object.keys(this.items).length\n        return true\n      }\n    }\n  }\n}\n\nSet.prototype.clear = function() {\n  this.items = {}\n  this.size = 0\n}\n```\n\n### 并集、交集、差集、子集\n\n业务中可能用数组多些, 如果碰到 set 类型的可以用 Array.from 将之转为数组类型, 再使用如下方法。\n\n```js\n// 并集\nfunction union(arr1, arr2) {\n  const arr = arr1.concat(arr2)\n  const result = Array.from(new Set(arr))\n  return result\n}\n\n// 交集\nfunction intersection(arr1, arr2) {\n  const result = arr1.filter(r => arr2.includes(r)) // 也可以转化为 set,用 has\n  return result\n}\n\n// 差集\nfunction difference(arr1, arr2) {\n  const result = arr1.filter(r => !arr2.includes(r))\n  return result\n}\n\n// 子集(判断 arr1 是否为 arr2 的子集)\nfunction isSubset(arr1, arr2) {\n  let bool = true\n  arr1.forEach(r => {\n    if (!arr2.includes(r)) {\n      bool = false\n      return\n    }\n  })\n  return bool\n}\n```\n\n### 创建 Set 对象\n\n```js\n// 方法一\nconst set1 = new Set()\nset.add(1)\n\n// 方法二\nconst set2 = new Set([1])\n```"}}]);