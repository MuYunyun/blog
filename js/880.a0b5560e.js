(self.webpackChunkblog=self.webpackChunkblog||[]).push([[880],{30880:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>c});var a=n(59713),l=n.n(a),i=n(6479),r=n.n(i),o=(n(67294),n(3905));function p(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function u(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?p(Object(n),!0).forEach((function(t){l()(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):p(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var m={};function c(e){var t=e.components,n=r()(e,["components"]);return(0,o.kt)("wrapper",u(u(u({},m),n),{},{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h3",null,"Schedule"),(0,o.kt)("p",null,"解决",(0,o.kt)("inlineCode",{parentName:"p"},"目标对象更快完成渲染"),"与",(0,o.kt)("inlineCode",{parentName:"p"},"及时响应优先级更高任务"),"之间的矛盾。"),(0,o.kt)("h3",null,"Perceived Performance"),(0,o.kt)("p",null,"Perceived performance 可感知到的性能"),(0,o.kt)("p",null,"在流畅性的章节中提到将主线程的一个长任务进行",(0,o.kt)("inlineCode",{parentName:"p"},"时间分片"),"可以拆分为多个帧任务, 但如果同时存在多个任务则必然会存在一种竞争机制, 于是需要一种 ",(0,o.kt)("inlineCode",{parentName:"p"},"Schedule")," 机制, 在时间分片中加入",(0,o.kt)("inlineCode",{parentName:"p"},"动态优先级"),"的概念来真正避免卡顿现象。"),(0,o.kt)("h3",null,"Schedule"),(0,o.kt)("p",null,"调度算法思想:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"任务执行时间得足够短, 能在一帧时间内执行完(时间分片);"),(0,o.kt)("li",{parentName:"ul"},"不同任务存在不同的优先级;")),(0,o.kt)("h3",null,"任务的种类"),(0,o.kt)("p",null,"在一帧中执行的任务种类有以下几种类别:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"user-blocking tasks"),": 基于用户的交互的任务(可见), 需在当前帧处理; -> ",(0,o.kt)("inlineCode",{parentName:"li"},"input"),"、",(0,o.kt)("inlineCode",{parentName:"li"},"rAF"),"、",(0,o.kt)("inlineCode",{parentName:"li"},"microtask"),"(顺畅的交互应小于 10 ms, 下同)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"default tasks"),": 基于用户获取数据渲染到界面上的任务(可见), 在当前的帧以及下一帧里处理; -> ",(0,o.kt)("inlineCode",{parentName:"li"},"macrotask"),"(小于 100 ms)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"idle tasks"),": 和分析、缓存、排序相关的任务(不可见); -> ",(0,o.kt)("inlineCode",{parentName:"li"},"requestIdleCallback"),"(小于 10 ms)")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"不能拆分的任务(执行时间较长的 chunk)怎么办？")),(0,o.kt)("p",null,"借助 ",(0,o.kt)("inlineCode",{parentName:"p"},"web Worker")),(0,o.kt)("h3",null,"任务的排序机制"),(0,o.kt)("p",null,"任务的排序机制是由 ",(0,o.kt)("inlineCode",{parentName:"p"},"expiration time")," 这个字段决定的，其值为 ",(0,o.kt)("inlineCode",{parentName:"p"},"callback 的注册时间"),"与",(0,o.kt)("inlineCode",{parentName:"p"},"当前任务优先级的值"),"之和, 表示过期时间(值越小, 越早执行)。"),(0,o.kt)("p",null,"优先级的值分为以下几种类别:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Immediate"),": (0ms timeout)需要实时交互的任务;              (Do it now)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"User Block"),": (250ms timeout)对页面交互有副作用的任务;      (Do it now)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Normal"),": (5s timeout)不影响交互的任务;                    (Do it soon)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Low"),": (10s timeout)可以延迟执行，但最终需要执行的任务;      (Do it eventually)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Idle"),": (no timeout)执行与否不影响应用的任务;               (Do it if you can)")),(0,o.kt)("p",null,"在了解了 ",(0,o.kt)("inlineCode",{parentName:"p"},"expiration time")," 之后, 对 ",(0,o.kt)("inlineCode",{parentName:"p"},"Schedule")," 的流程进行如下概述:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"所有回调根据 ",(0,o.kt)("inlineCode",{parentName:"li"},"expiration time")," 排好序放入一个队列中;"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"Schedule")," 自己注册一个回调 callback 调用该队列，并下一个帧中执行它;"),(0,o.kt)("li",{parentName:"ol"},"在下一帧中尽可能多地执行队形里的回调;")),(0,o.kt)("h3",null,"Schedule 源码分析"),(0,o.kt)("p",null,"Schedule 中 4 个比较重要的方法的作用罗列如下:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"requestHostCallback: 提供调用下一帧的能力"),(0,o.kt)("li",{parentName:"ul"},"cancelHostCallback: 提供取消当前任务的能力"),(0,o.kt)("li",{parentName:"ul"},"shouldYieldToHost: 提供暂停当前任务的能力"),(0,o.kt)("li",{parentName:"ul"},"getCurrentTime: 根据该函数获取的值从而判断具体的优先级")),(0,o.kt)("h3",null,"JND"),(0,o.kt)("p",null,"JND(Just Noticeable Difference), ",(0,o.kt)("a",u({parentName:"p"},{href:"https://github.com/MuYunyun/react/blob/0f1e97e7cb67b7e403af5f78f38294dfd33e081e/packages/react-reconciler/src/ReactFiberWorkLoop.js#L2144-L2167"}),"JND")),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"// Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\nfunction jnd(timeElapsed: number) {\n  return timeElapsed < 120\n    ? 120\n    : timeElapsed < 480\n      ? 480\n      : timeElapsed < 1080\n        ? 1080\n        : timeElapsed < 1920\n          ? 1920\n          : timeElapsed < 3000\n            ? 3000\n            : timeElapsed < 4320\n              ? 4320\n              : ceil(timeElapsed / 1960) * 1960;\n}\n")),(0,o.kt)("h3",null,"Connection between Time Slicing and Suspense"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Time Slicing")," is the premise of ",(0,o.kt)("inlineCode",{parentName:"p"},"Suspense"),". Because in each time slicing it can compare the task priority, and then determine whether to show the loading."),(0,o.kt)("p",null,(0,o.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/6999fa9b5759613e1dde3b2dfec7076d.jpg",alt:null}))),(0,o.kt)("h3",null,"is-input-pending"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"相比 ",(0,o.kt)("inlineCode",{parentName:"li"},"requestIdleCallback"),", 其有更简洁的 api;"),(0,o.kt)("li",{parentName:"ul"},"另外其不会受到优先级的限制;")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("a",u({parentName:"p"},{href:"https://github.com/WICG/is-input-pending"}),"is-input-pending"))),(0,o.kt)("h3",null,"相关文章"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",u({parentName:"li"},{href:"https://developer.chrome.com/devsummit/schedule/scheduling-on-off-main-thread"}),"scheduling-on-off-main-thread"),": 讲解了如何在帧里拆分任务以及使用 worker 的一些限制"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",u({parentName:"li"},{href:"https://philippspiess.com/scheduling-in-react/#fn-1"}),"Scheduling in React"),": 任务的排序机制"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",u({parentName:"li"},{href:"https://github.com/WICG/main-thread-scheduling"}),"main-thread-scheduling"),": schedule API in future. 核心是从最高优先级的任务中挑选时间过去最久的任务。"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",u({parentName:"li"},{href:"https://www.youtube.com/watch?reload=9&v=Iyrf52cwxQI&feature=youtu.be&utm_source=tinyreact&utm_medium=email"}),"Scheduling is the Future"),": @ReactEurope 2019 speaker: @aweary")))}c.isMDXComponent=!0}}]);