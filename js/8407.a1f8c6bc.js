(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8407],{68407:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>c});var r=n(59713),l=n.n(r),a=n(6479),i=n.n(a),o=(n(67294),n(3905));function p(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function u(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?p(Object(n),!0).forEach((function(t){l()(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):p(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var s={};function c(e){var t=e.components,n=i()(e,["components"]);return(0,o.kt)("wrapper",u(u(u({},s),n),{},{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h3",null,"二分查找思想"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"取已排列好数组的中间值"),(0,o.kt)("li",{parentName:"ol"},"把需查找的值和中间值进行比较"),(0,o.kt)("li",{parentName:"ol"},"如果比中间值小, 则对前半部分进行类似操作；如果比中间值大, 则对后半部分进行类似操作；")),(0,o.kt)("h3",null,"二分查找代码实现"),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"// arr 为指定数组, target 为目标元素\nfunction binarysearch(arr, target) {\n  let left = 0\n  let right = arr.length - 1\n  while (left <= right) {\n    const middlePoint = Math.floor((left + right) / 2)\n    let middle = arr[middlePoint]\n    if (middle > target) {\n      right = middlePoint - 1\n    } else if (middle < target) {\n      left = middlePoint + 1\n    } else {\n      return middle\n    }\n  }\n\n  return '数组中目标元素不存在'\n}\n")),(0,o.kt)("h3",null,"以二分查找法看如何写出正确的程序"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"明确变量的含义。比如在上述代码中, left 与 right 就是变量, 其意味当前查找数组中的左边界与右边界。","[left, ...right]",";"),(0,o.kt)("li",{parentName:"ul"},"循环不变量。在上述代码中, 循环中改变变量(left, right)的取值, 但是不改变变量的含义。","[left, ...right]",";"),(0,o.kt)("li",{parentName:"ul"},"小数据量调试。(快速, 准确, 耐心)"),(0,o.kt)("li",{parentName:"ul"},"大数据量调试。(能测出程序的性能)")),(0,o.kt)("h3",null,"真题"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"题目: 题目: 在一个二维数组中, 每一行都按照从左到右递增的顺序排序, 每一列都按照从上到下递增的顺序排序。请完成一个函数, 输入这样的一个二维数组和一个整数, 判断数组中是否含有该整数。")),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"1  2  3  4\n5  6  7  8\n9  10 11 12\n13 14 15 16\n\nfunction find(arr, n) {\n  let x = 0\n  let y = arr[x].length - 1\n  while (x < arr.length && y > 0) {\n    if (n > arr[x][y]) {\n      x++\n    } else if (n < arr[x][y]) {\n      y--\n    } else {\n      return '找到目标元素'\n    }\n  }\n  return '目标元素不存在'\n}\n")),(0,o.kt)("p",null,"这道题严格不算是二分查找, 不过用到了类似的思维。"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"求开方")),(0,o.kt)("p",null,(0,o.kt)("a",u({parentName:"p"},{href:"https://leetcode.com/problems/sqrtx/description/"}),"Leetcode : 69. Sqrt(x) (Easy)")),(0,o.kt)("p",null,"思路: 满足 0 < sqrt < x && sqrt === x / sqrt, 转化为二分查找求 sqrt"),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number} x\n * @return {number}\n */\nvar mySqrt = function(x) { // 8\n    let left = 1\n    let right = x\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2) // 4 2 3\n        const sqrt = x / mid // 2 4 2.7\n        if (sqrt === mid) return sqrt\n        if (sqrt > mid) {\n            left = mid + 1 // 3\n        } else if (sqrt < mid) {\n            right = mid - 1 // 3 2\n        }\n    }\n    return right // 这里返回 right 而不是 left 的原因: 用了 Math.floor, mid 会偏小, 相应 sqrt 会偏大\n}\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"有序数组的 Single Element")),(0,o.kt)("p",null,(0,o.kt)("a",u({parentName:"p"},{href:"https://leetcode.com/problems/single-element-in-a-sorted-array/description/"}),"Leetcode : 540. Single Element in a Sorted Array (Medium)")),(0,o.kt)("p",null,"题目描述: 一个有序数组只有一个数不出现两次, 找出这个数。"))}c.isMDXComponent=!0}}]);