(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9485],{89485:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>i});var r=t(59713),l=t.n(r),o=t(6479),a=t.n(o),p=(t(67294),t(3905));function u(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?u(Object(t),!0).forEach((function(n){l()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):u(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var c={};function i(e){var n=e.components,t=a()(e,["components"]);return(0,p.kt)("wrapper",s(s(s({},c),t),{},{components:n,mdxType:"MDXLayout"}),(0,p.kt)("h2",null,"数据类型"),(0,p.kt)("p",null,"在 TypeScript 进行类型定义的时候尽量不使用 Object、Boolean、Array、Function 等大写开头的标识来定义类型，因为它们在 JavaScript 中都是具体的函数对象，取而代之地应该使用 object、boolean、[]、() => void。"),(0,p.kt)("h3",null,"字符串类型"),(0,p.kt)("p",null,"一个保存字符串的文本，类型声明为 string。"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-ts"}),"let name: string = 'muyy'\n")),(0,p.kt)("h3",null,"布尔值类型"),(0,p.kt)("p",null,"boolean 是 true 或 false 的值，所以 ",(0,p.kt)("inlineCode",{parentName:"p"},"let isBool3: boolean = new Boolean(1)")," 就会编译报错，因为 new Boolean(1) 生成的是一个 Bool 对象。"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-ts"}),"let isBool1: boolean = false\n")),(0,p.kt)("h3",null,"数字类型"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-ts"}),"let number: number = 10;\n")),(0,p.kt)("h3",null,"数组类型"),(0,p.kt)("p",null,"数组是 Array 类型。然而，因为数组是一个集合，我们还需要指定在数组中的元素的类型。我们通过 ",(0,p.kt)("inlineCode",{parentName:"p"},"Array<type>")," or ",(0,p.kt)("inlineCode",{parentName:"p"},"type[]")," 语法为数组内的元素指定类型。"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-ts"}),'let arr: number[] = [1, 2, 3, 4, 5]\nlet arr2: Array<number> = [1, 2, 3, 4, 5]\n\nlet arr3: string[] = ["1","2"]\nlet arr4: Array<string> = ["1","2"]\n')),(0,p.kt)("h3",null,"Tuple 类型"),(0,p.kt)("p",null,"Tuple 类型相对于 Array 类型, 其允许元素的类型不一定相同。"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-js"}),"let x: [string, number]\nx = ['a', 1]\n")),(0,p.kt)("h3",null,"enums 类型"),(0,p.kt)("p",null,"列出所有可用值，一个枚举的默认初始值是 0。一开始的范围可以作如下调整:"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-ts"}),"enum Role {Employee = 3, Manager, Admin}\nlet role: Role = Role.Employee\nconsole.log(role) // 3\nconsole.log(Role[4]) // Manager\n")),(0,p.kt)("h3",null,"any 类型"),(0,p.kt)("p",null,"any 是默认的类型，其类型的变量允许任何类型的值："),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-ts"}),'let notSure:any = 10\nlet notSure2:any[] = [1,"2",false]\n')),(0,p.kt)("h3",null,"void 类型"),(0,p.kt)("p",null,"JavaScript 没有空值 void 的概念，在 TypeScirpt 中，可以用 void 表示没有任何返回值的函数："),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-ts"}),"function alertName(): void {\n  console.log('My name is muyy')\n}\n")),(0,p.kt)("p",null,"此外，需注意的是如果在函数声明的变量后方声明 () => void，函数中是可以返回任意值，只不过结果类型仍然为 void。"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-ts"}),"✅\nconst f1: () => void = function() {\n  return true\n}\n\n❎\nconst f3 = function(): void {\n  return true\n}\n")),(0,p.kt)("h3",null,"unknow 类型"),(0,p.kt)("p",null,"任何使用 any 类型的地方推荐使用 unknow 类型代替它。"),(0,p.kt)("blockquote",null,(0,p.kt)("p",{parentName:"blockquote"},(0,p.kt)("a",s({parentName:"p"},{href:"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type"}),"new-unknown-top-type"),", 比 any 更加安全的类型")),(0,p.kt)("p",null,"如果没有断言或缩小到更具体的类型，则不允许对 unknow 类型做任何操作。比如下方例子:"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-ts"}),"function f(x: unknown) {\n  x == 5;\n  x !== 10;\n  x >= 0; // Error\n  x + 1; // Error\n  x * 2; // Error\n  -x; // Error\n  +x; // Error\n  x.foo; // Error\n  x[5]; // Error\n  x(); // Error\n}\n")),(0,p.kt)("h3",null,"never 类型"),(0,p.kt)("p",null,"当函数 throw 或者返回错误, 循环永远为 true 时可以声明为 ",(0,p.kt)("a",s({parentName:"p"},{href:"https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-never-type"}),"never 类型"),"。"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-js"}),'// Function returning never must have unreachable end point\nfunction error(message: string): never {\n  throw new Error(message)\n}\n\n// Inferred return type is never\nfunction fail() {\n  return error("Something failed")\n}\n\n// Function returning never must have unreachable end point\nfunction infiniteLoop(): never {\n  while (true) { ... }\n}\n')))}i.isMDXComponent=!0}}]);