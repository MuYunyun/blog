(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3169],{73169:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>c});var r=t(59713),l=t.n(r),i=t(6479),o=t.n(i),a=(t(67294),t(3905));function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function u(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){l()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var p={};function c(e){var n=e.components,t=o()(e,["components"]);return(0,a.kt)("wrapper",u(u(u({},p),t),{},{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h3",null,"title"),(0,a.kt)("p",null,"Reverse a linked list from position m to n. Do it in one-pass."),(0,a.kt)("p",null,"Note: 1 ≤ m ≤ n ≤ length of list."),(0,a.kt)("p",null,"Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-js"}),"Input: 1->2->3->4->5->NULL, m = 2, n = 4\nOutput: 1->4->3->2->5->NULL\n")),(0,a.kt)("h3",null,"Analyze"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-js"}),"1 -> 2 -> 3 -> 4 -> 5\n    (4 -> 3 -> 2)\n")),(0,a.kt)("p",null,"该题是",(0,a.kt)("a",u({parentName:"p"},{href:"https://github.com/MuYunyun/blog/blob/master/BasicSkill/LeetCode/206.Reverse_Linked_List/README.md"}),"206.Reverse",(0,a.kt)("em",{parentName:"a"},"Linked")," List")," 的扩展, ","[m, n]"," 区间内指针翻转的思路同 206 题, 剩下的就是将 m 的 next 指向 n 指针的 next, 同时将排在 m 前面一位的指针的 next 指向 n。"),(0,a.kt)("p",null,"会存在以下卡题的点:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"最终返回的值怎么定;"),(0,a.kt)("li",{parentName:"ul"},"如何借助中间变量;")),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *   this.val = val;\n *   this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} m\n * @param {number} n\n * @return {ListNode}\n */\nvar reverseBetween = function(head, m, n) {\n  const originList = new ListNode(0)\n  originList.next = head\n\n  let listNode = originList\n\n  for (let i = 0; i < m - 1; i++) {\n    listNode = listNode.next\n  }\n\n  let prev = null\n  let cur = listNode.next\n\n  for (let i = 0; i < n - m + 1; i++) {\n    let next = cur.next\n    cur.next = prev\n    prev = cur\n    cur = next\n  }\n\n  // 将 m 的 next 指向 n 指针的 next, 同时将排在 m 前面一位的指针的 next 指向 n\n  listNode.next.next = cur\n  listNode.next = prev\n  return originList.next\n}\n")),(0,a.kt)("h3",null,"Sister Title"),(0,a.kt)("p",null,"206"))}c.isMDXComponent=!0}}]);