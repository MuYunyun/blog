(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5547],{15547:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>u});var r=n(59713),l=n.n(r),o=n(6479),a=n.n(o),p=(n(67294),n(3905));function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){l()(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var s={};function u(e){var t=e.components,n=a()(e,["components"]);return(0,p.kt)("wrapper",i(i(i({},s),n),{},{components:t,mdxType:"MDXLayout"}),(0,p.kt)("h3",null,"CheckBox 组件"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"勾的定制化: 首先使用 ",(0,p.kt)("inlineCode",{parentName:"li"},"appearance: none")," 去掉原生自带的勾。接着创建一个矩形, 保留 ",(0,p.kt)("inlineCode",{parentName:"li"},"border-left")," 与 ",(0,p.kt)("inlineCode",{parentName:"li"},"border-bottom")," 的边, 进行旋转得到勾。")),(0,p.kt)("h3",null,"能用 css 解决的场景尽量用 css 解决"),(0,p.kt)("p",null,(0,p.kt)("img",i({parentName:"p"},{src:"http://with.muyunyun.cn/6a44d5cba2693eea4e162f8514aa72ba.jpg",alt:null}))),(0,p.kt)("p",null,"场景: 蓝色区域为可以更改 ",(0,p.kt)("inlineCode",{parentName:"p"},"checked")," 的地方, 最开始使用 JS 计算出区域 1 与区域 2 的宽度, 使之相加得到蓝色区域的宽度。其实使用 css 中的 ",(0,p.kt)("inlineCode",{parentName:"p"},"display: inline-block")," 可以自动获取子节点的宽度。"),(0,p.kt)("h3",null,"css 的常量属性(比如 color、size)不要设置默认属性值(defaultProps)"),(0,p.kt)("p",null,"使用了默认属性值则会配合 JS 动态插入到 ",(0,p.kt)("inlineCode",{parentName:"p"},"style")," 属性, 这样子有个缺陷: 用户传入自定义的 ",(0,p.kt)("inlineCode",{parentName:"p"},"class 属性")," 不会生效。(因为 style 的优先级大于 class 传入的优先级)"))}u.isMDXComponent=!0}}]);