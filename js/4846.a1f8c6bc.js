(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4846],{94846:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>d});var r=t(59713),l=t.n(r),a=t(6479),i=t.n(a),o=(t(67294),t(3905));function u(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?u(Object(t),!0).forEach((function(n){l()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):u(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var p={};function d(e){var n=e.components,t=i()(e,["components"]);return(0,o.kt)("wrapper",s(s(s({},p),t),{},{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h3",null,"二叉树"),(0,o.kt)("p",null,(0,o.kt)("img",s({parentName:"p"},{src:"http://with.muyunyun.cn/c3bc86f87907fedaeba86b0f5b96a71a.jpg-300",alt:null}))),(0,o.kt)("p",null,"这棵树中最多有两个分支, 因此是",(0,o.kt)("inlineCode",{parentName:"p"},"二叉树"),"。"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"根节点"),": 一棵树最顶部的节点"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"内部节点"),": 在它上面还有其它内部节点或者叶节点的节点"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"叶节点"),": 处于一棵树根部的节点"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"子树"),": 由树中的内部节点和叶节点组成")),(0,o.kt)("h3",null,"概念延伸"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"完全二叉树"),"(compelete binary tree):",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"除了最后一行都满;"),(0,o.kt)("li",{parentName:"ul"},"在最后一行不满的情况下不能只存有右子树而没有左子树;")))),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),"          1\n       ↙     ↘\n     2         3\n  ↙\n4\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"满二叉树"),"(full binary tree):",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"每一行都满;")))),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),"           1\n        ↙     ↘\n     2          3\n  ↙     ↘    ↙    ↘\n4        5  6       7\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"二叉搜索树"),"(Binary Search Tree)",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"左侧子节点的数字小于父节点, 右侧子节点的数字大于父节点")))),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),"           11\n        ↙     ↘\n     7          15\n  ↙    ↘      ↙    ↘\n8        9   13     20\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"平衡二叉树"))),(0,o.kt)("p",null,"二叉收缩树最好的情况下查找效率是比较高, 比如上图中时间复杂度为 ",(0,o.kt)("inlineCode",{parentName:"p"},"O(logn)"),", 其访问性能近似于二分查找, 但最差时时间复杂度为 ",(0,o.kt)("inlineCode",{parentName:"p"},"O(n)"),", 如下示意:"),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),"7\n  ↘\n    8\n      ↘\n        9\n          ↘\n            11\n              ↘\n                13\n                  ↘\n                    15\n                      ↘\n                        20\n")),(0,o.kt)("p",null,"基于此需要在二叉搜索树基础上做一下平衡,"),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),"7                                    8\n  ↘              平衡后            ↙    ↘\n    8           -------\x3e         7        9\n      ↘\n        9\n")),(0,o.kt)("h3",null,"二叉搜索树的实现"),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),"function BinarySearchTree() {\n  function Node(key) {\n    this.key = key\n    this.left = null\n    this.right = null\n  }\n\n  let root = null\n\n  // 插入元素\n  // 实现思路: 至顶向下插入, 先判断顶点是否为空；顶点为空则直接在该处插入, 若不为空, 则通过比较顶点的 key 和插入元素的 key 判断该插入到顶点的左侧还是右侧, 后面进行如上递归\n  this.insert = function(key) {\n    const node = new Node(key)\n    if (root === null) {\n      root = node\n    } else {\n      insertNode(root, node)\n    }\n    function insertNode(parent, node) {\n      if (parent.key > node.key) {\n        if (parent.left === null) {\n          parent.left = node\n        } else {\n          insertNode(parent.left, node)\n        }\n      } else if (parent.key < node.key) {\n        if (parent.right === null) {\n          parent.right = node\n        } else {\n          insertNode(parent.right, node)\n        }\n      }\n    }\n  }\n\n  // 中序遍历\n  this.inOrderTraverse = function(cb) {\n    inOrderTraverse(root, cb)\n    function inOrderTraverse(node, cb) {\n      if (node) {\n        inOrderTraverse(node.left, cb)\n        cb(node.key)\n        inOrderTraverse(node.right, cb)\n      }\n    }\n  }\n\n  // 先序遍历\n  this.preOrderTraverse = function(cb) {\n    preOrderTraverse(root, cb)\n    function preOrderTraverse(node, cb) {\n      if (node) {\n        cb(node.key)\n        preOrderTraverse(node.left, cb)\n        preOrderTraverse(node.right, cb)\n      }\n    }\n  }\n\n  // 后序遍历\n  this.postOrderTraverse = function(cb) {\n    postOrderTraverse(root, cb)\n    function postOrderTraverse(node, cb) {\n      if (node) {\n        postOrderTraverse(node.left, cb)\n        postOrderTraverse(node.right, cb)\n        cb(node.key)\n      }\n    }\n  }\n\n  // 最大值: 思路最右边\n  this.max = function() {\n    let maxResult = {}\n    function getMax(node) {\n      if (node && node.right) {\n        maxResult = node.right\n        getMax(node.right)\n      }\n    }\n    getMax(root)\n    return maxResult.key\n  }\n\n  // 最小值: 思路最左边\n  this.min = function() {\n    let minResult = {}\n    function getMin(node) {\n      if (node && node.left) {\n        minResult = node.left\n        getMin(node.left)\n      }\n    }\n    getMin(root)\n    return minResult.key\n  }\n\n  // 查找指定元素\n  this.search = function(key) {\n    const searchKey = function(node) {\n      if (!node) {\n        return false\n      }\n      if (key > node.key) {\n        return searchKey(node.right)\n      } else if (key < node.key) {\n        return searchKey(node.left)\n      } else {\n        return true\n      }\n    }\n\n    return searchKey(root)\n  }\n\n  // 移除指定 key 值\n  this.remove = function(key) {\n    const removeKey = function(node, key) {\n      if (key < node.key) {         // ① 如果 key 值在传入节点的左边\n        node.left = removeKey(node.left, key)\n        return node\n      } else if (key > node.key) {  // ② 如果 key 值在传入节点的右边\n        node.right = removeKey(node.right, key)\n        return node\n      } else {                      // ③ 如果找到了 key 值\n        if (node.left === null && node.right === null) { // 删除的节点为根节点\n          node = null\n          return node\n        }\n        if (node.left === null) {                        // 删除的节点下有一个分支\n          node = node.right\n          return node\n        } else if (node.right === null) {\n          node = node.left\n          return node\n        }\n        const minNode = findMinNode(node.right)          // 删除的节点下有两个分支\n        node.key = minNode.key\n        node.right = removeKey(node.right, minNode.key)\n        return node\n      }\n    }\n\n    // 查找最小的节点\n    const findMinNode = function(node) {\n      if (node.left) {\n        return findMinNode(node.left)\n      } else {\n        return node\n      }\n    }\n\n    removeKey(root, key)\n  }\n}\n\nvar tree = new BinarySearchTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(3)\ntree.insert(9)\ntree.insert(8)\ntree.insert(10)\ntree.insert(13)\ntree.insert(12)\ntree.insert(14)\ntree.insert(20)\ntree.insert(18)\ntree.insert(25)\ntree.insert(6)\n")),(0,o.kt)("h3",null,"三种遍历方式的不同"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"中序遍历: 可用于",(0,o.kt)("inlineCode",{parentName:"li"},"二叉搜索树的排序"))),(0,o.kt)("p",null,(0,o.kt)("img",s({parentName:"p"},{src:"http://with.muyunyun.cn/ceeb68f801304f9910073708dd35ae64.jpg-300",alt:null}))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"先序遍历: 可用于",(0,o.kt)("inlineCode",{parentName:"li"},"打印结构化的文档"))),(0,o.kt)("p",null,(0,o.kt)("img",s({parentName:"p"},{src:"http://with.muyunyun.cn/65df3e9414f594107d95127f8ab5a9a1.jpg-300",alt:null}))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"后序遍历: 可用于查看文件夹目录")),(0,o.kt)("p",null,(0,o.kt)("img",s({parentName:"p"},{src:"http://with.muyunyun.cn/212607e3b24b52c0df959902ed8e4b1f.jpg-300",alt:null}))),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"三者都为 DFS, 本质在于节点的访问时机不同。")),(0,o.kt)("p",null,"三种遍历的实现方式大同小异, 可在上面代码中观察到实现的差异。如下是 Leetcode 中对应三种不同遍历方式的题目:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",s({parentName:"li"},{href:"https://github.com/MuYunyun/blog/blob/master/LeetCode/144.Binary_Tree_Preorder_Traversal/README.md"}),"Binary Tree Preorder Traversal")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",s({parentName:"li"},{href:"https://github.com/MuYunyun/blog/blob/master/LeetCode/94.Binary_Tree_Inorder_Traversal/README.md"}),"Binary Tree Inorder Traversal")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",s({parentName:"li"},{href:"https://github.com/MuYunyun/blog/blob/master/LeetCode/145.Binary_Tree_Postorder_Traversal/README.md"}),"Binary Tree Postorder Traversal"))),(0,o.kt)("h3",null,"remove 的几种情况"),(0,o.kt)("p",null,"remove 方法是二叉查找树中相对复杂的实现。思路仍然是递归。"),(0,o.kt)("p",null,"如果要删除的 key 在传入节点的左侧, 则递归调用 removeKey(node.left, key)；"),(0,o.kt)("p",null,"如果要删除的 key 在传入节点的右侧, 则递归调用 removeKey(node.right, key)；"),(0,o.kt)("p",null,"如果要删除的 key 与传入节点相等, 有如下三种情况:"),(0,o.kt)("p",null,"①: 删除的节点为根节点"),(0,o.kt)("p",null,(0,o.kt)("img",s({parentName:"p"},{src:"http://with.muyunyun.cn/65bd1b2b99db8a342423733d0480a7b6.jpg-300",alt:null}))),(0,o.kt)("p",null,"②: 删除的节点下有一个分支"),(0,o.kt)("p",null,(0,o.kt)("img",s({parentName:"p"},{src:"http://with.muyunyun.cn/78707683d0498daa0115d445df11f83e.jpg-300",alt:null}))),(0,o.kt)("p",null,"③: 删除的节点下有两个分支"),(0,o.kt)("p",null,"这里的思路是找到当前节点的右分支中最小的节点, 然后将该节点代替当前节点, 同时移除当前节点的右分支中最小的节点"),(0,o.kt)("p",null,(0,o.kt)("img",s({parentName:"p"},{src:"http://with.muyunyun.cn/4107c561ed1134093333e1b16c7350f4.jpg-300",alt:null}))),(0,o.kt)("h3",null,"测试用例"),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),"var tree = new BinarySearchTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(3)\ntree.insert(9)\ntree.insert(8)\ntree.insert(10)\ntree.insert(13)\ntree.insert(12)\ntree.insert(14)\ntree.insert(20)\ntree.insert(18)\ntree.insert(25)\ntree.insert(6)\n\nvar cb = (key) => console.log(key)\n\ntree.inOrderTraverse(cb)   // 中序遍历: 3 5 6 7 8 9 10 11 12 13 14 15 18 20 25\ntree.preOrderTraverse(cb)  // 先序遍历: 11 7 5 3 6 9 8 10 15 13 12 14 20 18 25\ntree.postOrderTraverse(cb) // 后序遍历: 3 6 5 8 10 9 7 12 14 13 18 25 20 15 11\n\ntree.max() // 25\ntree.max() // 3\n\ntree.search(6) // true\ntree.search(1) // false\n")))}d.isMDXComponent=!0}}]);