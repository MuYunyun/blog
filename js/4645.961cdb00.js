(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4645],{54645:n=>{n.exports="### 98.Validate Binary Search Tree\n\nGiven a binary tree, determine if it is a valid binary search tree (BST).\n\nAssume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\n \nExample 1:\n\n```js\n    2\n   / \\\n  1   3\n\nInput: [2,1,3]\nOutput: true\n```\n\nExample 2:\n\n```js\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n\nInput: [5,1,4,null,null,3,6]\nOutput: false\n```\n\nExplanation: The root node's value is 5 but its right child's value is 4.\n\n### Analyze\n\n一开始的想法是用后续遍历判断子节点是否为二分搜索树, 实现如下:\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n  return isValidBSTChild(root)\n};\n\nvar isValidBSTChild = function(node) {\n  if (!node || (!node.left && !node.right)) return true\n\n  const isLeftChildValidBST = isValidBSTChild(node.left)\n  const isRightChildValidBST = isValidBSTChild(node.right)\n  if (!isLeftChildValidBST || !isRightChildValidBST) return false\n\n  // defination for BST tree\n  if (node.right && node.left && node.right.val > node.val && node.val > node.left.val) return true\n  if (node.right && !node.left && node.right.val > node.val) return true\n  if (node.left && !node.right && node.left.val < node.val) return true\n  return false\n};\n```\n\n结果卡在了如下测试用例中:\n\n```js\n    10\n   /  \\\n  5   15\n     /  \\\n    6   20\n\nInput: [10,5,15,null,null,6,20]\nExpect Output: false\n```\n\n参考评论区的点拨, 题目等价为经过`中序遍历`输出后的节点是否为升序排列。再次实现:\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n  const analyze = []\n  inOrderTraverse(root, analyze)\n  for (let i = 0; i < analyze.length; i++) {\n    if (analyze[i] >= analyze[i + 1]) return false\n  }\n  return true\n};\n\nvar inOrderTraverse = function(node, analyzeArr) {\n  if (!node) return\n  inOrderTraverse(node.left, analyzeArr)\n  analyzeArr.push(node.val)\n  inOrderTraverse(node.right, analyzeArr)\n}\n```\n"}}]);