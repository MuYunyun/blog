(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1695],{71695:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>c});var r=t(59713),l=t.n(r),o=t(6479),a=t.n(o),s=(t(67294),t(3905));function u(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function i(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?u(Object(t),!0).forEach((function(e){l()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):u(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var p={};function c(n){var e=n.components,t=a()(n,["components"]);return(0,s.kt)("wrapper",i(i(i({},p),t),{},{components:e,mdxType:"MDXLayout"}),(0,s.kt)("h3",null,"257. Binary Tree Paths"),(0,s.kt)("p",null,"Given a binary tree, return all root-to-leaf paths."),(0,s.kt)("p",null,"Note: A leaf is a node with no children."),(0,s.kt)("p",null,"Example:"),(0,s.kt)("pre",null,(0,s.kt)("code",i({parentName:"pre"},{className:"language-js"}),'Input:\n\n   1\n /   \\\n2     3\n \\\n  5\n\nOutput: ["1->2->5", "1->3"]\n')),(0,s.kt)("p",null,"Explanation: All root-to-leaf paths are: 1->2->5, 1->3"),(0,s.kt)("h3",null,"Analyze"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"DFS 深度优先遍历的运用, 关键需要想清楚采用先序、中序、后序遍历中的哪一种。",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"先序遍历: 1 -> 2 -> 5, 1 -> 3")))),(0,s.kt)("pre",null,(0,s.kt)("code",i({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {string[]}\n */\nvar binaryTreePaths = function(root) {\n  const result = []\n  if (!root) return result\n\n  printTreePaths(root, result, '')\n  return result\n}\n\nvar printTreePaths = function(node, result, str) {\n  if (!node.left && !node.right) {\n    str += `${node.val}`\n    result.push(str)\n    return\n  }\n\n  str += `${node.val}->`\n\n  if (node.left) {\n    printTreePaths(node.left, result, str)\n  }\n\n  if (node.right) {\n    printTreePaths(node.right, result, str)\n  }\n}\n")))}c.isMDXComponent=!0}}]);