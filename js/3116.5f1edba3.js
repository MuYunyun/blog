(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3116],{53116:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>p});var r=n(59713),s=n.n(r),c=n(6479),o=n.n(c),a=(n(67294),n(3905));function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function u(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s()(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var x={};function p(e){var t=e.components,n=o()(e,["components"]);return(0,a.kt)("wrapper",u(u(u({},x),n),{},{components:t,mdxType:"MDXLayout"}),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-js"}),"const http = require('http')\nconst EventEmitter = require('events')\nconst context = require('./context')\nconst request = require('./request')\nconst response = require('./response')\n\nclass Koa extends EventEmitter {\n  constructor() {\n    super()\n    this.middlewares = []\n    this.context = context\n    this.request = request\n    this.response = response\n  }\n\n  listen(...args) {\n    http.createServer(this.callback()).listen(...args)\n  }\n\n  use(fn) {\n    this.middlewares.push(fn)\n  }\n\n  // 引人中间件\n  compose(ctx) {\n    const createAsync = function (fn, next) {\n      return async function () {\n        await fn(ctx, next)\n      }\n    }\n    let next = async function() { // 返回 Promise 对象, 从而进行后文 fn.then().catch() 调用\n      return Promise.resolve()\n    }\n\n    for (let i = this.middlewares.length - 1; i >= 0; i--) {\n      next = createAsync(this.middlewares[i], next)\n    }\n\n    return next()\n  }\n\n  callback() {\n    return (req, res) => {\n      const ctx = this.createCtx(req, res)\n      const handle = () => this.handleRes(ctx)\n      const errHandle = (err) => this.handleErr(err, ctx)\n      const fn = this.compose(ctx)\n      fn.then(handle).catch(errHandle)\n    }\n  }\n\n  // 将 req,  res 封装进 ctx 对象中\n  createCtx(req, res) {\n    const ctx = Object.create(this.context)\n    ctx.request = Object.create(this.request)\n    ctx.response = Object.create(this.response)\n    ctx.req = ctx.request.req = req\n    ctx.res = ctx.response.res = res\n    return ctx\n  }\n\n  handleRes(ctx) {\n    if (typeof(ctx.body) === 'string') {\n      ctx.statusCode && ctx.res.writeHead(ctx.statusCode)\n      ctx.res.end(ctx.body)\n    } else if (typeof(ctx.body) === 'object') {\n      ctx.statusCode && ctx.res.writeHead(ctx.statusCode)\n      ctx.res.end(JSON.stringify(ctx.body))\n    }\n  }\n\n  // 引人错误机制\n  handleErr(err, ctx) {\n    if (err.code === 'ENOENT') {\n      ctx.statusCode = 404\n    } else {\n      ctx.statusCode = 500\n    }\n    const msg = err.message || 'Internal Error'\n    ctx.res.end(msg)\n    this.emit('error', err)\n  }\n}\n\nmodule.exports = Koa\n")))}p.isMDXComponent=!0}}]);