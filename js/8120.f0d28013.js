(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8120],{88120:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>c});var l=t(59713),r=t.n(l),u=t(6479),i=t.n(u),a=(t(67294),t(3905));function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(n);e&&(l=l.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,l)}return t}function p(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){r()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var s={};function c(n){var e=n.components,t=i()(n,["components"]);return(0,a.kt)("wrapper",p(p(p({},s),t),{},{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h3",null,"234.Palindrome Linked List"),(0,a.kt)("p",null,"Given a singly linked list, determine if it is a palindrome."),(0,a.kt)("p",null,"Example 1:"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-js"}),"Input: 1->2\nOutput: false\n")),(0,a.kt)("p",null,"Example 2:"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-js"}),"Input: 1->2->2->1\nOutput: true\n")),(0,a.kt)("p",null,"Follow up:\nCould you do it in O(n) time and O(1) space?"),(0,a.kt)("h3",null,"Analyze"),(0,a.kt)("p",null,"思路比较清晰直观, 步骤如下:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"第一步: 使用快慢指针找到链表中点, 链表分割为左右两部分;"),(0,a.kt)("li",{parentName:"ol"},"第二步: 翻转右边的链表节点;"),(0,a.kt)("li",{parentName:"ol"},"第三步: 比较左右两边的节点;")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"该题与题目 ",(0,a.kt)("a",p({parentName:"p"},{href:"https://github.com/MuYunyun/blog/blob/master/LeetCode/143.Reorder_List/README.md"}),"143.Reorder_List")," 十分类似。")),(0,a.kt)("p",null,"步骤图解:"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-js"}),"第一步: 找中点, 分割链表;\n                        q\n              s\ndummy -> 1 -> 2 -> 2 -> 1 -> NULL\n              .\n              .\n                        q\n              s\ndummy -> 1 -> 2 -> 2 -> 1 -> NULL\n\nleft 链表:\n1 -> 2 -> null\n\nright 链表:\n2 -> 1 -> null\n\n第二步: 翻转右边的链表节点;\n\nleft 链表:\n1 -> 2 -> null\n\nright 链表:\n1 -> 2 -> null\n\n第三步: 判断 left 链表与 right 链表;\n")),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\nvar isPalindrome = function(head) {\n  const dummy = new ListNode(0)\n  dummy.next = head\n\n  let slow = dummy, quick = dummy\n  while (quick && quick.next) {\n    slow = slow.next\n    quick = quick.next.next\n  }\n\n  let right = slow.next\n  slow.next = null\n  let left = dummy.next\n\n  right = reverseLink(right)\n\n  while (left && right) {\n    if (left.val !== right.val) {\n      return false\n    }\n    left = left.next\n    right = right.next\n  }\n  return true\n}\n\nfunction reverseLink(list) {\n  const dummy = new ListNode(0)\n  dummy.next = list\n\n  let prev = null\n  let cur = dummy.next\n\n  while (cur) {\n    const next = cur.next\n    cur.next = prev\n    prev = cur\n    cur = next\n  }\n\n  return prev\n}\n")),(0,a.kt)("p",null,(0,a.kt)("img",p({parentName:"p"},{src:"http://with.muyunyun.cn/f1d261951e75505802e0b5b8ea8848bc.jpg",alt:null}))),(0,a.kt)("h3",null,"Sister Title"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",p({parentName:"li"},{href:"(https://github.com/MuYunyun/blog/blob/master/LeetCode/143.Reorder_List/README.md)"}),"143.Reorder_List"))))}c.isMDXComponent=!0}}]);