(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3475],{3475:n=>{n.exports="### title\n\n给定一个字符串, 请将字符串里的字符按照出现的频率`降序排列`。\n\n示例 1:\n\n```js\n输入:\n\"tree\"\n\n输出:\n\"eert\"\n```\n\n解释: 'e'出现两次，'r'和't'都只出现一次。\n因此'e'必须出现在'r'和't'之前。此外，\"eetr\"也是一个有效的答案。\n\n示例 2:\n\n```js\n输入:\n\"cccaaa\"\n\n输出:\n\"cccaaa\"\n```\n\n解释: 'c'和'a'都出现三次。此外，\"aaaccc\"也是有效的答案。\n注意\"cacaca\"是不正确的，因为相同的字母必须放在一起。\n\n示例 3:\n\n```js\n输入:\n\"Aabb\"\n\n输出:\n\"bbAa\"\n```\n\n解释: 此外，\"bbaA\"也是一个有效的答案，但\"Aabb\"是不正确的。\n注意'A'和'a'被认为是两种不同的字符。\n\n### 题解\n\n思路: 根据题意, 本题用 Map 来存储字符出现的频率, 难点在如何处理 Map 中对象出现的频率? 以下解法使用 arr 将 map 里的值存储转化为 `[{ key, value }]` 的形式, 最后使用 JS 的 sort 方法来完成题解。\n\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar frequencySort = function(s) {\n  const map = new Map()\n  for (let i = 0; i < s.length; i++) {\n    const getMap = map.get(s[i])\n    if (!getMap) {\n      map.set(s[i], 1)\n    } else {\n      map.set(s[i], getMap + 1)\n    }\n  }\n\n  const arr = []\n  for (let key of map.keys()) {\n    arr.push({\n      key,\n      value: map.get(key)\n    })\n  }\n\n  // todo 后续实现下以下排序\n  arr.sort((a, b) => b.value - a.value)\n\n  const result = arr.map(r => {\n    let str = ''\n    for (let i = 0; i < r.value; i++) {\n      str = str + r.key\n    }\n    return str\n  }).join('')\n\n  return result\n};\n```\n\n### 归类\n\nmap"}}]);