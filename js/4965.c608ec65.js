(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4965],{44965:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>i});var a=t(59713),l=t.n(a),r=t(6479),s=t.n(r),p=(t(67294),t(3905));function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function u(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){l()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var c={};function i(e){var n=e.components,t=s()(e,["components"]);return(0,p.kt)("wrapper",u(u(u({},c),t),{},{components:n,mdxType:"MDXLayout"}),(0,p.kt)("h3",null,"命令式编程和声明式编程"),(0,p.kt)("p",null,"拿泡茶这个事例进行区分命令式编程和声明式编程"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"命令式编程")),(0,p.kt)("p",null,"1.烧开水(为第一人称)\n2.拿个茶杯\n3.放茶叶\n4.冲水"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"声明式编程")),(0,p.kt)("p",null,"1.给我泡杯茶(为第二人称)"),(0,p.kt)("p",null,"举个 demo"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"// 命令式编程\nconst convert = function(arr) {\n  const result = []\n  for (let i = 0; i < arr.length; i++) {\n    result[i] = arr[i].toLowerCase()\n  }\n  return result\n}\n\n// 声明式编程\nconst convert = function(arr) {\n  return arr.map(r => r.toLowerCase())\n}\n")),(0,p.kt)("h3",null,"什么是函数式编程"),(0,p.kt)("p",null,"函数式编程是声明式编程的范式。在函数式编程中数据在由纯函数组成的管道中传递。"),(0,p.kt)("blockquote",null,(0,p.kt)("p",{parentName:"blockquote"},"函数式编程可以用简单如",(0,p.kt)("inlineCode",{parentName:"p"},"交换律、结合律、分配律"),"的数学之法来帮我们简化代码的实现。")),(0,p.kt)("p",null,"它具有如下一些特性:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"纯粹性: 纯函数不改变除当前作用域以外的值;")),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"// 反面示例\nlet a = 0\nconst add = (b) => a = a + b // 两次 add(1) 结果不一致\n\n// 正确示例\nconst add = (a, b) => a + b\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"数据不可变性: Immutable")),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"// 反面示例\nconst arr = [1, 2]\nconst arrAdd = (value) => {\n  arr.push(value)\n  return arr\n}\n\narrAdd(3) // [1, 2, 3]\narrAdd(3) // [1, 2, 3, 3]\n\n// 正面示例\nconst arr = [1, 2]\nconst arrAdd = (value) => {\n  return arr.concat(value)\n}\n\narrAdd(3) // [1, 2, 3]\narrAdd(3) // [1, 2, 3]\n")),(0,p.kt)("blockquote",null,(0,p.kt)("p",{parentName:"blockquote"},"在后记 1 中对数组字符串方法是否对原值有影响作了整理")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"函数柯里化: 将多个入参的函数转化为一个入参的函数;")),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"const add = a => b => c => a + b + c\nadd(1)(2)(3)\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"偏函数: 将多个入参的函数转化成两部分;")),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"const add = a => (b, c) => a + b + c\nadd(1)(2, 3)\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"可组合: 函数之间能组合使用")),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"const add = (x) => x + x\nconst mult = (x) => x * x\n\nconst addAndMult = (x) => add(mult(x))\n")),(0,p.kt)("h3",null,"柯里化(curry)"),(0,p.kt)("p",null,"如下是一个加法函数:"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var add = (a, b, c) => a + b + c\n\nadd(1, 2, 3) // 6\n")),(0,p.kt)("p",null,"假如有这样一个 ",(0,p.kt)("inlineCode",{parentName:"p"},"curry")," 函数, 用其包装 ",(0,p.kt)("inlineCode",{parentName:"p"},"add")," 函数后返回一个新的函数 ",(0,p.kt)("inlineCode",{parentName:"p"},"curryAdd"),", 我们可以将参数 ",(0,p.kt)("inlineCode",{parentName:"p"},"a、b")," 进行分开传递进行调用。"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var curryAdd = curry(add)\n\n// 以下输出结果都相同\ncurryAdd(1, 2, 3) // 6\ncurryAdd(1, 2)(3) // 6\ncurryAdd(1)(2)(3) // 6\ncurryAdd(1)(2, 3) // 6\n")),(0,p.kt)("h4",null,"动手实现一个 curry 函数"),(0,p.kt)("p",null,"核心思路: 若传进去的参数个数未达到 ",(0,p.kt)("inlineCode",{parentName:"p"},"curryAdd")," 的个数，则将参数缓存在闭包变量 lists 中:"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"function curry(fn, ...args) {\n  const length = fn.length\n  let lists = args || []\n\n  let listLen\n  return function (..._args) {\n    lists = [...lists, ..._args]\n    listLen = lists.length\n\n    if (listLen < length) {\n      const that = lists\n      lists = []\n      return curry(fn, ...that)\n    } else if (listLen === length) {\n      const that = lists\n      lists = []\n      return fn.apply(this, that)\n    }\n  }\n}\n")),(0,p.kt)("h3",null,"代码组合(compose)"),(0,p.kt)("p",null,"现在有 ",(0,p.kt)("inlineCode",{parentName:"p"},"toUpperCase"),"、",(0,p.kt)("inlineCode",{parentName:"p"},"reverse"),"、",(0,p.kt)("inlineCode",{parentName:"p"},"head")," 三个函数, 分别如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var toUpperCase = (str) => str.toUpperCase()\nvar reverse = (arr) => arr.reverse()\nvar head = (arr) => arr[0]\n")),(0,p.kt)("p",null,"接着使用它们实现将数组末位元素大写化输出, 可以这样做:"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var reverseHeadUpperCase = (arr) => toUpperCase(head(reverse(arr)))\n\nreverseHeadUpperCase(['apple', 'banana', 'peach']) // PEACH\n")),(0,p.kt)("p",null,"此时在构建 ",(0,p.kt)("inlineCode",{parentName:"p"},"reverseHeadUpperCase")," 函数的时候, 必须手动声明传入参数 arr, 是否能提供一个 ",(0,p.kt)("inlineCode",{parentName:"p"},"compose")," 函数让使用者更加友好的使用呢? 类似如下形式:"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var reverseHeadUpperCase = compose(toUpperCase, head, reverse)\n\nreverseHeadUpperCase(['apple', 'banana', 'peach']) // PEACH\n")),(0,p.kt)("p",null,"此外 ",(0,p.kt)("inlineCode",{parentName:"p"},"compose")," 函数符合",(0,p.kt)("inlineCode",{parentName:"p"},"结合律"),", 我们可以这样子使用:"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"compose(compose(toUpperCase, head), reverse)\ncompose(toUpperCase, compose(head, reverse))\n")),(0,p.kt)("p",null,"以上两种写法与 ",(0,p.kt)("inlineCode",{parentName:"p"},"compose(toUpperCase, head, reverse)")," 的效果完全相同, 都是依次从右到左执行传参中的函数。"),(0,p.kt)("p",null,"此外 ",(0,p.kt)("inlineCode",{parentName:"p"},"compose")," 和 ",(0,p.kt)("inlineCode",{parentName:"p"},"map")," 一起使用时也有相关的结合律, 以下两种写法效果相等"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"compose(map(f), map(g))\nmap(compose(f, g))\n")),(0,p.kt)("h4",null,"动手实现一个 compose 函数"),(0,p.kt)("p",null,"代码精华集中在一行之内, 其为众多开源库(比如 Redux) 所采用。"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var compose = (...args) => (initValue) => args.reduceRight((a, c) => c(a), initValue)\n")),(0,p.kt)("h3",null,"范畴论"),(0,p.kt)("p",null,"范畴论是数学中的一个分支。可以将范畴理解为一个容器, 把原来对值的操作，现转为对容器的操作。如下图:"),(0,p.kt)("p",null,(0,p.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/c65fa1b63dbe9fa0a0771e7e561dc85b.jpg-200",alt:null}))),(0,p.kt)("blockquote",null,(0,p.kt)("p",{parentName:"blockquote"},"学习函数式编程就是学习各种函子的过程。")),(0,p.kt)("p",null,"函数式编程中, ",(0,p.kt)("inlineCode",{parentName:"p"},"函子(Functor)")," 是实现了 ",(0,p.kt)("inlineCode",{parentName:"p"},"map")," 函数的容器, 下文中将函子视为范畴，模型可表示如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"class Functor {\n  constructor(value) {\n    this.value = value\n  }\n\n  map(fn) {\n    return new Functor(fn(this.value))\n  }\n}\n")),(0,p.kt)("p",null,"但是在函数式编程中, 要避免使用 ",(0,p.kt)("inlineCode",{parentName:"p"},"new")," 这种面向对象的编程方式, 取而代之对外暴露了一个 ",(0,p.kt)("inlineCode",{parentName:"p"},"of")," 的接口, 也称为 ",(0,p.kt)("inlineCode",{parentName:"p"},"pointed functor"),"。"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"Functor.of = value => new Functor(value)\n")),(0,p.kt)("h4",null,"Maybe 函子"),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"Maybe 函子"),"是为了解决 ",(0,p.kt)("inlineCode",{parentName:"p"},"this.value")," 为 null 的情形, 用法如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"Maybe.of(null).map(r => r.toUpperCase()) // null\nMaybe.of('m').map(r => r.toUpperCase())  // Maybe {value: \"M\"}\n")),(0,p.kt)("p",null,"实现代码如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"class Maybe {\n  constructor(value) {\n    this.value = value\n  }\n\n  map(fn) {\n    return this.value ? new Maybe(fn(this.value)) : null\n  }\n}\n\nMaybe.of = value => new Maybe(value)\n")),(0,p.kt)("h4",null,"Either 函子"),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"Either 函子")," 是为了对应 ",(0,p.kt)("inlineCode",{parentName:"p"},"if...else...")," 的语法, 即",(0,p.kt)("inlineCode",{parentName:"p"},"非左即右"),"。因此可以将之拆分为 ",(0,p.kt)("inlineCode",{parentName:"p"},"Left")," 和 ",(0,p.kt)("inlineCode",{parentName:"p"},"Right")," 两个函子, 它们的用法如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var left = Left.of(1).map(r => r + 1)  // Left {value: 1}\n\nvar right = Right.of(1).map(r => r + 1) // Right {value: 2}\n")),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"Left 函子"),"实现代码如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"class Left {\n  constructor(value) {\n    this.value = value\n  }\n\n  map(fn) {\n    return this\n  }\n}\n\nLeft.of = value => new Left(value)\n")),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"Right 函子"),"实现代码如下(其实就是上面的 ",(0,p.kt)("inlineCode",{parentName:"p"},"Functor"),"):"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"class Right {\n  constructor(value) {\n    this.value = value\n  }\n\n  map(fn) {\n    return new Right(fn(this.value))\n  }\n}\n\nRight.of = value => new Right(value)\n")),(0,p.kt)("p",null,"具体 ",(0,p.kt)("inlineCode",{parentName:"p"},"Either")," 函数只是对调用 ",(0,p.kt)("inlineCode",{parentName:"p"},"Left 函子")," 或 ",(0,p.kt)("inlineCode",{parentName:"p"},"Right 函子")," 作一层筛选, 其接收 ",(0,p.kt)("inlineCode",{parentName:"p"},"f"),"、",(0,p.kt)("inlineCode",{parentName:"p"},"g")," 两个函数以及一个函子(",(0,p.kt)("inlineCode",{parentName:"p"},"Left or Right"),")"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var Either = function(f, g, functor) {\n  switch(functor.constructor.name) {\n    case 'Left':\n      return f(functor.value)\n    case 'Right':\n      return g(functor.value)\n    default:\n      return f(functor.value)\n  }\n}\n")),(0,p.kt)("p",null,"使用 demo:"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"Either((v) => console.log('left', v), (v) => console.log('def', v), left)   // left 1\nEither((v) => console.log('def', v), (v) => console.log('rigth', v), rigth) // rigth 2\n")),(0,p.kt)("h4",null,"Monad 函子"),(0,p.kt)("p",null,"函子会发生嵌套, 比如下面这样:"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"Functor.of(Functor.of(1)) // Functor { value: Functor { value: 1 } }\n")),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"Monad 函子")," 对外暴露了 ",(0,p.kt)("inlineCode",{parentName:"p"},"join")," 和 ",(0,p.kt)("inlineCode",{parentName:"p"},"flatmap")," 接口, 调用者从而可以扁平化嵌套的函子。"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"class Monad {\n  constructor(value) {\n    this.value = value\n  }\n\n  map(fn) {\n    return new Monad(fn(this.value))\n  }\n\n  join() {\n    return this.value\n  }\n\n  flatmap(fn) {\n    return this.map(fn).join()\n  }\n}\n\nMonad.of = value => new Monad(value)\n")),(0,p.kt)("p",null,"使用方法:"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"// join\nMonad.of(Monad.of(1).join()) // Monad { value: 1 }\nMonad.of(Monad.of(1)).join() // Monad { value: 1 }\n\n// flatmap\nMonad.of(1).flatmap(r => r + 1)  // 2\n")),(0,p.kt)("blockquote",null,(0,p.kt)("p",{parentName:"blockquote"},"Monad 函子可以运用在 I/O 这种不纯的操作上将之变为纯函数的操作，目前比较懵懂，日后补充。")),(0,p.kt)("h3",null,"后记 1: 数组字符串方法小结(是否对原值有影响)"),(0,p.kt)("h4",null,"不会对原数组有影响的方法"),(0,p.kt)("h5",null,"slice"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var test = [1, 2, 3]\nvar result = test.slice(0, 1)\n\nconsole.log(test)   // [1, 2, 3]\nconsole.log(result) // [1]\n")),(0,p.kt)("h5",null,"concat"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var test = [1, 2, 3]\nvar result = test.concat(4)\n\nconsole.log(test)   // [1, 2, 3]\nconsole.log(result) // [1, 2, 3, 4]\n")),(0,p.kt)("h4",null,"对原数组有影响的方法"),(0,p.kt)("h5",null,"splice(这个需要特别记一下)"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var test = [1, 2, 3]\nvar result = test.splice(0, 1)\n\nconsole.log(test)   // [2, 3]\nconsole.log(result) // [1]\n")),(0,p.kt)("h5",null,"sort"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var arr = [2, 1, 3, 4]\narr.sort((r1, r2) => (r1 - r2))\n\nconsole.log(arr) // [1, 2, 3, 4]\n")),(0,p.kt)("h5",null,"reverse"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var test = [1, 2, 3]\nvar result = test.reverse()\n\nconsole.log(test)   // [3, 2, 1]\nconsole.log(result) // [3, 2, 1]\n")),(0,p.kt)("h5",null,"push/pop/unshift/shift"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var test = [1, 2, 3]\nvar result = test.push(4)\n\nconsole.log(test)   // [1, 2, 3, 4]\nconsole.log(result) // 4\n")),(0,p.kt)("h4",null,"不会对原字符串造成影响的方法"),(0,p.kt)("h5",null,"substr/substring/slice"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"// substr\nvar test = 'abc'\nvar result = test.substr(0, 1)\n\nconsole.log(test)   // 'abc'\nconsole.log(result) // a\n\n// substring\nvar test = 'abc'\nvar result = test.substring(0, 1)\n\nconsole.log(test)   // 'abc'\nconsole.log(result) // a\n\n// slice\nvar test = 'abc'\nvar result = test.slice(0, 1)\n\nconsole.log(test)   // 'abc'\nconsole.log(result) // a\n")),(0,p.kt)("h5",null,"replace"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var test = 'abc'\nvar result = test.replace('c', 'd')\n\nconsole.log(test)   // 'abc'\nconsole.log(result) // 'abd'\n")),(0,p.kt)("h3",null,"参考"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("a",u({parentName:"li"},{href:"https://mostly-adequate.gitbooks.io/mostly-adequate-guide"}),"mostly-adequate-guide")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("a",u({parentName:"li"},{href:"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese"}),"JavaScript 函数式编程指南")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("a",u({parentName:"li"},{href:"https://github.com/mqyqingfeng/Blog/issues/42"}),"JavaScript 专题之函数柯里化")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("a",u({parentName:"li"},{href:"http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html"}),"函数式编程入门教程"))))}i.isMDXComponent=!0}}]);