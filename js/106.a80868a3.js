(self.webpackChunkblog=self.webpackChunkblog||[]).push([[106],{10106:(t,e,n)=>{"use strict";n.r(e),n.d(e,{default:()=>p});var r=n(59713),s=n.n(r),i=n(6479),l=n.n(i),a=(n(67294),n(3905));function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function u(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){s()(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}var h={};function p(t){var e=t.components,n=l()(t,["components"]);return(0,a.kt)("wrapper",u(u(u({},h),n),{},{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h3",null,"341.Flatten Nested List Iterator"),(0,a.kt)("p",null,"Given a nested list of integers, implement an ",(0,a.kt)("inlineCode",{parentName:"p"},"iterator")," to flatten it."),(0,a.kt)("p",null,"Each element is either an integer, or a list -- whose elements may also be integers or other lists."),(0,a.kt)("p",null,"Example 1:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-js"}),"Input: [[1,1],2,[1,1]]\nOutput: [1,1,2,1,1]\n")),(0,a.kt)("p",null,"Explanation: By calling next repeatedly until hasNext returns false,\n             the order of elements returned by next should be: ","[1,1,2,1,1]","."),(0,a.kt)("p",null,"Example 2:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-js"}),"Input: [1,[4,[6]]]\nOutput: [1,4,6]\n")),(0,a.kt)("p",null,"Explanation: By calling next repeatedly until hasNext returns false,\n             the order of elements returned by next should be: ","[1,4,6]","."),(0,a.kt)("h3",null,"analyze"),(0,a.kt)("p",null,"该题需注意的点: [1, ","[4]","] 里的子项 1, ","[4]"," 分别通过 ",(0,a.kt)("inlineCode",{parentName:"p"},"getInteger")," 与 ",(0,a.kt)("inlineCode",{parentName:"p"},"getList")," 获取到。"),(0,a.kt)("h3",null,"递归法"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-js"}),"/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * function NestedInteger() {\n *\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     @return {boolean}\n *     this.isInteger = function() {\n *         ...\n *     };\n *\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\n *     Return null if this NestedInteger holds a nested list\n *     @return {integer}\n *     this.getInteger = function() {\n *         ...\n *     };\n *\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\n *     Return null if this NestedInteger holds a single integer\n *     @return {NestedInteger[]}\n *     this.getList = function() {\n *         ...\n *     };\n * };\n */\n/**\n * @constructor\n * @param {NestedInteger[]} nestedList\n */\nvar NestedIterator = function(nestedList) {\n  this.printArr = []\n  this.resetArr(nestedList)\n}\n\nNestedIterator.prototype.resetArr = function(nestedList) {\n  if (!nestedList && !nestedList.length) return\n  for (let i = 0; i < nestedList.length; i++) {\n    const curList = nestedList[i]\n    if (curList.isInteger()) {\n      this.printArr.unshift(curList.getInteger())\n    } else {\n      this.resetArr(curList.getList())\n    }\n  }\n}\n\n/**\n * @this NestedIterator\n * @returns {boolean}\n */\nNestedIterator.prototype.hasNext = function() {\n  return this.printArr.length > 0\n}\n\n/**\n * @this NestedIterator\n * @returns {integer}\n */\nNestedIterator.prototype.next = function() {\n  return this.printArr.pop()\n}\n\n/**\n * Your NestedIterator will be called like this:\n * var i = new NestedIterator(nestedList), a = [];\n * while (i.hasNext()) a.push(i.next());\n*/\n")),(0,a.kt)("h3",null,"迭代法"),(0,a.kt)("p",null,"相对递归法, 迭代法需要额外维护一个",(0,a.kt)("inlineCode",{parentName:"p"},"系统调用栈"),", 然后使用",(0,a.kt)("inlineCode",{parentName:"p"},"颜色标记法"),"完成题解。"),(0,a.kt)("p",null,"颜色标记法思路:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"未访问过的列表标记为",(0,a.kt)("inlineCode",{parentName:"li"},"白色"),", 访问过的列表标记为",(0,a.kt)("inlineCode",{parentName:"li"},"灰色"),";"),(0,a.kt)("li",{parentName:"ul"},"从栈顶取出访问元素:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"若为灰色元素, 则打印之;"),(0,a.kt)("li",{parentName:"ul"},"若为白色元素, 则遍历子列表:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"若子列表为列表, 则将其",(0,a.kt)("inlineCode",{parentName:"li"},"标记为白色"),"并推入栈;"),(0,a.kt)("li",{parentName:"ul"},"若子列表为数字, 则将其",(0,a.kt)("inlineCode",{parentName:"li"},"标记为灰色"),"并推入栈;")))))),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-js"}),"/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * function NestedInteger() {\n *\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     @return {boolean}\n *     this.isInteger = function() {\n *         ...\n *     };\n *\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\n *     Return null if this NestedInteger holds a nested list\n *     @return {integer}\n *     this.getInteger = function() {\n *         ...\n *     };\n *\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\n *     Return null if this NestedInteger holds a single integer\n *     @return {NestedInteger[]}\n *     this.getList = function() {\n *         ...\n *     };\n * };\n */\n/**\n * @constructor\n * @param {NestedInteger[]} nestedList\n */\nvar NestedIterator = function(nestedList) {\n  this.printArr = []\n  if (!nestedList) return\n  this.stackList = []\n  this.stackList.push({ color: 'white', list: nestedList })\n  while (this.stackList.length > 0) {\n    const { color, list } = this.stackList.pop()\n    if (color === 'gray') {\n      this.printArr.unshift(list)\n    } else {\n      for (let i = 0; i < list.length; i++) {\n        if (list[i].isInteger()) {\n          this.stackList.push({ color: 'gray', list: list[i].getInteger() })\n        } else {\n          this.stackList.push({ color: 'white', list: list[i].getList() })\n        }\n      }\n    }\n  }\n}\n\n/**\n * @this NestedIterator\n * @returns {boolean}\n */\nNestedIterator.prototype.hasNext = function() {\n  return this.printArr.length > 0\n}\n\n/**\n * @this NestedIterator\n * @returns {integer}\n */\nNestedIterator.prototype.next = function() {\n  return this.printArr.shift()\n}\n\n/**\n * Your NestedIterator will be called like this:\n * var i = new NestedIterator(nestedList), a = [];\n * while (i.hasNext()) a.push(i.next());\n*/\n")),(0,a.kt)("h3",null,"Similar Title"),(0,a.kt)("p",null,"94、144、145"))}p.isMDXComponent=!0}}]);