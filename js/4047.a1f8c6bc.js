(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4047],{64047:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>k});var r=t(59713),a=t.n(r),l=t(6479),i=t.n(l),p=(t(67294),t(3905));function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var u={};function k(e){var n=e.components,t=i()(e,["components"]);return(0,p.kt)("wrapper",c(c(c({},u),t),{},{components:n,mdxType:"MDXLayout"}),(0,p.kt)("h3",null,"Fiber 的数据结构"),(0,p.kt)("p",null,"此小节会通过两个 ",(0,p.kt)("inlineCode",{parentName:"p"},"demo")," 来展示 ",(0,p.kt)("inlineCode",{parentName:"p"},"Stack Reconciler")," 以及 ",(0,p.kt)("inlineCode",{parentName:"p"},"Fiber Reconciler")," 的数据结构。"),(0,p.kt)("p",null,(0,p.kt)("img",c({parentName:"p"},{src:"http://with.muyunyun.cn/7621091ae74df1bbd8b00586128a7d44.jpg-300v",alt:null}))),(0,p.kt)("p",null,"首先用代码表示上图节点间的关系。比如 ",(0,p.kt)("inlineCode",{parentName:"p"},"a1 节点"),"下有 ",(0,p.kt)("inlineCode",{parentName:"p"},"b1、b2、b3 节点"),", 就可以把它们间的关系写成 ",(0,p.kt)("inlineCode",{parentName:"p"},"a1.render = () => [b1, b2, b3]"),";"),(0,p.kt)("pre",null,(0,p.kt)("code",c({parentName:"pre"},{className:"language-js"}),"var a1 = { name: 'a1', render = () => [b1, b2, b3] }\nvar b1 = { name: 'b1', render = () => [c1] }\nvar b2 = { name: 'b2', render = () => [c2] }\nvar b3 = { name: 'b3', render = () => [] }\nvar c1 = { name: 'c1', render = () => [d1] }\nvar c2 = { name: 'c2', render = () => [] }\nvar d1 = { name: 'd1', render = () => [d2] }\nvar d2 = { name: 'd2', render = () => [] }\n")),(0,p.kt)("h4",null,"Stack Reconciler"),(0,p.kt)("p",null,"在 ",(0,p.kt)("inlineCode",{parentName:"p"},"React 16")," 之前，节点之间的关系可以用数据结构中",(0,p.kt)("inlineCode",{parentName:"p"},"树的深度遍历"),"来表示。"),(0,p.kt)("p",null,"如下实现 ",(0,p.kt)("inlineCode",{parentName:"p"},"walk")," 函数, 将深度遍历的节点打印出来。"),(0,p.kt)("pre",null,(0,p.kt)("code",c({parentName:"pre"},{className:"language-js"}),"walk(a1)\n\nfunction walk(instance) {\n  if (!instance) return\n  console.log(instance.name)\n  instance.render().map(walk)\n}\n")),(0,p.kt)("p",null,"输出结果为: ",(0,p.kt)("inlineCode",{parentName:"p"},"a1 b1 c1 d1 d2 b2 c2 b3")),(0,p.kt)("h4",null,"Fiber Reconciler"),(0,p.kt)("p",null,"在 ",(0,p.kt)("inlineCode",{parentName:"p"},"React 16")," 中，节点之间的关系可以用数据结构中的",(0,p.kt)("inlineCode",{parentName:"p"},"链表"),"来表示。"),(0,p.kt)("p",null,"节点之间的链表有三种情形, 用图表示如下:"),(0,p.kt)("p",null,(0,p.kt)("img",c({parentName:"p"},{src:"http://with.muyunyun.cn/d7378495a2f16e9058c80326705465f4.jpg-300v",alt:null}))),(0,p.kt)("ol",null,(0,p.kt)("li",{parentName:"ol"},"父节点到子节点(红色虚线)"),(0,p.kt)("li",{parentName:"ol"},"同层节点(黄色虚线)"),(0,p.kt)("li",{parentName:"ol"},"子节点到父节点(蓝色虚线)")),(0,p.kt)("blockquote",null,(0,p.kt)("p",{parentName:"blockquote"},"父节点指向第一个子节点, 每个子节点都指向父节点，同层节点间是单向链表。")),(0,p.kt)("p",null,"首先, 构建节点的数据结构, 如下所示:"),(0,p.kt)("pre",null,(0,p.kt)("code",c({parentName:"pre"},{className:"language-js"}),"var FiberNode = function(instance) {\n  this.instance = instance\n  this.parent = null\n  this.sibling = null\n  this.child = null\n}\n")),(0,p.kt)("p",null,"然后创建一个将节点串联起来的 ",(0,p.kt)("inlineCode",{parentName:"p"},"connect")," 函数:"),(0,p.kt)("pre",null,(0,p.kt)("code",c({parentName:"pre"},{className:"language-js"}),"var connect = function(parent, childList) {\n  parent.child = childList.reduceRight((prev, current) => {\n    const fiberNode = new FiberNode(current)\n    fiberNode.parent = parent\n    fiberNode.sibling = prev\n    return fiberNode\n  }, null)\n\n  return parent.child\n}\n")),(0,p.kt)("blockquote",null,(0,p.kt)("p",{parentName:"blockquote"},"在 JavaScript 中实现链表的数据结构可以巧用 reduceRight")),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"connect")," 函数中实现了上述链表关系。可以像这样使用它:"),(0,p.kt)("pre",null,(0,p.kt)("code",c({parentName:"pre"},{className:"language-js"}),"var parent = new FiberNode(a1)\nvar childFirst = connect(parent, a1.render())\n")),(0,p.kt)("p",null,"这样子便完成了 ",(0,p.kt)("inlineCode",{parentName:"p"},"a1 节点"),"指向 ",(0,p.kt)("inlineCode",{parentName:"p"},"b1 节点"),"的链表、",(0,p.kt)("inlineCode",{parentName:"p"},"b1、b2、b3 节点间"),"的单向链表以及 ",(0,p.kt)("inlineCode",{parentName:"p"},"b1、b2、b3 节点"),"指向 ",(0,p.kt)("inlineCode",{parentName:"p"},"a1 节点"),"的链表。"),(0,p.kt)("p",null,"最后剩下 ",(0,p.kt)("inlineCode",{parentName:"p"},"goWalk")," 函数将全部节点给遍历完。"),(0,p.kt)("pre",null,(0,p.kt)("code",c({parentName:"pre"},{className:"language-js"}),"// 打印日志以及添加列表\nvar walk = function(node) {\n  console.log(node.instance.name)\n  const childLists = node.instance.render()\n  let child = null\n  if (childLists.length > 0) {\n    child = connect(node, childLists)\n  }\n  return child\n}\n\nvar goWalk = function(root) {\n  let currentNode = root\n\n  while (true) {\n    const child = walk(currentNode)\n    // 如果有子节点\n    if (child) {\n      currentNode = child\n      continue\n    }\n\n    // 如果没有相邻节点, 则返回到父节点\n    while (!currentNode.sibling) {\n      currentNode = currentNode.parent\n      if (currentNode === root) {\n        return\n      }\n    }\n\n    // 相邻节点\n    currentNode = currentNode.sibling\n  }\n}\n\n// 调用\ngoWalk(new FiberNode(a1))\n")),(0,p.kt)("p",null,"打印结果为 ",(0,p.kt)("inlineCode",{parentName:"p"},"a1 b1 c1 d1 d2 b2 c2 b3")),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"Fiber")," 在一个节点上的执行流程总结如下:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"在当前节点下寻找是否有子节点",(0,p.kt)("ul",{parentName:"li"},(0,p.kt)("li",{parentName:"ul"},"若有, 则进入子节点"),(0,p.kt)("li",{parentName:"ul"},"若没有, 则在当前节点下寻找是否有下一个相邻节点",(0,p.kt)("ul",{parentName:"li"},(0,p.kt)("li",{parentName:"ul"},"若有, 则进入下一个相邻节点"),(0,p.kt)("li",{parentName:"ul"},"若没有, 则返回它的父节点")))))),(0,p.kt)("h3",null,"Fiber Reconciler 的优势"),(0,p.kt)("p",null,"通过分析上述两种数据结构实现的代码，可以得出下面结论:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"基于树的深度遍历实现的 Reconciler: 一旦进入调用栈便无法暂停;"),(0,p.kt)("li",{parentName:"ul"},"基于链表实现的 Reconciler: 在 ",(0,p.kt)("inlineCode",{parentName:"li"},"while(true) {}")," 的循环中, 可以通过 ",(0,p.kt)("inlineCode",{parentName:"li"},"currentNode")," 的赋值重新得到需要操作的节点，而在赋值之前便可以'暂停'来执行其它逻辑, 这也是 ",(0,p.kt)("inlineCode",{parentName:"li"},"requestIdleCallback")," 能得以在 ",(0,p.kt)("inlineCode",{parentName:"li"},"Fiber Reconciler")," 的原因。")),(0,p.kt)("h3",null,"相关链接"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("a",c({parentName:"li"},{href:"https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7"}),"The how and why on React’s usage of linked list in Fiber to walk the component’s tree")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("a",c({parentName:"li"},{href:"https://github.com/facebook/react/issues/7942"}),"Fiber Principles: Contributing To Fiber"),": Fiber 设计思想相关 issue, 推荐。")))}k.isMDXComponent=!0}}]);