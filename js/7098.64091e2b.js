(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7098],{17098:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>s});var r=t(59713),a=t.n(r),l=t(6479),i=t.n(l),u=(t(67294),t(3905));function p(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function h(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?p(Object(t),!0).forEach((function(n){a()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):p(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var o={};function s(e){var n=e.components,t=i()(e,["components"]);return(0,u.kt)("wrapper",h(h(h({},o),t),{},{components:n,mdxType:"MDXLayout"}),(0,u.kt)("h3",null,"题目"),(0,u.kt)("p",null,"给定 n 个非负整数 a1, a2, ..., an, 每个数代表坐标中的一个点 (i, ai)。在坐标内画 n 条垂直线, 垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线, 使得它们与 x 轴共同构成的容器可以容纳最多的水。"),(0,u.kt)("p",null,"说明: 你不能倾斜容器, 且 n 的值至少为 2。"),(0,u.kt)("p",null,"-",(0,u.kt)("a",h({parentName:"p"},{href:"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg"}))),(0,u.kt)("p",null,"图中垂直线代表输入数组 ","[1,8,6,2,5,4,8,3,7]","。在此情况下, 容器能够容纳水(表示为蓝色部分)的最大值为 49。"),(0,u.kt)("p",null,"示例:"),(0,u.kt)("pre",null,(0,u.kt)("code",h({parentName:"pre"},{className:"language-js"}),"输入: [1,8,6,2,5,4,8,3,7]\n输出: 49\n")),(0,u.kt)("h3",null,"解题"),(0,u.kt)("p",null,"暴力法: 时间复杂度 O(n^2), 空间复杂度 O(1);"),(0,u.kt)("pre",null,(0,u.kt)("code",h({parentName:"pre"},{className:"language-js"}),"// 暴力法\n/**\n * @param {number[]} height\n * @return {number}\n */\nvar maxArea = function (height) {\n  let maxArea = 0\n  const length = height.length\n  for (let i = 0; i < length; i++) {\n    for (let y = i + 1; y < length; y++) {\n      result = Math.min(height[i], height[y]) * (y - i)\n      if (result > maxArea) {\n        maxArea = result\n      }\n    }\n  }\n  return maxArea\n}\n")),(0,u.kt)("p",null,"双指针法: 一个指针指向首位, 一个指针指向末尾; 因为受限于高度低的那一方, 所以移动高度较低的那一位; 这样子只要遍历一次就能得出结果, 时间复杂度 O(n), 空间复杂度 O(1);"),(0,u.kt)("pre",null,(0,u.kt)("code",h({parentName:"pre"},{className:"language-js"}),"// 双指针法\nvar maxArea = function (height) {\n  let head = 0, tail = height.length - 1, maxArea = 0\n  while (head < tail) {\n    result = Math.min(height[head], height[tail]) * (tail - head)\n    if (result > maxArea) {\n      maxArea = result\n    }\n    if (height[head] <= height[tail]) {\n      head++\n    } else {\n      tail--\n    }\n  }\n  return maxArea\n}\n")),(0,u.kt)("h3",null,"类似题目"),(0,u.kt)("p",null,"125、167、344、345"))}s.isMDXComponent=!0}}]);