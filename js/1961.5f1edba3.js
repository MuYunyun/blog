(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1961],{61961:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>u});var a=t(59713),s=t.n(a),i=t(6479),o=t.n(i),r=(t(67294),t(3905));function p(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function c(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?p(Object(t),!0).forEach((function(e){s()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):p(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var l={};function u(n){var e=n.components,t=o()(n,["components"]);return(0,r.kt)("wrapper",c(c(c({},l),t),{},{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h3",null,"setState 是同步还是异步的?"),(0,r.kt)("pre",null,(0,r.kt)("code",c({parentName:"pre"},{className:"language-js"}),'class App extends React.Component {\n  state = {\n    num: 0\n  };\n\n  analyze = () => {\n    this.setState({\n      num: this.state.num + 1\n    });\n    console.log("num", this.state.num);\n    this.setState({\n      num: this.state.num + 1\n    });\n    console.log("num", this.state.num);\n    this.setState({\n      num: this.state.num + 1\n    });\n    console.log("num", this.state.num);\n  };\n\n  handleClick = () => {\n    this.analyze(); // ①\n    // setTimeout(() => { // ②\n    //   this.analyze();\n    // }, 0);\n  };\n\n  render() {\n    return <button onClick={this.handleClick}>click button</button>;\n  }\n}\n')),(0,r.kt)("p",null,"① 处代码打印结果: 0 0 0;\n② 处代码打印结果: 1 2 3;"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("a",c({parentName:"p"},{href:"https://codesandbox.io/s/6l98prq3nk"}),"demo 演示"))),(0,r.kt)("p",null,"为什么会出现这样的现象呢, 相关源码如下:"),(0,r.kt)("pre",null,(0,r.kt)("code",c({parentName:"pre"},{className:"language-js"}),"// 如果满足一定条件, 则对 setState 做批量更新\nfunction batchedUpdates(fn) {\n  const previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingUpdates = true;\n  try {\n    return fn(a); // 相当于所有 setState 都在这里执行, 相当于就是异步执行 setState 了。可见上述 demo\n  } finally {\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performSyncWork();\n    }\n  }\n}\n\n// setState 会进这个函数\nfunction requestWork(root, expirationTime) {\n  addRootToSchedule(root, expirationTime);\n  if (isRendering) {\n    return;\n  }\n\n  if (isBatchingUpdates) {\n    // Flush work at the end of the batch.\n    if (isUnbatchingUpdates) {\n      // ...unless we're inside unbatchedUpdates, in which case we should\n      // flush it now.\n      nextFlushedRoot = root;\n      nextFlushedExpirationTime = Sync;\n      performWorkOnRoot(root, Sync, false);\n    }\n    return;\n  }\n\n  // 如果 isBatchingUpdates 为 false 则执行这里, 相当于 setState 每次调用这里, 就是同步的了\n  if (expirationTime === Sync) {\n    performSyncWork();\n  } else {\n    scheduleCallbackWithExpirationTime(root, expirationTime);\n  }\n}\n")),(0,r.kt)("p",null,"依赖上下文中 ",(0,r.kt)("inlineCode",{parentName:"p"},"isBatchingUpdates")," 等相关布尔值, 如果 ",(0,r.kt)("inlineCode",{parentName:"p"},"isBatchingUpdates")," 为 ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," 则进行批量更新, 如果 ",(0,r.kt)("inlineCode",{parentName:"p"},"isBatchingUpdates")," 为 ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," 则进行同步更新"))}u.isMDXComponent=!0}}]);