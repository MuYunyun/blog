(window.webpackJsonp=window.webpackJsonp||[]).push([[255],{945:function(n,e){n.exports="### 347.Top K Frequent Elements\n\nGiven a non-empty array of integers, return the k most frequent elements.\n\n```js\nExample 1:\n\nInput: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]\n```\n\nExample 2:\n\n```js\nInput: nums = [1], k = 1\nOutput: [1]\n```\n\nNote:\n\n* You may assume k is always valid, 1 â‰¤ k â‰¤ number of unique elements.\n* Your algorithm's `time complexity must be better than O(n log n)`, where n is the array's size.\n* It's guaranteed that `the answer is unique`, in other words the set of the top k frequent elements is unique.\n* You can return the answer in any order.\n\n### Analyze\n\næ€è·¯ä¸€:\n\n1. å°†å„ä¸ªå…ƒç´ å‡ºç°çš„é¢‘ç‡ç»Ÿè®¡è¿›å“ˆå¸Œè¡¨ä¸­;\n2. ç„¶åå¯¹å‡ºç°é¢‘ç‡è¿›è¡Œæ’åº;\n3. å–é¢‘ç‡æ’å‰ k çš„å…ƒç´ ;\n\nè¿™æ ·çš„æ—¶é—´å¤æ‚åº¦ä¸º O(nlog n) çº§åˆ«ã€‚\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function(nums, k) {\n  const obj = {}\n  for (let i = 0; i < nums.length; i++) {\n    if (!obj[nums[i]]) {\n      obj[nums[i]] = 1\n    } else {\n      obj[nums[i]] = obj[nums[i]] + 1\n    }\n  }\n\n  const list = []\n\n  const keysArr = Object.keys(obj)\n  for (let i = 0; i < keysArr.length; i++) {\n    const key = keysArr[i]\n    const value = obj[key]\n    list.push({ key, value })\n  }\n\n  list.sort((r1, r2) => r2.value - r1.value)\n  const result = []\n  list.map((obj, index) => {\n    if (index < k) {\n      result.push(parseInt(obj.key, 10))\n    }\n  })\n  return result\n}\n```\n\nè¯¥é¢˜è§£è™½ç„¶å¯ä»¥ ac, ä½†æ˜¯ç”±äºé¢˜ç›®ç»™å‡ºäº†æ—¶é—´å¤æ‚åº¦éœ€å°äº `(n log n)` è¿™ä¸€é™åˆ¶, å› è€Œæˆ‘ä»¬æ€è€ƒå…¶å®ƒæ–¹å¼ğŸ¤”ã€‚\n\næ€è·¯äºŒ: æ¡¶æ’åºåˆ†ç»„çš„æ€æƒ³\n\n1. é¦–å…ˆå°†å„ä¸ªå…ƒç´ å‡ºç°çš„é¢‘ç‡ç»Ÿè®¡è¿›å“ˆå¸Œè¡¨ä¸­;\n2. å°†é¢‘ç‡å‡å» 1 åçš„å€¼ä½œä¸ºæ•°ç»„ list çš„ä¸‹æ ‡å­˜å…¥;\n3. ä» list ä¸­éå†å–å‡ºé¢‘ç‡æœ€é«˜çš„ k ä¸ªå…ƒç´ ;\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function(nums, k) {\n  const obj = {}\n  for (let i = 0; i < nums.length; i++) {\n    if (!obj[nums[i]]) {\n      obj[nums[i]] = 1\n    } else {\n      obj[nums[i]] = obj[nums[i]] + 1\n    }\n  }\n\n  const list = []\n\n  const keysArr = Object.keys(obj)\n  for (let i = 0; i < keysArr.length; i++) {\n    const key = keysArr[i]\n    const value = obj[key]\n    if (!list[value - 1]) {\n      list[value - 1] = [parseInt(key, 10)]\n    } else {\n      list[value - 1].push(parseInt(key, 10))\n    }\n  }\n\n  const result = []\n  let count = 0\n  for (let i = list.length - 1; i >= 0; i--) {\n    const curList = list[i]\n    if (curList) {\n      for (let x = 0; x < curList.length; x++) {\n        if (count === k) return result\n        result.push(curList[x])\n        count++\n      }\n    }\n  }\n  return result\n}\n```\n\n![](http://with.muyunyun.cn/926ca1b564c07610790ab1e0e4cafa6f.jpg)"}}]);