(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6682],{56682:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>p});var r=t(59713),s=t.n(r),a=t(6479),l=t.n(a),i=(t(67294),t(3905));function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function u(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){s()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var c={};function p(n){var e=n.components,t=l()(n,["components"]);return(0,i.kt)("wrapper",u(u(u({},c),t),{},{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h3",null,"集合"),(0,i.kt)("p",null,"集合是一种",(0,i.kt)("inlineCode",{parentName:"p"},"无重复元素, 无顺序"),"的数据结构。"),(0,i.kt)("p",null,"ES6 引入的 Set 就是集合。"),(0,i.kt)("h3",null,"简易版 Set 实现"),(0,i.kt)("p",null,"我们来动手实现一个简易版的 Set, 它拥有的 api 如下:"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-js"}),"add(value)\n\ndelete(value)\n\nhas(value)\n\nclear()\n\nsize\n")),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-js"}),"// 代码如下, 仅仅用来理解, 实现得不严谨\nfunction Set() {\n  this.items = {}\n  this.size = 0\n}\n\nSet.prototype.add = function(value) {\n  if (!this.items[value]) {\n    this.items[value] = value // 这样子不能实现存储数组、对象\n    this.size = Object.keys(this.items).length\n  }\n}\n\nSet.prototype.has = function(value) {\n  if (this.items.hasOwnProperty(value)) {\n    return true\n  } else {\n    return false\n  }\n}\n\nSet.prototype.delete = function(value) {\n  for (let i in this.items) {\n    if (this.items.hasOwnProperty(i)) {\n      if (i === value.toString()) {\n        delete(this.items[i])\n        this.size = Object.keys(this.items).length\n        return true\n      }\n    }\n  }\n}\n\nSet.prototype.clear = function() {\n  this.items = {}\n  this.size = 0\n}\n")),(0,i.kt)("h3",null,"并集、交集、差集、子集"),(0,i.kt)("p",null,"业务中可能用数组多些, 如果碰到 set 类型的可以用 Array.from 将之转为数组类型, 再使用如下方法。"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-js"}),"// 并集\nfunction union(arr1, arr2) {\n  const arr = arr1.concat(arr2)\n  const result = Array.from(new Set(arr))\n  return result\n}\n\n// 交集\nfunction intersection(arr1, arr2) {\n  const result = arr1.filter(r => arr2.includes(r)) // 也可以转化为 set,用 has\n  return result\n}\n\n// 差集\nfunction difference(arr1, arr2) {\n  const result = arr1.filter(r => !arr2.includes(r))\n  return result\n}\n\n// 子集(判断 arr1 是否为 arr2 的子集)\nfunction isSubset(arr1, arr2) {\n  let bool = true\n  arr1.forEach(r => {\n    if (!arr2.includes(r)) {\n      bool = false\n      return\n    }\n  })\n  return bool\n}\n")),(0,i.kt)("h3",null,"创建 Set 对象"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-js"}),"// 方法一\nconst set1 = new Set()\nset.add(1)\n\n// 方法二\nconst set2 = new Set([1])\n")))}p.isMDXComponent=!0}}]);