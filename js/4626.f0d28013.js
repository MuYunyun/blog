(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4626],{54626:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>p});var r=t(59713),i=t.n(r),a=t(6479),c=t.n(a),l=(t(67294),t(3905));function u(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function m(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?u(Object(t),!0).forEach((function(e){i()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):u(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var o={};function p(n){var e=n.components,t=c()(n,["components"]);return(0,l.kt)("wrapper",m(m(m({},o),t),{},{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h3",null,"64. Minimum Path Sum"),(0,l.kt)("p",null,"Given a m x n grid filled with ",(0,l.kt)("inlineCode",{parentName:"p"},"non-negative numbers"),", find a path from top left to bottom right, which minimizes the sum of all numbers along its path."),(0,l.kt)("p",null,"Note: You can only ",(0,l.kt)("inlineCode",{parentName:"p"},"move either down or right")," at any point in time."),(0,l.kt)("p",null,"Example 1:"),(0,l.kt)("pre",null,(0,l.kt)("code",m({parentName:"pre"},{className:"language-js"}),"1 3 1\n1 5 1\n4 2 1\n\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOutput: 7\nExplanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.\n")),(0,l.kt)("p",null,"Example 2:"),(0,l.kt)("pre",null,(0,l.kt)("code",m({parentName:"pre"},{className:"language-js"}),"1 2 3\n4 5 6\n\nInput: grid = [[1,2,3],[4,5,6]]\nOutput: 12\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"m == grid.length"),(0,l.kt)("li",{parentName:"ul"},"n == grid","[i]",".length"),(0,l.kt)("li",{parentName:"ul"},"1 <= m, n <= 200"),(0,l.kt)("li",{parentName:"ul"},"0 <= grid","[i][j]"," <= 100")),(0,l.kt)("h3",null,"analyze"),(0,l.kt)("p",null,"动态规划一:"),(0,l.kt)("pre",null,(0,l.kt)("code",m({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minPathSum = function (grid) {\n  const m = grid.length\n  const n = grid[0].length\n  const cache = {}\n  return findMinCount(m - 1, n - 1, grid, cache)\n}\n\nfunction findMinCount(x, y, grid, cache) {\n  if (cache[`${x}~${y}`]) {\n    return cache[`${x}~${y}`]\n  }\n\n  let count = 0\n\n  if (x === 0 && y === 0) {\n    count = grid[0][0]\n  } else if (x === 0) {\n    count = findMinCount(0, y - 1, grid, cache) + grid[0][y]\n  } else if (y === 0) {\n    count = findMinCount(x - 1, y, grid, cache) + grid[x][0]\n  }\n\n  if (x > 0 && y > 0) {\n    count = Math.min(findMinCount(x - 1, y, grid, cache), findMinCount(x, y - 1, grid, cache)) + grid[x][y]\n  }\n\n  cache[`${x}~${y}`] = count\n\n  return count\n}\n")),(0,l.kt)("p",null,"动态规划二:"),(0,l.kt)("pre",null,(0,l.kt)("code",m({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minPathSum = function (grid) {\n  const mLength = grid.length\n  const nLength = grid[0].length\n  const cache = []\n  for (let m = mLength - 1; m >= 0; m--) {\n    for (let n = nLength - 1; n >= 0; n--) {\n      if (!cache[m]) cache[m] = []\n      if (m + 1 >= mLength && n + 1 >= nLength) {\n        cache[m][n] = grid[m][n]\n      } else if (m + 1 >= mLength) {\n        cache[m][n] = cache[m][n + 1] + grid[m][n]\n      } else if (n + 1 >= nLength) {\n        cache[m][n] = cache[m + 1][n] + grid[m][n]\n      } else {\n        cache[m][n] = Math.min(cache[m + 1][n], cache[m][n + 1]) + grid[m][n]\n      }\n    }\n  }\n  return cache[0][0]\n}\n")),(0,l.kt)("h3",null,"Similar Title"),(0,l.kt)("p",null,"120"))}p.isMDXComponent=!0}}]);