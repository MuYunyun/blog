(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1067],{11067:(n,t,e)=>{"use strict";e.r(t),e.d(t,{default:()=>i});var r=e(59713),c=e.n(r),o=e(6479),l=e.n(o),a=(e(67294),e(3905));function u(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,r)}return e}function p(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?u(Object(e),!0).forEach((function(t){c()(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):u(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}var s={};function i(n){var t=n.components,e=l()(n,["components"]);return(0,a.kt)("wrapper",p(p(p({},s),e),{},{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h3",null,"代理模式"),(0,a.kt)("p",null,"情景: 小明追女生 A"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"非代理模式: 小明 =花=> 女生 A"),(0,a.kt)("li",{parentName:"ul"},"代理模式: 小明 =花=> 让女生 A 的好友 B 帮忙 =花=> 女生 A")),(0,a.kt)("h3",null,"代理模式的特点"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"代理对象和本体对象具有一致的接口, 对使用者友好")),(0,a.kt)("p",null,"代理模式的种类有很多, 在 JS 中最常用的为虚拟代理和缓存代理。"),(0,a.kt)("h4",null,"虚拟代理实现图片预加载"),(0,a.kt)("p",null,"下面这段代码运用代理模式来实现图片预加载, 可以看到通过代理模式巧妙地将创建图片与预加载逻辑分离, 并且在未来如果不需要预加载, 只要改成请求本体代替请求代理对象就行。"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-js"}),"const myImage = (function() {\n  const imgNode = document.createElement('img')\n  document.body.appendChild(imgNode)\n  return {\n    setSrc: function(src) {\n      imgNode.src = src\n    }\n  }\n})()\n\nconst proxyImage = (function() {\n  const img = new Image()\n  img.onload = function() { // http 图片加载完毕后才会执行\n    myImage.setSrc(this.src)\n  }\n  return {\n    setSrc: function(src) {\n      myImage.setSrc('loading.jpg') // 本地 loading 图片\n      img.src = src\n    }\n  }\n})()\n\nproxyImage.setSrc('http://loaded.jpg')\n")),(0,a.kt)("h4",null,"缓存代理实现乘积计算"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-js"}),"const mult = function() {\n  let a = 1\n  for (let i = 0, l; l = arguments[i++];) {\n    a = a * l\n  }\n  return a\n}\n\nconst proxyMult = (function() {\n  const cache = {}\n  return function() {\n    const tag = Array.prototype.join.call(arguments, ',')\n    if (cache[tag]) {\n      return cache[tag]\n    }\n    cache[tag] = mult.apply(this, arguments)\n    return cache[tag]\n  }\n})()\n\nproxyMult(1, 2, 3, 4) // 24\n")),(0,a.kt)("h3",null,"小 tip"),(0,a.kt)("p",null,"在开发时候不要先去猜测是否需要使用代理模式, 如果发现直接使用某个对象不方便时, 再来优化不迟。"))}i.isMDXComponent=!0}}]);