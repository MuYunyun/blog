(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6020],{26020:n=>{n.exports="### 230. Kth Smallest Element in a BST\n\nGiven a binary search tree, write a function kthSmallest to find the kth smallest element in it.\n\nExample 1:\n\n```js\nInput: root = [3,1,4,null,2], k = 1\n    3\n  /   \\\n 1     4\n  \\\n   2\nOutput: 1\n```\n\nExample 2:\n\n```js\nInput: root = [5,3,6,2,4,null,null,1], k = 3\n        5\n      /   \\\n     3     6\n    / \\\n   2   4\n  /\n 1\nOutput: 3\n```\n\nFollow up:\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\n\nConstraints:\n\nThe number of elements of the BST is between 1 to 10^4.\nYou may assume k is always valid, 1 ≤ k ≤ BST's total elements.\n\n### Analyze\n\n思路: 中序遍历维护计数, 当计数值到达 k 时, 当前节点的 val 即为题目要求的第 k 小的值元素值。\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} k\n * @return {number}\n */\nvar kthSmallest = function(root, k) {\n  const countResult = { value: 0 }\n  return analyzeCount(root, k, countResult)\n}\n\nvar analyzeCount = function(node, k, count) {\n  if (!node) return null\n  const pickLeft = analyzeCount(node.left, k, count)\n  if (typeof pickLeft === 'number') return pickLeft\n  count.value = count.value + 1\n  if (k === count.value) {\n    return node.val\n  }\n  const pickRight = analyzeCount(node.right, k, count)\n  if (typeof pickRight === 'number') return pickRight\n}\n```\n"}}]);