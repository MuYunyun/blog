(self.webpackChunkblog=self.webpackChunkblog||[]).push([[420],{60420:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>s});var r=t(59713),c=t.n(r),o=t(6479),u=t.n(o),l=(t(67294),t(3905));function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function p(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){c()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var f={};function s(n){var e=n.components,t=u()(n,["components"]);return(0,l.kt)("wrapper",p(p(p({},f),t),{},{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h3",null,"Optimize fibonacci sequence"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"题目: 求斐波那契数列 1,1,2,3,5,8,13,21,34,55,89...中的第 n 项")),(0,l.kt)("p",null,"斐波那契数列考察的是递归算法, 但是要注意优化, 探寻下面优化前后的代码片段。"),(0,l.kt)("p",null,"优化前:"),(0,l.kt)("pre",null,(0,l.kt)("code",p({parentName:"pre"},{className:"language-js"}),"let count1 = 0\nfunction fn(n) {\n  count1++\n  if (n === 1 || n === 2) {\n    return 1\n  }\n  return fn(n - 1) + fn(n - 2)\n}\n\nconsole.log(fn(20), count1) // 6765 13529\n")),(0,l.kt)("p",null,"优化后:"),(0,l.kt)("pre",null,(0,l.kt)("code",p({parentName:"pre"},{className:"language-js"}),"function _fn(n) {\n  if (cache[n]) {\n    return cache[n]\n  }\n  count2++\n  if (n === 1 || n === 2) {\n    return 1\n  }\n  cache[n - 1] = _fn(n - 1)\n  cache[n - 2] = _fn(n - 2)\n  return cache[n - 1] + cache[n - 2]\n}\n\nlet count2 = 0\nfunction fn(n) {\n  const cache = {}\n  return _fn(n)\n}\n\nconsole.log(fn(20), count2) // 6765 20\n")),(0,l.kt)("p",null,"小结: 通过",(0,l.kt)("inlineCode",{parentName:"p"},"记忆化缓存数据"),", 可以看到大大提高了运行性能。"))}s.isMDXComponent=!0}}]);