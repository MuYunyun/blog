(window.webpackJsonp=window.webpackJsonp||[]).push([[193],{883:function(n,e){n.exports="### 观察者模式\n\n应用场景:\n\n1. 场景一: 当观察的数据对象发生变化时, 自动调用相应函数。比如 vue 的双向绑定;\n2. 场景二: 每当调用对象里的某个方法时, 就会调用相应'访问'逻辑。比如给测试框架赋能的 spy 函数;\n\n### 场景一: 双向绑定\n\n#### Object.defineProperty\n\n使用 `Object.defineProperty(obj, props, descriptor)` 实现观察者模式, 其也是 [vue 双向绑定](https://github.com/MuYunyun/blog/issues/11) 的核心, 示例如下(当改变 obj 中的 value 的时候, 自动调用相应相关函数):\n\n```js\nvar obj = {\n  data: { list: [] },\n}\n\nObject.defineProperty(obj, 'list', {\n  get() {\n    return this.data['list']\n  },\n  set(val) {\n    console.log('值被更改了')\n    this.data['list'] = val\n  }\n})\n```\n\n#### Proxy\n\nProxy/Reflect 是 ES6 引入的新特性, 也可以使用其完成观察者模式, 示例如下(效果同上):\n\n```js\nvar obj = {\n  value: 0\n}\n\nvar proxy = new Proxy(obj, {\n  set: function(target, key, value, receiver) { // {value: 0}  \"value\"  1  Proxy {value: 0}\n    console.log('调用相应函数')\n    Reflect.set(target, key, value, receiver)\n  }\n})\n\nproxy.value = 1 // 调用相应函数\n\n```\n\n### 场景二\n\n下面来实现 sinon 框架的 spy 函数:\n\n```js\nconst sinon = {\n  analyze: {},\n  spy: function(obj, fnName) {\n    const that = this\n    const oldFn = Object.getOwnPropertyDescriptor(obj, fnName).value\n    Object.defineProperty(obj, fnName, {\n      value: function() {\n        oldFn()\n        if (that.analyze[fnName]) {\n          that.analyze[fnName].count = ++that.analyze[fnName].count\n        } else {\n          that.analyze[fnName] = {}\n          that.analyze[fnName].count = 1\n        }\n        console.log(`${fnName} 被调用了 ${that.analyze[fnName].count} 次`)\n      }\n    })\n  }\n}\n\nconst obj = {\n  someFn: function() {\n    console.log('my name is someFn')\n  }\n}\n\nsinon.spy(obj, 'someFn')\n\nobj.someFn()\n// my name is someFn\n// someFn 被调用了 1 次\nobj.someFn()\n// my name is someFn\n// someFn 被调用了 2 次\n```\n\n### `vue` 在 3.0 版本上使用 `Proxy` 重构的原因\n\n首先罗列 `Object.defineProperty()` 的缺点:\n\n1. `Object.defineProperty()` 不会监测到数组引用不变的操作(比如 `push/pop` 等);\n2. `Object.defineProperty()` 只能监测到对象的属性的改变, 即如果有深度嵌套的对象则需要再次给之绑定 `Object.defineProperty()`;\n\n关于 `Proxy` 的优点\n\n1. 可以劫持数组的改变;\n2. `defineProperty` 是对属性的劫持, `Proxy` 是对对象的劫持;"}}]);