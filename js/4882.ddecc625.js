(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4882],{14882:n=>{n.exports="### 130. Surrounded Regions\n\nGiven a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.\n\nA region is captured by flipping all 'O's into 'X's in that surrounded region.\n\nExample:\n\n[['X', 'X', 'X', 'X'], ['X', 'O', 'O', 'X'], ['X', 'X', 'O', 'X'], ['X', 'O', 'X', 'X']]\n\n```js\nX X X X\nX O O X\nX X O X\nX O X X\n```\n\n```js\nX X X X\nX O O X\nX X O X\nX - X X\n```\n\nAfter running your function, the board should be:\n\n```js\nX X X X\nX X X X\nX X X X\nX O X X\n```\n\nExplanation:\n\n`Surrounded regions shouldn’t be on the border`, which means that any 'O' on the border of the board are not flipped to 'X'. `Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'`. Two cells are connected if they are adjacent cells connected horizontally or vertically.\n\nExample:\n\nvar test = [[\"O\",\"O\",\"O\"],[\"O\",\"O\",\"O\"],[\"O\",\"O\",\"O\"]]\n\n```js\nO O O\nO O O\nO O O\n```\n\nAfter running your function, the board should be:\n\n```js\nO O O\nO O O\nO O O\n```\n\n### Analyze\n\n* 分析终止迭代(不合法)的条件\n  1. m, n 坐标已经使用过;\n  2. m, n 坐标位于边界而且 board[m][n] 为 'O'\n  3. board[m][n] 为 'X'\n\n```js\n/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar solve = function(board) {\n  const used = []\n  for (let m = 0; m < board.length; m++) {\n    for (let n = 0; n < board[m].length; n++) {\n      if (used.indexOf(`${m},${n}`) === -1) {\n        recursive(board, m, n, used)\n      }\n    }\n  }\n  return board\n};\n\nvar direction = [[1, 0], [0, 1], [-1, 0], [0, -1]] // 下、右、上、左\n\n// m: row; n: column\nvar isValid = (board, m, n, used) => {\n  if (!board[m] || !board[m][n]) return false\n  const notUsed = used.indexOf(`${m},${n}`) === -1\n  used.push(`${m},${n}`)\n  return notUsed\n}\n\n// judge if it is in board\nvar isInBorder = (board, m, n) => m === 0 || n === 0 || m === board.length - 1 || n === board[0].length - 1\n\nvar recursive = function(board, m, n, used) {\n  // end condition.\n  if (!isValid(board, m, n, used) || (isInBorder(board, m, n) && board[m][n] === 'O') || board[m][n] === 'X') {\n    return false\n  }\n  for (let i = 0; i < direction.length; i++) {\n    const tag = recursive(board, m + direction[i][0], n + direction[i][1], used)\n    // recursive to set value\n    if (tag && board[m][n] === 'O') {\n      board[m][n] = 'X'\n    }\n    // 若不在边界的坐标 m,n 四周的值都不合理, 且 borad[m][n] === 'O', 则要让 board[m][n] = 'X'\n    // todo: board[m][n - 1] === 'O'\n    if (i === 3 && !isInBorder(board, m, n) && board[m][n] === 'O') {\n      board[m][n] = 'X'\n    }\n  }\n  return true\n}\n```\n\n「若不在边界的坐标 m,n 四周的值都不合理, 且 borad[m][n] === 'O', 则要让 board[m][n] = 'X'」, 这个条件在如下测试用例面前是过不去的砍👀\n\n```\nO O O\nO O O\nO O O\n```\n\n观察评论区调整了下思路:\n\n1. 将边界的 O 以及与其相连的 O 标记为 `_`。\n2. 遍历节点\n   1. 将剩余的 O 全部替换为 X。\n   2. 将全部的 _ 替换为 O。\n\n> 点子比行动更重要！\n\n```js\n/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar solve = function(board) {\n  const used = []\n  for (let m = 0; m < board.length; m++) {\n    for (let n = 0; n < board[m].length; n++) {\n      if (isInBorder(m, n, board) && board[m][n] === 'O') {\n        replaceWith_(board, m, n, used)\n      }\n    }\n  }\n\n  for (let m = 0; m < board.length; m++) {\n    for (let n = 0; n < board[m].length; n++) {\n      if (board[m][n] === 'O') {\n        board[m][n] = 'X'\n      }\n      if (board[m][n] === '_') {\n        board[m][n] = 'O'\n      }\n    }\n  }\n  return board\n};\n\n// judge if it is in board\nvar isInBorder = (m, n, board) => m === 0 || n === 0 || m === board.length - 1 || n === board[0].length - 1\n\nvar isValid = (board, m, n, used) => {\n  if (!board[m] || !board[m][n]) return false\n  const notUsed = used.indexOf(`${m},${n}`) === -1\n  used.push(`${m},${n}`)\n  return notUsed\n}\n\nvar direction = [[1, 0], [0, 1], [-1, 0], [0, -1]] // 下、右、上、左\n\nvar replaceWith_ = (board, m, n, used) => {\n  if (!isValid(board, m, n, used) || board[m][n] === 'X') return\n  if (board[m][n] === 'O') {\n    board[m][n] = '_'\n  }\n\n  for (let i = 0; i < direction.length; i++) {\n    replaceWith_(board, m + direction[i][0], n + direction[i][1], used)\n  }\n}\n```\n\n### Sister Title\n\n79、200"}}]);