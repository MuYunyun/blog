(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1014],{21014:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>p});var r=t(59713),a=t.n(r),l=t(6479),u=t.n(l),o=(t(67294),t(3905));function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function m(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){a()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var s={};function p(n){var e=n.components,t=u()(n,["components"]);return(0,o.kt)("wrapper",m(m(m({},s),t),{},{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h3",null,"437. Path Sum III"),(0,o.kt)("p",null,"You are given a binary tree in which each node contains an integer value."),(0,o.kt)("p",null,"Find the number of paths that sum to a given value."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"The path does not need to start or end at the root or a leaf"),", but it must go downwards (traveling only from parent nodes to child nodes)."),(0,o.kt)("p",null,"The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Example"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",m({parentName:"pre"},{className:"language-js"}),"root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\n\n      10\n     /  \\\n    5   -3\n   / \\    \\\n  3   2   11\n / \\   \\\n3  -2   1\n\nReturn 3. The paths that sum to 8 are:\n\n1.  5 -> 3\n2.  5 -> 2 -> 1\n3. -3 -> 11\n")),(0,o.kt)("h3",null,"题解"),(0,o.kt)("p",null,"此题的难点需想清每个节点都要当作",(0,o.kt)("inlineCode",{parentName:"p"},"根节点"),"来对待, 因此题解为如下三部分之和:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"当前节点作为根节点"),"时相加为 sum 的路径之和。"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"当前节点左子树作为根节点"),"时相加为 sum 的路径之和。"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"当前节点右子树作为根节点"),"时相加为 sum 的路径之和。")),(0,o.kt)("p",null,"同时递归可以分为两个部分: ",(0,o.kt)("inlineCode",{parentName:"p"},"根节点的递归")," 与 ",(0,o.kt)("inlineCode",{parentName:"p"},"分析总和的递归"),"。"),(0,o.kt)("pre",null,(0,o.kt)("code",m({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} sum\n * @return {number}\n */\nvar pathSum = function(root, sum) {\n  if (!root) return 0\n  // total means result value\n  // initialSum means init sum value\n  let result = { total: 0, initialSum: sum }\n  analyzeSum(root, result, sum)\n  return result.total\n};\n\nvar analyzeSum = function(node, result, sum) {\n  if (!node) return\n  const extraSum = sum - node.val\n  if (extraSum === 0) {\n    result.total = result.total + 1\n  }\n\n  analyzeSum(node.left, result, extraSum)\n  analyzeSum(node.right, result, extraSum)\n  // handle it as root node.\n  analyzeSum(node.left, result, result.initialSum)\n  analyzeSum(node.right, result, result.initialSum)\n}\n")),(0,o.kt)("p",null,"submit 后, 卡在了如下测试用例中:"),(0,o.kt)("pre",null,(0,o.kt)("code",m({parentName:"pre"},{className:"language-js"}),"输入:\n[1,null,2,null,3] // 该测试用例有点怪, 应该为 [1, null, 2, null, null, null, 3]\n3\n\n       1\n     /   \\\n  null    2\n        /   \\\n      null    3\n\n输出:\n3\n预期:\n2\n")),(0,o.kt)("p",null,"经过排查, ",(0,o.kt)("inlineCode",{parentName:"p"},"analyzeSum")," 函数存在冗余的调用, 并未将",(0,o.kt)("inlineCode",{parentName:"p"},"根节点的递归"),"与",(0,o.kt)("inlineCode",{parentName:"p"},"分析总和的递归"),"给解耦。调整如下:"),(0,o.kt)("pre",null,(0,o.kt)("code",m({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} sum\n * @return {number}\n */\n// recursive root node\nvar pathSum = function(root, sum) {\n  if (!root) return 0\n  const curTotal = analyzeSum(root, sum)\n  const leftChildTotal = pathSum(root.left, sum)\n  const rightChildTotal = pathSum(root.right, sum)\n  return curTotal + leftChildTotal + rightChildTotal\n};\n\n// recursive anlyze total value\nvar analyzeSum = function(node, expectSum) {\n  if (!node) return 0\n  const extraSum = expectSum - node.val\n  if (extraSum === 0) {\n    return 1 + analyzeSum(node.left, extraSum) + analyzeSum(node.right, extraSum)\n  } else {\n    return analyzeSum(node.left, extraSum) + analyzeSum(node.right, extraSum)\n  }\n}\n")))}p.isMDXComponent=!0}}]);