(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5074],{85074:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>k});var a=t(59713),r=t.n(a),l=t(6479),u=t.n(l),p=(t(67294),t(3905));function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){r()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var m={};function k(e){var n=e.components,t=u()(e,["components"]);return(0,p.kt)("wrapper",o(o(o({},m),t),{},{components:n,mdxType:"MDXLayout"}),(0,p.kt)("h3",null,"Contains Duplicate III"),(0,p.kt)("p",null,"Given an array of integers, find out whether there are ",(0,p.kt)("inlineCode",{parentName:"p"},"two distinct indices")," i and j in the array such that the absolute difference between nums","[i]"," and nums","[j]"," is at most t and the absolute difference between i and j is at most k."),(0,p.kt)("p",null,"Example 1:"),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"Input: nums = [1,2,3,1], k = 3, t = 0\nOutput: true\n")),(0,p.kt)("p",null,"Example 2:"),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"Input: nums = [1,0,1,1], k = 1, t = 2\nOutput: true\n")),(0,p.kt)("p",null,"Example 3:"),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"Input: nums = [1,5,9,1,5,9], k = 2, t = 3\nOutput: false\n")),(0,p.kt)("h3",null,"Analyze"),(0,p.kt)("p",null,"思路: 参照官方题解该题可以使用桶排序的思想来设置查找表的 key - value。比较好理解的一个例子: 小敏生日在 3 月份, 她想知道是否有其他同学生日和她在 30 天以内, 假设每个月有 30 天, 那么只要找 2 月份和 4 月份两个月生日的同学就行了, 转化到该题目即 key 只要保留一个 value 就行。"),(0,p.kt)("blockquote",null,(0,p.kt)("p",{parentName:"blockquote"},"桶排序的思想: 将数据根据归类划分到若干个区域, 然后对该些区域分别进行排序;")),(0,p.kt)("p",null,"此题综合了滑动窗口、查找表、桶排序的知识, 需要二刷。"),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"| i - j | ≤ k\n| nums[i] - nums[j] | ≤ t\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"此外需要考虑边界值",(0,p.kt)("ul",{parentName:"li"},(0,p.kt)("li",{parentName:"ul"},"k <= 0、 t <= 0")))),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number} t\n * @return {boolean}\n */\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\n  if (k < 0 || t < 0) return false\n  const getKey = (value) => {\n    return Math.floor(value / (t + 1))\n  }\n\n  const map = new Map()\n\n  let l = 0\n  while (l < nums.length) {\n    const key = getKey(nums[l])\n\n    if (map.has(key)) {\n      return true\n    } else if (map.has(key + 1) || map.has(key - 1)) {\n      if (map.get(key + 1) - nums[l] <= t) { return true }\n      if (nums[l] - map.get(key - 1) <= t) { return true }\n    }\n\n    map.set(key, nums[l])\n\n    if (l >= k) {\n      map.delete(getKey(nums[l - k]))\n    }\n\n    l++\n  }\n\n  return false\n}\n")),(0,p.kt)("h3",null,"Sister Title"),(0,p.kt)("p",null,"217、219"))}k.isMDXComponent=!0}}]);