(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3810],{83810:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>c});var o=t(59713),r=t.n(o),l=t(6479),a=t.n(l),i=(t(67294),t(3905));function p(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function u(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?p(Object(t),!0).forEach((function(n){r()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):p(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var s={};function c(e){var n=e.components,t=a()(e,["components"]);return(0,i.kt)("wrapper",u(u(u({},s),t),{},{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h3",null,"222. Count Complete Tree Nodes"),(0,i.kt)("p",null,"Given a ",(0,i.kt)("inlineCode",{parentName:"p"},"complete binary tree"),", count the number of nodes."),(0,i.kt)("p",null,"Note:"),(0,i.kt)("p",null,"Definition of a complete binary tree from Wikipedia:\nIn a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-js"}),"Input:\n    1\n   / \\\n  2   3\n / \\  /\n4  5 6\n\nOutput: 6\n")),(0,i.kt)("h3",null,"Analyze"),(0,i.kt)("p",null,"方式一: 递归"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar countNodes = function(root) {\n  if (!root) return 0\n  return 1 + countNodes(root.left) + countNodes(root.right)\n};\n")),(0,i.kt)("p",null,"方式二: 利用完全二叉树性质解题"),(0,i.kt)("p",null,"根据题目给出的当前树是完全二叉树的限制, 可得到子树存在如下两点条件:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"若左子树的深度 = 右子树的深度, 则",(0,i.kt)("inlineCode",{parentName:"li"},"左子树为满二叉树"),";"),(0,i.kt)("li",{parentName:"ul"},"若左子树的深度 > 右子树的深度, 则",(0,i.kt)("inlineCode",{parentName:"li"},"右子树为满二叉树"),";")),(0,i.kt)("p",null,"可以根据上述分析简化递归次数。"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar countNodes = function(root) {\n  if (!root) return 0\n\n  const leftDeep = deep(root.left)\n  const rightDeep = deep(root.right)\n\n  if (leftDeep === rightDeep) {\n    // the count of left node is Math.pow(2, leftDeep) - 1, so the total is\n    // Math.pow(2, leftDeep) - 1 + countNodes(root.right) + 1, 1 means parent node\n    return Math.pow(2, leftDeep) + countNodes(root.right)\n  } else {\n    return Math.pow(2, rightDeep) + countNodes(root.left)\n  }\n};\n\n// get the deep of current node cleverly with features of the complete tree.\nvar deep = function(node) {\n  if (!node) return 0\n  let nodeVal = node\n  let count = 1\n\n  while (nodeVal.left) {\n    count++\n    nodeVal = nodeVal.left\n  }\n\n  return count\n}\n")))}c.isMDXComponent=!0}}]);