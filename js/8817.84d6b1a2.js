(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8817],{18817:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>c});var a=t(59713),r=t.n(a),l=t(6479),s=t.n(l),i=(t(67294),t(3905));function u(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function p(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?u(Object(t),!0).forEach((function(n){r()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):u(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var o={};function c(e){var n=e.components,t=s()(e,["components"]);return(0,i.kt)("wrapper",p(p(p({},o),t),{},{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h3",null,"93.Restore IP Addresses"),(0,i.kt)("p",null,"Given a string s containing only digits, return all possible valid IP addresses that can be obtained from s. You can return them in any order."),(0,i.kt)("p",null,"A valid IP address consists of exactly ",(0,i.kt)("inlineCode",{parentName:"p"},"four integers"),", each integer is between 0 and 255, separated by single dots and ",(0,i.kt)("inlineCode",{parentName:"p"},"cannot have leading zeros"),'. For example, "0.1.2.201" and "192.168.1.1" are valid IP addresses and "0.011.255.245", "192.168.1.312" and "',(0,i.kt)("a",p({parentName:"p"},{href:"mailto:192.168@1.1"}),"192.168@1.1"),'" are invalid IP addresses.'),(0,i.kt)("p",null,"Example 1:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),'Input: s = "25525511135"\nOutput: ["255.255.11.135","255.255.111.35"]\n')),(0,i.kt)("p",null,"Example 2:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),'Input: s = "0000"\nOutput: ["0.0.0.0"]\n')),(0,i.kt)("p",null,"Example 3:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),'Input: s = "1111"\nOutput: ["1.1.1.1"]\n')),(0,i.kt)("p",null,"Example 4:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),'Input: s = "010010"\nOutput: ["0.10.0.10","0.100.1.0"]\n')),(0,i.kt)("p",null,"Example 5:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),'Input: s = "101023"\nOutput: ["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]\n')),(0,i.kt)("p",null,"Constraints:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"0 <= s.length <= 3000"),(0,i.kt)("li",{parentName:"ul"},"s consists of digits only.")),(0,i.kt)("h3",null,"Analyze"),(0,i.kt)("p",null,"方法一: 遍历穷举法"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"/**\n * @param {string} s\n * @return {string[]}\n */\nvar restoreIpAddresses = function (s) {\n  const arr = []\n  for (let i = 1; i < 4; i++) {\n    for (let j = i + 1; j < i + 5; j++) {\n      for (let z = j + 1; z < j + 5; z++) {\n        const a = s.slice(0, i)\n        const b = s.slice(i, j)\n        const c = s.slice(j, z)\n        const d = s.slice(z, s.length)\n        if (validate(a) && validate(b) && validate(c) && validate(d)) {\n          arr.push(`${a}.${b}.${c}.${d}`)\n        }\n      }\n    }\n  }\n  return arr\n};\n\nvar validate = function (value) {\n  if (value.length > 3 || value.length === 0 || +value > 255 || (value[0] === '0' && value.length > 1)) {\n    return false\n  }\n  return true\n}\n")),(0,i.kt)("p",null,"方法二: 回溯法"),(0,i.kt)("p",null,"回溯是一种思想。DFS 也是回溯思想的一种实践案例。回溯法本质是一种穷举的递归算法, 既然是递归, 它就需要有终止条件。"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"/**\n * @param {string} s\n * @return {string[]}\n */\nvar restoreIpAddresses = function(s) {\n  const res = []\n  backtracking(s, 0, '', res)\n  return res\n};\n\nvar backtracking = function(s, start, ipValue, res) {\n  const splitIpNode = ipValue.split('.')\n  const ipNode = splitIpNode.length\n  // end condition\n  for (let i = 0; i < ipNode; i++) {\n    if (!isValid(splitIpNode[i])) return\n  }\n  if (ipValue.length === s.length + 3 && !ipValue.endsWith('.')) {\n    // 比如 010010 存在两种相等的 case, 0100 + 1 + 0, 0100 + 10, 因此需要去重\n    if (res.indexOf(ipValue) === -1) res.push(ipValue)\n    return\n  } else if (ipValue.length === s.length + 3 && ipValue.endsWith('.')) {\n    return\n  }\n\n  for (let i = start + 1; i < start + 4; i++) {\n    if (i >= s.length + 1) return\n    const str = s.slice(start, i)\n    const ipValueNew = ipNode <= 3 ? ipValue + str + '.' : ipValue + str\n    backtracking(s, i, ipValueNew, res)\n  }\n}\n\n// judge if the str value is valid for ip.\nvar isValid = function (value) {\n  if (value.length > 3 || +value > 255 || (value[0] === '0' && value.length > 1)) {\n    return false\n  }\n  return true\n}\n")),(0,i.kt)("p",null,"针对此题, 方法一相对方法二较为容易。"))}c.isMDXComponent=!0}}]);