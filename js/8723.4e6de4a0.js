(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8723],{78723:n=>{n.exports="### for 循环/while 循环\n\nJavaScript 提供多种遍历语法。最原始的写法就是 for 循环。\n\n```js\nlet arr = [1,2,3,4,5];\n\nfor (var index = 0; index < arr.length; index++) {\n  console.log(myArray[index]); // 1 2 3 4 5\n}\n```\n\n* 缺点：这种写法相对麻烦\n\n### forEach\n\n数组提供内置的 forEach 方法\n\n```js\nlet arr = [1,2,3,4,5];\n\narr.forEach((element,index) => {\n  console.log(element); // 1 2 3 4 5\n})\n```\n\n* 缺点: 这种写法的问题在于, 无法中途跳出 forEach 循环, break 命令或 return 命令都不能生效。\n\n### for...in\n\nfor……in 用于遍历对象所有的`可枚举属性`, 功能类似于 Object.keys()。\n\n```js\nlet obj = {\n  name: 'cloud',\n  phone: '157xxxx2065'\n}\n\nfor (let prop in obj) {\n  console.log(prop); // name phone\n}\n```\n\n可能有朋友会问, 不可枚举的对象有哪些呢? 比如 constructor, 数组的 length 就属于不可枚举属性。\n\n```js\nlet arr = [10, 20, 30, 40, 50]\n\nfor (let prop in arr) {\n  console.log(prop) // '0' '1' '2' '3' '4'\n}\n```\n\n缺点：\n\n* 数组的键名是数字, 但是 for...in 循环是以字符串作为键名 “0”、“1”、“2” 等等。\n* for...in 循环主要是为遍历对象而设计的, 不适用于遍历数组\n\n### for...of\n\n`for……of` 是 ES6 新增的遍历方式, 它提供了统一的遍历机制。所有实现了 [Symbol.iterator] 接口的对象都可以被遍历。for...of 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象 (比如 arguments 对象、DOM NodeList 对象)、Generator 对象, 以及字符串。\n\n优点：\n\n* 有着同 for...in 一样的简洁语法, 但是没有 for...in 那些缺点;\n* 不同用于 forEach 方法, 它可以与 break、continue 和 return 配合使用\n* 提供了遍历所有数据结构的统一操作接口\n\n下面是一个使用 break 语句, 跳出 for...of 循环的例子。\n\n```js\nfor (var n of fibonacci) {\n  if (n > 1000)\n    break\n  console.log(n)\n}\n```\n\n上面的例子, 会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000, 就会使用 break 语句跳出 for...of 循环。\n\n#### for...of 获取索引\n\n* entries() 返回一个遍历器对象, 用来遍历 `[键名, 键值]` 组成的数组。对于数组, 键名就是索引值；对于 Set, 键名与键值相同。Map 结构的 Iterator 接口, 默认就是调用 entries 方法。\n* keys() 返回一个遍历器对象, 用来遍历所有的键名。\n* values() 返回一个遍历器对象, 用来遍历所有的键值。\n\n```js\n// demo\nlet arr = ['a', 'b', 'c'];\nfor (let pair of arr.entries()) {\n  console.log(pair);\n}\n// [0, 'a']\n// [1, 'b']\n// [2, 'c']\n```\n\n#### 类似数组的对象\n\n类似数组的对象包括好几类。下面是 for...of 循环用于字符串、DOM NodeList 对象、arguments 对象的例子。\n\n```js\n// 字符串\nlet str = \"hello\";\n\nfor (let s of str) {\n  console.log(s); // h e l l o\n}\n\n// DOM NodeList对象\nlet paras = document.querySelectorAll(\"p\");\n\nfor (let p of paras) {\n  p.classList.add(\"test\");\n}\n\n// arguments对象\nfunction printArgs() {\n  for (let x of arguments) {\n    console.log(x);\n  }\n}\nprintArgs('a', 'b');\n// 'a'\n// 'b'\n```\n\n并不是所有类似数组的对象都具有 Iterator 接口, 一个简便的解决方法, 就是使用 Array.from 方法将其转为数组。\n\n```js\nlet arrayLike = { length: 2, 0: 'a', 1: 'b' };\n\n// 报错\nfor (let x of arrayLike) {\n  console.log(x);\n}\n\n// 正确\nfor (let x of Array.from(arrayLike)) {\n  console.log(x);  // 'a' // 'b'\n}\n```\n\n#### 普通的对象\n\n对于普通的对象, for...of 结构不能直接使用, 会报错, 必须部署了 Iterator 接口后才能使用。\n\n```js\nlet es6 = {\n  edition: 6,\n  committee: \"TC39\",\n  standard: \"ECMA-262\"\n};\n\nfor (let e in es6) {\n  console.log(e);\n}\n// edition\n// committee\n// standard\n\nfor (let e of es6) {\n  console.log(e);\n}\n// TypeError: es6 is not iterable\n```\n\n解决方法是, 使用 Object.keys 方法将对象的键名生成一个数组, 然后遍历这个数组。\n\n```js\nfor (var key of Object.keys(someObject)) {\n  console.log(key + ': ' + someObject[key]);\n}\n```"}}]);