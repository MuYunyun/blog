(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5115],{95115:n=>{n.exports="### 450.Delete Node in a BST\n\nGiven a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\n\nBasically, the deletion can be divided into two stages:\n\nSearch for a node to remove.\nIf the node is found, delete the node.\nFollow up: Can you solve it with time complexity O(height of tree)?\n\nExample 1:\n\n```js\n         5                             5\n       /   \\                         /   \\\n      3     6        ---\x3e           4     6\n     /  \\     \\                    /       \\\n    2    4     7                  2         7\n\nInput: root = [5,3,6,2,4,null,7], key = 3\nOutput: [5,4,6,2,null,null,7]\n```\n\nExplanation: Given key to delete is 3. So we find the node with value 3 and delete it.\nOne valid answer is [5,4,6,2,null,null,7], shown in the above BST.\nPlease notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.\n\n```js\n      5\n    /   \\\n   2     6\n    \\     \\\n     4     7\n```\n\nExample 2:\n\nInput: root = [5,3,6,2,4,null,7], key = 0\nOutput: [5,3,6,2,4,null,7]\nExplanation: The tree does not contain a node with value = 0.\n\nExample 3:\n\nInput: root = [], key = 0\nOutput: []\n \nConstraints:\n\n* The number of nodes in the tree is in the range [0, 104].\n* -105 <= Node.val <= 105\n* Each node has `a unique value`.\n* root is a valid binary search tree.\n* -105 <= key <= 105\n\n### Analyze\n\n```js\n      5\n    /   \\\n   3     6\n /  \\     \\\n2    4     7\n```\n\n```js\n      3\n    /   \\\n   2     4\n          \\\n           6\n            \\\n             7\n```\n\n* 此时删除元素为 5, 此时含有左节点, 可以通过如下方法达到目的:\n  * 将`删除元素的左下方元素 3` 替代`删除元素 5`;\n  * 将`左下方元素的右侧最下方子元素 4` 衔接`删除元素的右下方子元素 6`;\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} key\n * @return {TreeNode}\n */\nvar deleteNode = function(root, key) {\n  if (!root) return null\n  // if key > root.val, delete node in root.right. Otherwise delete node in root.left.\n  if (key > root.val) {\n    const rightNode = deleteNode(root.right, key)\n    root.right = rightNode\n    return root\n  } else if (key < root.val) {\n    const leftNode = deleteNode(root.left, key)\n    root.left = leftNode\n    return root\n  } else {\n    // now root.val === key\n    if (!root.left) {\n      return root.right\n    }\n    if (!root.right) {\n      return root.left\n    }\n    // 将删除元素的左下方元素替代删除元素;\n    // 将左下方元素的右侧最下方子元素衔接删除元素的右下方子元素;\n    const rightChild = root.right\n    let newRightChild = root.left\n    while (newRightChild.right) {\n      newRightChild = newRightChild.right\n    }\n    newRightChild.right = rightChild\n    return root.left\n  }\n};\n```"}}]);