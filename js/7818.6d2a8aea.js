(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7818],{7818:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>p});var r=t(59713),l=t.n(r),s=t(6479),a=t.n(s),i=(t(67294),t(3905));function c(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?c(Object(t),!0).forEach((function(n){l()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var u={};function p(e){var n=e.components,t=a()(e,["components"]);return(0,i.kt)("wrapper",o(o(o({},u),t),{},{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h3",null,"title"),(0,i.kt)("p",null,"给定一个字符串, 找出不含有重复字符的最长子串的长度。"),(0,i.kt)("p",null,"示例:"),(0,i.kt)("pre",null,(0,i.kt)("code",o({parentName:"pre"},{className:"language-js"}),'给定 "abcabcbb", 没有重复字符的最长子串是 "abc", 那么长度就是 3。\n\n给定 "bbbbb", 最长的子串就是 "b", 长度是 1。\n\n给定 "pwwkew", 最长子串是 "wke", 长度是 3。请注意答案必须是一个子串, "pwke" 是子序列而不是子串。\n')),(0,i.kt)("h3",null,"题解"),(0,i.kt)("p",null,"方法名: 滑动窗口是字符串/数组中常用概念"),(0,i.kt)("p",null,"解法一: ",(0,i.kt)("inlineCode",{parentName:"p"},"判断字符串 s[i, j) 中是否有 s.charAt(j + 1), 如果有, 给左区间加上相应的值"),", 执行时间大致为 98ms 左右。"),(0,i.kt)("p",null,"具体步骤如下:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"取滑动列表 ","[left, right]",";"),(0,i.kt)("li",{parentName:"ol"},"若列表 ","[left, right]"," 中的取值之和小于 s, 则列表的有边界 right 往右扩张。"),(0,i.kt)("li",{parentName:"ol"},"若列表 ","[left, right]"," 中的取值之和大于 s, 则列表的左边界 left 往右扩张。")),(0,i.kt)("pre",null,(0,i.kt)("code",o({parentName:"pre"},{className:"language-js"}),"/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n  if (s.length < 1) {\n    return 0\n  }\n  let i = 0, j = 1, longest = 1\n  while (j < s.length) {\n    if (s.slice(i, j).indexOf(s.charAt(j)) > -1) {\n      i += s.slice(i, j).indexOf(s.charAt(j)) + 1\n    } else {\n      longest = Math.max(j - i + 1, longest)\n    }\n    j++\n  }\n  return longest\n}\n")),(0,i.kt)("p",null,"思考: 针对 ",(0,i.kt)("inlineCode",{parentName:"p"},"判断字符串 s[i, j) 中是否有 s.charAt(j + 1)")," 这一句, 是否能使用 O(n) 时间复杂度的算法代替 indexOf 呢? 使用 cacheObj 来缓存值, 测试执行时间大致为 170ms 左右。"),(0,i.kt)("pre",null,(0,i.kt)("code",o({parentName:"pre"},{className:"language-js"}),"/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n  let left = 0, right = 0 // [left, right] 区域\n  let result = 0 // 假定结果的初始值为 0\n  const cacheObj = {}\n\n  while (left < s.length) {\n    if (right < s.length && !cacheObj[s[right]]) {\n      cacheObj[s[right]] = 1\n      result = Math.max(result, right - left + 1)\n      right++\n    } else {\n      cacheObj[s[left]] = null\n      left++\n    }\n  }\n  if (result === 0) {\n    return 0\n  }\n  return result\n}\n")),(0,i.kt)("h3",null,"Sister Title"),(0,i.kt)("p",null,"76(todo)、209、438"))}p.isMDXComponent=!0}}]);