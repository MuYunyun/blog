(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1802],{71802:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>p});var r=t(59713),a=t.n(r),l=t(6479),m=t.n(l),i=(t(67294),t(3905));function u(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function g(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?u(Object(t),!0).forEach((function(e){a()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):u(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var o={};function p(n){var e=n.components,t=m()(n,["components"]);return(0,i.kt)("wrapper",g(g(g({},o),t),{},{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h3",null,"120. Triangle"),(0,i.kt)("p",null,"Given a triangle array, return the ",(0,i.kt)("inlineCode",{parentName:"p"},"minimum path sum")," from top to bottom."),(0,i.kt)("p",null,"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either ",(0,i.kt)("inlineCode",{parentName:"p"},"index i")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"index i + 1")," on the next row."),(0,i.kt)("p",null,"Example 1:"),(0,i.kt)("pre",null,(0,i.kt)("code",g({parentName:"pre"},{className:"language-js"}),"Input: triangle = [[2], [3,4], [6,5,7], [4,1,8,3]]\n2 3 6 1\n2 3 5 1\nOutput: 11\nExplanation: The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n")),(0,i.kt)("p",null,"Example 2:"),(0,i.kt)("pre",null,(0,i.kt)("code",g({parentName:"pre"},{className:"language-js"}),"Input: triangle = [[-10]]\nOutput: -10\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Constraints:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"1 <= triangle.length <= 200"),(0,i.kt)("li",{parentName:"ul"},"triangle","[0]",".length == 1"),(0,i.kt)("li",{parentName:"ul"},"triangle","[i]",".length == triangle","[i - 1]",".length + 1"),(0,i.kt)("li",{parentName:"ul"},"-104 <= triangle","[i][j]"," <= 104")))),(0,i.kt)("p",null," \nFollow up: Could you do this using only O(n) extra space, where n is the total number of rows in the triangle?"),(0,i.kt)("h3",null,"Analyze"),(0,i.kt)("pre",null,(0,i.kt)("code",g({parentName:"pre"},{className:"language-js"}),"2\n3 4\n6 5 7\n4 1 6 8\n")),(0,i.kt)("p",null,"根据题意如果当前值的下标为 ",(0,i.kt)("inlineCode",{parentName:"p"},"(m, n)"),", 则其下一个数的下标为 ",(0,i.kt)("inlineCode",{parentName:"p"},"(m + 1， n)")," 或者 ",(0,i.kt)("inlineCode",{parentName:"p"},"(m + 1, n + 1)"),"。"),(0,i.kt)("pre",null,(0,i.kt)("code",g({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[][]} triangle\n * @return {number}\n */\nvar minimumTotal = function(triangle) {\n  const cache = { smallest: Infinity }\n  getSmaller(triangle, 0, 0, 0, cache)\n  return cache.smallest\n}\n\n// m: witch row\n// n: witch column\n// result: current min value\nvar getSmaller = function(triangle, m, n, result, cache) {\n  const sum = result + (triangle[m][n] ? triangle[m][n] : 0)\n  if (m === triangle.length - 1) {\n    cache.smallest = Math.min(cache.smallest, sum)\n    return\n  }\n\n  getSmaller(triangle, m + 1, n, sum, cache)\n  getSmaller(triangle, m + 1, n + 1, sum, cache)\n}\n")),(0,i.kt)("p",null,"此时提交的时候执行时间超时, 开始优化!"),(0,i.kt)("p",null,"首先使用 ",(0,i.kt)("inlineCode",{parentName:"p"},"f(m, n) = Math.min(f(m + 1, n), f(m + 1, n + 1)) + triangle[m][n]")," 优化、精简代码如下:"),(0,i.kt)("pre",null,(0,i.kt)("code",g({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[][]} triangle\n * @return {number}\n */\nvar minimumTotal = function(triangle) {\n  return getSmaller(triangle, 0, 0)\n}\n\n// m: witch row\n// n: witch column\nvar getSmaller = function(triangle, m, n) {\n  console.log('m', m, 'n', n, 'triangle', triangle[m][n])\n  if (m === triangle.length - 1) {\n    return triangle[m][n]\n  }\n  const a = getSmaller(triangle, m + 1, n)\n  const b = getSmaller(triangle, m + 1, n + 1)\n  return (a < b ? a : b) + triangle[m][n]\n}\n")),(0,i.kt)("p",null,"以 ",(0,i.kt)("inlineCode",{parentName:"p"},"var triangle = [[2], [3,4], [6,5,7], [4,1,8,3]]")," 为例, 当前 ",(0,i.kt)("inlineCode",{parentName:"p"},"getSmaller")," 函数执行次数为 15。调用栈如下:"),(0,i.kt)("pre",null,(0,i.kt)("code",g({parentName:"pre"},{className:"language-js"}),"2\n3 4\n6 5 7\n4 1 8 3\n\nm 0 n 0 triangle 2\nm 1 n 0 triangle 3\nm 2 n 0 triangle 6\nm 3 n 0 triangle 4\nm 3 n 1 triangle 1\nm 2 n 1 triangle 5 <-\nm 3 n 1 triangle 1 <-\nm 3 n 2 triangle 8 <-\nm 1 n 1 triangle 4\nm 2 n 1 triangle 5 <-\nm 3 n 1 triangle 1 <-\nm 3 n 2 triangle 8 <-\nm 2 n 2 triangle 7\nm 3 n 2 triangle 8\nm 3 n 3 triangle 3\n")),(0,i.kt)("p",null,"此时可以发现箭头处的调用是相似的, 故而可以使用缓存减少调用栈的次数。缓存优化如下:"),(0,i.kt)("pre",null,(0,i.kt)("code",g({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[][]} triangle\n * @return {number}\n */\nvar minimumTotal = function(triangle) {\n  return getSmaller(triangle, 0, 0, {})\n}\n\n// m: witch row\n// n: witch column\nvar getSmaller = function(triangle, m, n, cache) {\n  console.log('m', m, 'n', n, 'triangle', triangle[m][n])\n  if (m === triangle.length - 1) {\n    return triangle[m][n]\n  }\n  const a = typeof cache[`${m + 1}_${n}`] === 'number'\n    ? cache[`${m + 1}_${n}`]\n    : getSmaller(triangle, m + 1, n, cache)\n  const b = typeof cache[`${m + 1}_${n + 1}`] === 'number'\n    ? cache[`${m + 1}_${n + 1}`]\n    : getSmaller(triangle, m + 1, n + 1, cache)\n  const result = (a < b ? a : b) + triangle[m][n]\n  cache[`${m}_${n}`] = result\n  return result\n}\n")),(0,i.kt)("p",null,"执行优化后式子, 调用栈如下, 可以发现此前箭头处重复的调用现已缩小为一次。"),(0,i.kt)("pre",null,(0,i.kt)("code",g({parentName:"pre"},{className:"language-js"}),"m 0 n 0 triangle 2\nm 1 n 0 triangle 3\nm 2 n 0 triangle 6\nm 3 n 0 triangle 4\nm 3 n 1 triangle 1\nm 2 n 1 triangle 5 <-\nm 3 n 1 triangle 1 <-\nm 3 n 2 triangle 8 <-\nm 1 n 1 triangle 4\nm 2 n 2 triangle 7\nm 3 n 2 triangle 8\nm 3 n 3 triangle 3\n")),(0,i.kt)("p",null,"接着使用动态规划的思路来解题, 因为其递归方向为至底向上, 因此可以减少缓存记忆化的环节。"),(0,i.kt)("p",null,"思路为遍历 ",(0,i.kt)("inlineCode",{parentName:"p"},"triangle")," 最后一行数据, 向上查找数据。取和为最小的那次数据。"),(0,i.kt)("pre",null,(0,i.kt)("code",g({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[][]} triangle\n * @return {number}\n */\nvar minimumTotal = function(triangle) {\n  let result = Infinity\n  for (let n = 0; n < triangle[triangle.length - 1].length; n++) {\n    const value = getSmaller(triangle, triangle.length - 1, n)\n    result = Math.min(value, result)\n  }\n  return result\n}\n\nvar getSmaller = function(triangle, m, n) {\n  if (m === 0) {\n    return triangle[m][n]\n  }\n\n  const a = getSmaller(triangle, m - 1, n)\n  if (triangle[m - 1][n - 1] === undefined) {\n    return a + triangle[m][n]\n  }\n\n  const b = getSmaller(triangle, m - 1, n - 1)\n  return (a < b ? a : b) + triangle[m][n]\n}\n")),(0,i.kt)("p",null,"此时提交报",(0,i.kt)("inlineCode",{parentName:"p"},"超时"),", 如上解法已然是从下往上递归了呀, 难道这样子仍然没有满足动态规划思路么? 问题出在哪呢?"),(0,i.kt)("p",null,"参考社区上同学的题解, 动态规划本质是从下往上的递归, 相比从上往下的递归, 它节省的是重复函数栈调用的开销。值得注意的是, 它也",(0,i.kt)("inlineCode",{parentName:"p"},"需要记忆化"),", 故而上述代码会超时, 下面给出记忆化的代码片段:"),(0,i.kt)("pre",null,(0,i.kt)("code",g({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[][]} triangle\n * @return {number}\n */\nvar minimumTotal = function(triangle) {\n  const arr = []\n  for (let m = triangle.length - 1; m >= 0; m--) {\n    for (let n = 0; n <= m; n++) {\n      if (!arr[m]) arr[m] = []\n      if (!arr[m + 1]) {\n        arr[m][n] = triangle[m][n]\n      } else {\n        arr[m][n] = Math.min(arr[m + 1][n], arr[m + 1][n + 1]) + triangle[m][n]\n      }\n    }\n  }\n  return arr[0][0]\n}\n")),(0,i.kt)("h3",null,"Similar Title"),(0,i.kt)("p",null,"64"),(0,i.kt)("p",null,"值得二刷"))}p.isMDXComponent=!0}}]);