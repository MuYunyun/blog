(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1825],{21825:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>s});var a=t(59713),l=t.n(a),p=t(6479),r=t.n(p),i=(t(67294),t(3905));function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function u(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){l()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var c={};function s(n){var e=n.components,t=r()(n,["components"]);return(0,i.kt)("wrapper",u(u(u({},c),t),{},{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h3",null,"SearchBar"),(0,i.kt)("p",null,"在使用 css 的动画属性 ",(0,i.kt)("inlineCode",{parentName:"p"},"transition")," 时, 如果变化前后以下属性改变会使动画失效。",(0,i.kt)("inlineCode",{parentName:"p"},"display/text-align"),"; 所以要维持动画的生效, 保留了 ",(0,i.kt)("inlineCode",{parentName:"p"},"text-align: center")," 属性, 让搜索字样居中。如下图是动画前后的效果。"),(0,i.kt)("p",null,(0,i.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/cb02d781a8437bb43eea1581d41e6c87.jpg",alt:null}))),(0,i.kt)("p",null,(0,i.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/004c6594536786fb1bb57e3df5524831.jpg",alt:null}))),(0,i.kt)("p",null,"受 ",(0,i.kt)("inlineCode",{parentName:"p"},"text-align: center")," 影响, 为了不让 🔍 icon 居中, 这个时候使用 ",(0,i.kt)("inlineCode",{parentName:"p"},"visibility: hidden")," 来占位;"),(0,i.kt)("p",null,(0,i.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/9366ca8f6e6f6d7c85d34ca893af131a.jpg",alt:null}))),(0,i.kt)("h3",null,"几个事件钩子的调用先后顺序"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"onBlur"),": 失焦"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"onClear"),": 点击清除图标触发清除"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"onFocus"),": 聚焦")),(0,i.kt)("p",null,(0,i.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/d188c846ffbd8c79646a940c352686d5.jpg",alt:null}))),(0,i.kt)("p",null,"点击叉号的时候, 因为叉号不在 ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," 输入框内, 所以首先执行的是 ",(0,i.kt)("inlineCode",{parentName:"p"},"onBlur"),", 此时失去焦点, 后续执行不了叉号上的 ",(0,i.kt)("inlineCode",{parentName:"p"},"handleClear")," 逻辑。解决方法如下:"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-js"}),"handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n  const { onBlur } = this.props\n  onBlur(e)\n\n  setTimeout(() => {\n    // 如果点击叉号, 执行到这里时候 document.activeElement === this.inputRef\n    if (document.activeElement !== this.inputRef) {\n      this.setState({ focus: false })\n    }\n  }, 20)\n}\n\n/* 清空输入并重新聚焦 */\nhandleClear = () => {\n  const { onClear, onChange } = this.props\n  onChange && onChange('')\n  onClear('')\n  this.focus()\n}\n\nfocus = () => {\n  if (this.inputRef) {\n    this.inputRef.focus()\n  }\n}\n")),(0,i.kt)("h3",null,"解决点击 🔍 不 blur 仍然保持聚焦的效果"),(0,i.kt)("p",null,(0,i.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/afa95e394ae7ff8b1b180b0407acf424.jpg",alt:null}))),(0,i.kt)("p",null,"当点击搜索 ",(0,i.kt)("inlineCode",{parentName:"p"},"icon")," 的时候, 为了仍保留 ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," 的聚焦的效果, 使用 ",(0,i.kt)("inlineCode",{parentName:"p"},"z-index")," 对 ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," 元素做如下操作。"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-css"}),".demo {\n  position: absolute;\n  z-index: 2;\n  background-color: transparent;\n}\n")))}s.isMDXComponent=!0}}]);