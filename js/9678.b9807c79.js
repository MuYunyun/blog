(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9678],{79678:n=>{n.exports="### 61.Rotate List\n\nGiven a linked list, rotate the list to the right by k places, where `k is non-negative`.\n\nExample 1:\n\n```js\nInput: 1->2->3->4->5->NULL, k = 2\nOutput: 4->5->1->2->3->NULL\n\nExplanation:\nrotate 1 steps to the right: 5->1->2->3->4->NULL\nrotate 2 steps to the right: 4->5->1->2->3->NULL\n```\n\nExample 2:\n\n```js\nInput: 0->1->2->NULL, k = 4\nOutput: 2->0->1->NULL\nExplanation:\nrotate 1 steps to the right: 2->0->1->NULL\nrotate 2 steps to the right: 1->2->0->NULL\nrotate 3 steps to the right: 0->1->2->NULL\nrotate 4 steps to the right: 2->0->1->NULL\n```\n\n### Analyze\n\n分析: 该题可以转化为从尾部向前数到第 k 个元素, 将该元素作为头节点, 同时将初始尾节点的下一个节点指向初始头节点。\n\n1. 第一步: 遍历一遍链表得到初始尾结点 last;\n2. 第二步: l 与 r 距离保持为 modK + 1;\n3. 第三步: l 与 r 同时向右移动, 直到 r 为 null, 则 l 为要分割的元素;\n\n> 此外如果链表长度为 0 或者链表长度与 k 相等时, 则链表实际上没有旋转交换位置。\n\n```js\n  l                r\ndummy -> 1 -> 2 -> 3 -> 4 -> 5 -> NULL\n                   .\n                   .\n                   l               r\ndummy -> 1 -> 2 -> 3 -> 4 -> 5 -> NULL\n```\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n  const dummy = new ListNode(0)\n  dummy.next = head\n  let count = 0\n  let last = dummy\n  while (last.next) {\n    last = last.next\n    count++\n  }\n\n  if (count === 0 || count === k) return dummy.next\n  const modK = k % count\n  let diff = modK + 1\n\n  let l = dummy\n  let r = dummy\n  while (diff--) {\n    r = r.next\n  }\n\n  while (r) {\n    r = r.next\n    l = l.next\n  }\n\n  last.next = dummy.next\n  dummy.next = l.next\n  l.next = null\n\n  return dummy.next\n}\n```\n\n### Sister Title\n\n19"}}]);