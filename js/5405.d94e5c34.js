(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5405],{55405:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>c});var a=n(59713),l=n.n(a),r=n(6479),o=n.n(r),i=(n(67294),n(3905));function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){l()(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var m={};function c(e){var t=e.components,n=o()(e,["components"]);return(0,i.kt)("wrapper",p(p(p({},m),n),{},{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h3",null,"jest 与 jest-dom(ReactTestingLibrary)"),(0,i.kt)("h3",null,"一些配置"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"jest.config.js")," 的一些常见配置属性如下:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"module.exports = {\n  // 可以指定测试环境\n  testEnviroment: 'jest-environment-node' | 'jest-enviroment-jsdom',\n  // 指定模块加载目录\n  moduleDirectories: ['node_modules', path.join(__dirname, 'src'), 'shared']\n  // identity-obj-proxy 支持在 jest 中引入 css, 同时支持 css 的模块化\n  moduleNameMapper: {\n    \"\\\\.(css|less|scss)$\": \"identity-obj-proxy\",\n  },\n  // before jest is loaded(不依赖 jest)\n  setupFiles: []\n  // after jest is loaded(依赖 jest)\n  setupTestFrameworkScriptFile: require.resolve('./test/setup-tests.js')\n  // 测试覆盖率收集目录\n  collectCoverageFrom: ['src/**/*.js']\n  // 指定测试覆盖率需要需要达到的阈值\n  coverageThreshold: {\n    global: {\n      statements: 80,\n      branches: 80,\n      lines: 80,\n      functions: 80,\n    }\n  }\n  // 增强 watch 模式体验: $ npm install --save-dev jest-watch-typeahead\n  watchPlugins: [\n    'jest-watch-typeahead/filename',\n    'jest-watch-typeahead/testname',\n  ]\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("a",p({parentName:"p"},{href:"https://github.com/emotion-js/emotion"}),"jest-emotion"),": css 中具体样式发生更改便重新生成 snapshot。")),(0,i.kt)("h3",null,"jest-dom"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"jest-dom")," 封装了测试 dom 的方法。报错的信息可以更加准确。"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"import 'jest-dom/extend-expect'\n")),(0,i.kt)("p",null,"此时可以使用如下方法:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"expect(input).toHavaAttribute('type', 'number') // 是否有某个属性\nexpect(..).toHaveTextContent()                  // 是否有某个内容\n")),(0,i.kt)("h3",null,"dom-test-library"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"dom-test-library")," 的优势。"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"增加了更多的操作, 比如根据 label 找对应的节点;"),(0,i.kt)("li",{parentName:"ul"},"支持正则匹配;")),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"import { queries } from 'dom-testing-library'\n")),(0,i.kt)("h3",null,"@testing-library/react 的使用"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"@testing-library/react")," 在 ",(0,i.kt)("inlineCode",{parentName:"p"},"dom-test-library")," 的基础上查找 React 组件。"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"import 'react-testing-library/cleanup-after-each' // 自动完成每次的回收\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"可以使用 ",(0,i.kt)("inlineCode",{parentName:"li"},"react-testing-library")," 中的 debug 函数来对子组件进行断点调试。")),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"test('...', () => {\n  const { debug } = render(<Component />)\n  debug()\n  // or\n  debug(<SomeComponent />)\n})\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Test React Component Event Handlers with fireEvent from react-testing-library")),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"import { fireEvent } from 'react-testing-library'\n\nfireEvent.change()\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"几种断言方式")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"方式一: ",(0,i.kt)("inlineCode",{parentName:"p"},"expect(container).toHaveTextContent(/the number is invalid/i)"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"方式二: ",(0,i.kt)("inlineCode",{parentName:"p"},"getByText(/the number is invalid/i)"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"方式三: ",(0,i.kt)("inlineCode",{parentName:"p"},"expect(getByText(/the number is invalid/i)).toBeTruthy()"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"方式四: 配合 ",(0,i.kt)("inlineCode",{parentName:"p"},"data-testid")," 属性可以使用 ",(0,i.kt)("inlineCode",{parentName:"p"},"expect(getByTestId('...')).toHaveTextContent(/the number is invalid/i)"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Test prop updates with react-testing-library"))),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"test('...', () => {\n  const { rerender } = render(<Component />)\n  rerender(<SomeComponent />)\n})\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getByLabelText"),"       (form inputs)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getByPlaceholderText")," (only if your input doesn’t have a label — less accessible!)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getByText"),"            (buttons and headers)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getByAltText"),"         (images)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getByTestId"),"          (use this for things like dynamic text or otherwise odd elements you want to test)")),(0,i.kt)("p",null,"上述每一个方法都有对应的 ",(0,i.kt)("inlineCode",{parentName:"p"},"queryByFoo")," 替代方法。以 ",(0,i.kt)("inlineCode",{parentName:"p"},"query")," 开头的方法找不到的话会返回 null, 以 ",(0,i.kt)("inlineCode",{parentName:"p"},"get")," 开头的方法找不到的话会 throw。"),(0,i.kt)("p",null,"如果这些都不会让你确切地知道你在找什么, render 方法也会返回映射到 container 属性的 DOM 元素，所以也可以像 ",(0,i.kt)("inlineCode",{parentName:"p"},"container.querySelector('body #root')")," 一样使用它。"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Mock HTTP Requests with jest.mock in React Component Tests")),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"import { render, fireEvent, wait } from 'react-testing-library'\nimport {loadGreeting as mockLoadGreeting} from '../api'\n\njest.mock('../api', () => {\n  return {\n    loadGreeting: jest.fn(subject =>\n      Promise.resolve({data: {greeting: `Hi ${subject}`}}),\n    ),\n  }\n})\n\ntest('loads greetings on click', () => {\n  const {getByLabelText, getByText, getByTestId} = render(<GreetingLoader />)\n  const nameInput = getByLabelText(/name/i)\n  const loadButton = getByText(/load/i)\n  nameInput.value = 'Mary'\n  fireEvent.click(loadButton)\n  await wait(() => expect(getByTestId('greeting')).toHaveTextContent())\n  expect(mockLoadGreeting).toHaveBeenCalledTimes(1)\n  expect(mockLoadGreeting).toHaveBeenCalledWith('Mary')\n})\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Mock react-transition-group in React Component Tests with jest.mock")),(0,i.kt)("p",null,"比如 ",(0,i.kt)("inlineCode",{parentName:"p"},"react-transition-group")," 动画库也是存在异步库, 它会在 1s 后将 Children 隐藏, 这时候可以使用 ",(0,i.kt)("inlineCode",{parentName:"p"},"mock")," 来处理。"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"jest.mock('react-transition-group', () => {\n  return {\n    CSSTransition: props => (props.in ? props.children : null),\n  }\n})\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"将 ",(0,i.kt)("inlineCode",{parentName:"li"},"console.error()")," mock 掉")),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"beforeEach(() => {\n  jest.spyOn(console, 'error').mockImplementation(() => {})\n})\n\nafterEach(() => {\n  console.error.mockRestore()\n})\n")),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"// componentDidCatch 里的两个参数\nconst error = expect.any(Error)\nconst info = {componentStack: expect.stringContaining('Bomb')}\nexpect(mockReportError).toHaveBeenCalledWith(error, info)\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",p({parentName:"li"},{href:"https://github.com/testing-library/jest-dom"}),"jest-dom"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",p({parentName:"li"},{href:"https://github.com/testing-library/jest-dom#tobevisible"}),"toBeVisible"))))),(0,i.kt)("h3",null,"mock 测试"),(0,i.kt)("h4",null,"mock 请求后端接口数据"),(0,i.kt)("p",null,"当测试需要请求后端接口数据的 UI 组件(比如图片上传组件), 为了防止接口不稳定等影响到测试用例通过, 通常需要对请求后端接口数据进行 mock。"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"当需要测试接口返回的真实数据时可以对其进行集成测试。")),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"jest.spyOn(global, 'fetch').mockImplementation(() => {\n  Promise.resolve({\n    json: () => Promise.resolve(mockData)\n  })\n})\n")),(0,i.kt)("h4",null,"mock 浏览器节点信息"),(0,i.kt)("p",null,"在使用 JEST 测试一些需要浏览器位置信息的组件(比如 PullToRefresh、Scrollbar 组件等等)时, 需要将浏览器节点信息给 mock 掉。"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"将获取位置的方法抽离到 util 包中;",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"这也是为什么尽量将",(0,i.kt)("inlineCode",{parentName:"li"},"函数力度拆细"),"的原因。"))),(0,i.kt)("li",{parentName:"ol"},"mock util 包中的该方法;")),(0,i.kt)("h4",null,"mock 模块/组件"),(0,i.kt)("p",null,"如果存在对当前组件的测试影响不大的第三方模块, 可以将相关模块/组件进行 mock, 从而可以提高测试的效率。"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"jest.mock('someComponent', () => {\n  return (props) => {\n    return <span>mock Component</span>\n  }\n})\n")),(0,i.kt)("h4",null,"mock 时间类 api"),(0,i.kt)("p",null,"如果测试用例中遇到 ",(0,i.kt)("inlineCode",{parentName:"p"},"setTimeout(fn, 5000)")," 真的等上 5s 后才执行 fn 测试效率是非常低效的, 因此可以使用 jest 提供的 ",(0,i.kt)("inlineCode",{parentName:"p"},"jest.useFakeTimers()")," 来 mock 与时间有关的 api。"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"// mocks out setTimeout and other timer functions with mock functions.\njest.useFakeTimers()\n\n// use jest.runAllTimers() to make sure all perf of callback.\njest.runAllTimers()\n\n// move ahead in time by 100ms\nact(() => {\n  jest.advanceTimersByTime(100)\n})\n")),(0,i.kt)("h3",null,"act"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"act")," 确保其函数里跟的单元方法(比如 rendering、用户事件、数据获取)在执行步骤 ",(0,i.kt)("inlineCode",{parentName:"p"},"make assertions")," 之前已经全部执行完。"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"act(() => {\n  // render components\n})\n// make assertions\n")),(0,i.kt)("h3",null,"书写一个测试函数"),(0,i.kt)("p",null,"测试函数有两种风格, BDD(行为驱动开发) 以及 TDD(测试驱动开发)。"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"BDD 风格: ",(0,i.kt)("inlineCode",{parentName:"li"},"foo.should.equal('bar')")," 或者 ",(0,i.kt)("inlineCode",{parentName:"li"},"expect(foo).to.equal('bar')"),";"),(0,i.kt)("li",{parentName:"ul"},"TDD 风格: ",(0,i.kt)("inlineCode",{parentName:"li"},"assert.equal(foo, 'bar', 'foo equal bar')"),";")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("a",p({parentName:"p"},{href:"https://www.chaijs.com/guide/styles/"}),"几种断言类型"))),(0,i.kt)("p",null,"下面我们来书写基于 BDD 风格的 test 函数:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"async function test(title, callback) {\n  try {\n    await callback()\n    console.log(`✓ ${title}`)\n  } catch (error) {\n    console.error(`✕ ${title}`)\n    console.error(error)\n  }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"expect")," 函数:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"function expect(actual) {\n  return {\n    toBe(expected) {\n      if (actual !== expected) {\n        throw new Error(`${actual} is not equal to ${expected}`)\n      }\n    }\n  }\n}\n")),(0,i.kt)("p",null,"应用:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),'const sum = (a, b) => a + b\n\ntest("sum adds numbers", async () => {\n  const result = await sum(3, 7)\n  const expected = 10\n  expect(result).toBe(expected)\n})\n')),(0,i.kt)("h3",null,"不得不测实例上的方法?"),(0,i.kt)("p",null,"如果在 '@testing-library/react' 中测试某些组件暴露给业务方的钩子, 记录了下可以这样子测试"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"it('test instance exist', () => {\n  let instance\n  render(\n    <Component\n      ref={node => {\n        instance = node\n      }}\n    />\n  )\n  expect(Object.prototype.toString.call(instance.A)).toBe('[object Function]')\n  expect(Object.prototype.toString.call(instance.B)).toBe('[object Function]')\n})\n")),(0,i.kt)("h3",null,"link"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",p({parentName:"li"},{href:"https://blog.sapegin.me/all/react-testing-3-jest-and-react-testing-library/"}),"react-testing-3-jest-and-react-testing-library/"))))}c.isMDXComponent=!0}}]);