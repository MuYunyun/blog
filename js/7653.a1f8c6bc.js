(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7653],{47653:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>i});var l=t(59713),o=t.n(l),r=t(6479),a=t.n(r),s=(t(67294),t(3905));function c(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);n&&(l=l.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,l)}return t}function p(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?c(Object(t),!0).forEach((function(n){o()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var u={};function i(e){var n=e.components,t=a()(e,["components"]);return(0,s.kt)("wrapper",p(p(p({},u),t),{},{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h3",null,"Promise/A+ 核心"),(0,s.kt)("p",null,(0,s.kt)("img",p({parentName:"p"},{src:"http://with.muyunyun.cn/e1a0c15c44f9b014aa78d7b7620db474.jpg-200",alt:null}))),(0,s.kt)("p",null,"在实现一个符合 Promise/A+ 规范的 promise 之前, 先了解下 Promise/A+ 核心, 想更全面地了解可以阅读 ",(0,s.kt)("a",p({parentName:"p"},{href:"https://segmentfault.com/a/1190000002452115"}),"Promise/A+规范")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Promise 操作只会处在 3 种状态的一种: 未完成态(pending)、完成态(resolved)、失败态(rejected);"),(0,s.kt)("li",{parentName:"ul"},"Promise 的状态只会出现从未完成态向完成态或失败态转化;"),(0,s.kt)("li",{parentName:"ul"},"Promise 的状态一旦转化, 将不能被更改;")),(0,s.kt)("h3",null,"Promise api"),(0,s.kt)("h4",null,"Promise.resolve()"),(0,s.kt)("p",null,"Promise.resolve() 括号内有 4 种情况"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-js"}),'/* 跟 Promise 对象 */\nPromise.resolve(Promise.resolve(1))\n// Promise {state: "resolved", data: 1, callbackQueue: Array(0)}\n\n/* 跟 thenable 对象 */\nvar thenable = {\n  then: function(resolve, reject) {\n    resolve(1)\n  }\n}\n\nPromise.resolve(thenable)\n// Promise {state: "resolved", data: 1, callbackQueue: Array(0)}\n\n/* 普通参数 */\nPromise.resolve(1)\n// Promise {state: "resolved", data: 1, callbackQueue: Array(0)}\n\n/* 不跟参数 */\nPromise.resolve()\n// Promise {state: "resolved", data: undefined, callbackQueue: Array(0)}\n')),(0,s.kt)("h4",null,"Promise.reject()"),(0,s.kt)("p",null,"相较于 Promise.resolve(), Promise.reject() 原封不动地返回参数值"),(0,s.kt)("h4",null,"Promise.all(arr)"),(0,s.kt)("p",null,"对于 Promise.all(arr) 来说, 在参数数组中所有元素都变为决定态后, 然后才返回新的 promise。"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-js"}),"// 以下 demo, 请求两个 url, 当两个异步请求返还结果后, 再请求第三个 url\nconst p1 = request(`http://some.url.1`)\nconst p2 = request(`http://some.url.2`)\n\nPromise.all([p1, p2])\n  .then((datas) => { // 此处 datas 为调用 p1, p2 后的结果的数组\n    return request(`http://some.url.3?a=${datas[0]}&b=${datas[1]}`)\n  })\n  .then((data) => {\n    console.log(msg)\n  })\n")),(0,s.kt)("h4",null,"Promise.race(arr)"),(0,s.kt)("p",null,"对于 Promise.race(arr) 来说, 只要参数数组有一个元素变为决定态, 便返回新的 promise。"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-js"}),"// race 译为竞争, 同样是请求两个 url, 当且仅当一个请求返还结果后, 就请求第三个 url\nconst p1 = request(`http://some.url.1`)\nconst p2 = request(`http://some.url.2`)\n\nPromise.race([p1, p2])\n  .then((data) => { // 此处 data 取调用 p1, p2 后优先返回的结果\n    return request(`http://some.url.3?value=${data}`)\n  })\n  .then((data) => {\n    console.log(data)\n  })\n")),(0,s.kt)("h4",null,"Promise.wrap(fn) —— 回调函数转 Promise"),(0,s.kt)("p",null,"通过下面这个案例, 提供回调函数 Promise 化的思路。"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-js"}),"function foo(a, b, cb) {\n  ajax(\n    `http://some.url?a=${a}&b=${b}`,\n    cb\n  )\n}\n\nfoo(1, 2, function(err, data) {\n  if (err) {\n    console.log(err)\n  } else {\n    console.log(data)\n  }\n})\n")),(0,s.kt)("p",null,"如上是一个传统回调函数使用案例, 假如现在有个函数 Promise.wrap(), 使用其包裹 foo 函数从而使之 promise 化, 用法如下:"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-js"}),"const promiseFoo = Promise.wrap(foo)\n\npromiseFoo(1, 2)\n  .then((data) => {\n    console.log(data)\n  })\n  .catch((err) => {\n    console.log(err)\n  })\n")),(0,s.kt)("p",null,"让我们来实现 Promise.wrap() 函数:"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-js"}),"Promise.wrap = function(fn) {\n  return funtion(...args) {\n    return new Promise((resolve, reject) => {\n      fn.apply(null, args.concat((err, data) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(data)\n        }\n      }))\n    })\n  }\n}\n")),(0,s.kt)("h4",null,"then/catch/done"),(0,s.kt)("p",null,"这几个 api 比较简单, 合起来一起带过"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-js"}),"Promise.resolve(1)\n  .then((data) => {console.log(data)}, (err) => {console.log(err)}) // 链式调用, 可以传一个参数(推荐), 也可以传两个参数\n  .catch((err) => {console.log(err)}) // 捕获链式调用中抛出的错误 || 捕获变为失败态的值\n  .done()                             // 能捕获前面链式调用的错误(包括 catch 中), 可以传两个参数也可不传\n")),(0,s.kt)("h3",null,"实现一个 Promise"),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"实践了一个符合 Promise/A+ 规范的 ",(0,s.kt)("a",p({parentName:"p"},{href:"https://github.com/MuYunyun/repromise"}),"repromise"),"。")),(0,s.kt)("h4",null,"坑点 1: 事件循环"),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"事件循环: 同步队列执行完后, 在指定时间后再执行异步队列的内容。")),(0,s.kt)("p",null,"之所以要单列事件循环, 因为代码的执行顺序与其息息相关, 此处用 setTimeout 来模拟事件循环；"),(0,s.kt)("p",null,"下面代码片段中, ① 处执行完并不会马上执行 setTimeout() 中的代码(③), 而是此时有多少次 then 的调用, 就会重新进入 ② 处多少次后, 再进入 ③"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-js"}),"excuteAsyncCallback(callback, value) {\n  const that = this\n  setTimeout(function() {\n    const res = callback(value) // ③\n    that.excuteCallback('fulfilled', res)\n  }, 4)\n}\n\nthen(onResolved, onRejected) {\n  const promise = new this.constructor()\n  if (this.state !== 'PENDING') {\n    const callback = this.state === 'fulfilled' ? onResolved : onRejected\n    this.excuteAsyncCallback.call(promise, callback, this.data)              // ①\n  } else {\n    this.callbackArr.push(new CallbackItem(promise, onResolved, onRejected)) // ②\n  }\n  return promise\n}\n")),(0,s.kt)("h4",null,"坑点 2: this 的指向问题"),(0,s.kt)("p",null,"this.callbackArr.push() 中的 this 指向的是 ‘上一个’ promise, 所以类 CallbackItem 中, this.promise 存储的是'下一个' promise(then 对象)。"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-js"}),"class Promise {\n  ...\n  then(onResolved, onRejected) {\n    const promise = new this.constructor()\n    if (this.state !== 'PENDING') {        // 第一次进入 then, 状态是 RESOLVED 或者是 REJECTED\n      const callback = this.state === 'fulfilled' ? onResolved : onRejected\n      this.excuteAsyncCallback.call(promise, callback, this.data)  // 绑定 this 到 promise\n    } else {                               // 从第二次开始以后, 进入 then, 状态是 PENDING\n      this.callbackArr.push(new CallbackItem(promise, onResolved, onRejected)) // 这里的 this 也是指向‘上一个’ promise\n    }\n    return promise\n  }\n  ...\n}\n\nclass CallbackItem {\n  constructor(promise, onResolve, onReject) {\n    this.promise = promise // 相应地, 这里存储的 promise 是来自下一个 then 的\n    this.onResolve = typeof(onResolve) === 'function' ? onResolve : (resolve) => {}\n    this.onReject = typeof(onRejected) === 'function' ? onRejected : (rejected) => {}\n  }\n  ...\n}\n")),(0,s.kt)("h3",null,"拓展延伸"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-js"}),"setTimeout(() => {\n  console.log('A')\n}, 0)\n\nPromise.resolve(\n  console.log('B')\n).then(() => {\n  console.log('C')\n})\n\nconsole.log('D')\n")),(0,s.kt)("p",null,"正常情况下, 此 demo 应该输出 ",(0,s.kt)("inlineCode",{parentName:"p"},"B D C A"),", 这里涉及到宏任务和微任务的知识点, 一个宏任务里可以有多个微任务。"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"宏任务(macroTask): setTimeout、requestAnimationFrame"),(0,s.kt)("li",{parentName:"ul"},"微任务(microTask): promise、setImmediate、async/await")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"由于此项目中的 promise 是用 setTimeout 实现的, 所以在上述 demo 中, 此项目输出的结果是 ",(0,s.kt)("inlineCode",{parentName:"p"},"B D A C"),", 解决方法: 可以参考 ",(0,s.kt)("a",p({parentName:"p"},{href:"https://github.com/YuzuJS/setImmediate"}),"setImmediate.js"),"。它的本质用了一些 hack 的手段, 比如借用了 ",(0,s.kt)("inlineCode",{parentName:"p"},"postMessage")," 这个来操作事件循环。")),(0,s.kt)("h3",null,"问题: promise.all 如何做到让多个 setTimeout 并发运行?"),(0,s.kt)("p",null,"这个就是 promise.all() 的本质了, 浏览器内部提供了一个事件循环机制来模拟成伪'并发'"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-js"}),"var oldTime = Date.now()\nsetTimeout(() => {console.log(Date.now() - oldTime)}, 1000) // 1001 ~ 1005(存在 4ms 的波动)\nsetTimeout(() => {console.log(Date.now() - oldTime)}, 2000) // 2001 ~ 2005\n")))}i.isMDXComponent=!0}}]);