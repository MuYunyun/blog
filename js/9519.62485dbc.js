(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9519],{99519:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>c});var r=t(59713),l=t.n(r),o=t(6479),p=t.n(o),a=(t(67294),t(3905));function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function u(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){l()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var s={};function c(n){var e=n.components,t=p()(n,["components"]);return(0,a.kt)("wrapper",u(u(u({},s),t),{},{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h3",null,"归并排序思想"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"取一个基准点, 将数组不断拆分成左右两部分, 直到数组的长度为 1;"),(0,a.kt)("li",{parentName:"ol"},"对拆离的数组进行",(0,a.kt)("inlineCode",{parentName:"li"},"比较合并"),";")),(0,a.kt)("p",null,"演示如下:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-js"}),"3   1   5   2\n\n3   1 | 5   2\n\n3 | 1 | 5 | 2\n\n1   3 | 2   5\n\n1   2   3   5\n")),(0,a.kt)("h3",null,"代码实现"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-js"}),"// 可以把它当成分函数\nvar mergeSort = function(arr) {\n  // 将数组 arr 拆分成 [0, point) 和 [point, arr.length] 两部分\n  const point = arr.length / 2\n  const left = arr.slice(0, point)\n  const right = arr.slice(point, arr.length)\n\n  if (arr.length === 1) {\n    return arr\n  }\n\n  return merge(mergeSort(left), mergeSort(right))\n}\n\n// 可以当作是合函数\nfunction merge(left, right) {\n  let l = 0 // 第一个数组的下标\n  let r = 0 // 第二个数组的下标\n  const result = []\n\n  while (l < left.length && r < right.length) {\n    if (left[l] < right[r]) {\n      result.push(left[l])\n      l++\n    } else {\n      result.push(right[r])\n      r++\n    }\n  }\n\n  while (l < left.length) {\n    result.push(left[l])\n    l++\n  }\n\n  while (r < right.length) {\n    result.push(right[r])\n    r++\n  }\n\n  return result\n}\n")),(0,a.kt)("h3",null,"归并排序与快速排序的异同"),(0,a.kt)("p",null,"归并排序与快速排序都是用递归来实现的算法, 都是分分合合的过程。区别在于归并排序在合的过程中进行排序, 快速排序则在分的过程中进行排序。另外它们的时间复杂度都为 O(nlogn)。"))}c.isMDXComponent=!0}}]);