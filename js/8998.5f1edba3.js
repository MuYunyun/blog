(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8998],{98998:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>f});var r=t(59713),a=t.n(r),o=t(6479),u=t.n(o),l=(t(67294),t(3905));function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function s(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){a()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var m={};function f(n){var e=n.components,t=u()(n,["components"]);return(0,l.kt)("wrapper",s(s(s({},m),t),{},{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h3",null,"112. Path Sum"),(0,l.kt)("p",null,"Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum."),(0,l.kt)("p",null,"Note: A leaf is a node with no children."),(0,l.kt)("p",null,"Example:"),(0,l.kt)("p",null,"Given the below binary tree and sum = 22,"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-js"}),"      5\n     / \\\n    4   8\n   /   / \\\n  11  13  4\n /  \\      \\\n7    2      1\n")),(0,l.kt)("p",null,"return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22."),(0,l.kt)("h3",null,"Analyze"),(0,l.kt)("p",null,"使用递归的思路进行解题:"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} sum\n * @return {boolean}\n */\nvar hasPathSum = function(root, sum) {\n  if (!root) return false\n  return ifHasPathSum(root, sum)\n}\n\nvar ifHasPathSum = function(node, sum) {\n  if (!node && sum !== 0) return false\n  if (!node && sum === 0) return true\n  const remainingVal = sum - node.val\n  const leftResult = ifHasPathSum(node.left, remainingVal)\n  if (leftResult) return true\n  const rightResult = ifHasPathSum(node.right, remainingVal)\n  if (rightResult) return true\n  return false\n}\n")),(0,l.kt)("p",null,"此时 ac, 卡在了以下测试用例中(此题的难点在于对递归终止条件的判断)"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-js"}),"    1\n  /   \\\nnull   2\n")),(0,l.kt)("p",null,"先对代码进行整理精简:"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} sum\n * @return {boolean}\n */\nvar hasPathSum = function(root, sum) {\n  if (!root) return false\n  return ifHasPathSum(root, sum)\n}\n\nvar ifHasPathSum = function(node, sum) {\n  if (!node) return sum === 0\n  const remainingVal = sum - node.val\n  return ifHasPathSum(node.left, remainingVal) || ifHasPathSum(node.right, remainingVal)\n}\n")),(0,l.kt)("p",null,"终止条件应由",(0,l.kt)("inlineCode",{parentName:"p"},"判断当前节点为空而且 sum === 0"),"调整为",(0,l.kt)("inlineCode",{parentName:"p"},"判断当前节点为叶子节点且 node.val === sum"),", 再次修正代码"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} sum\n * @return {boolean}\n */\nvar hasPathSum = function(root, sum) {\n  if (!root) return false\n  if (!root.left && !root.right) return root.val === sum\n  const remainingVal = sum - root.val\n  return hasPathSum(root.left, remainingVal) || hasPathSum(root.right, remainingVal)\n}\n")))}f.isMDXComponent=!0}}]);