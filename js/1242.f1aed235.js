(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1242],{91242:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>m});var r=t(59713),a=t.n(r),l=t(6479),u=t.n(l),o=(t(67294),t(3905));function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var p={};function m(e){var n=e.components,t=u()(e,["components"]);return(0,o.kt)("wrapper",i(i(i({},p),t),{},{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h3",null,"113. Path Sum II"),(0,o.kt)("p",null,"Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum."),(0,o.kt)("p",null,"Note: A leaf is a node with no children."),(0,o.kt)("p",null,"Example:"),(0,o.kt)("p",null,"Given the below binary tree and sum = 22,"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),"      5\n     / \\\n    4   8\n   /   / \\\n  11  13  4\n /  \\    / \\\n7    2  5   1\n")),(0,o.kt)("p",null,"Return:"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),"[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n")),(0,o.kt)("h3",null,"Analyze"),(0,o.kt)("p",null,"思路: 结合 DFS 中的先序遍历将所有解推入数组中。"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} sum\n * @return {number[][]}\n */\nvar pathSum = function(root, sum) {\n  const result = []\n  if (!root) return []\n  analyzeSum(root, '', result, sum)\n  return result.map(val => {\n    return val.split('->')\n  })\n};\n\n/**\n * node: analyze node\n * str: join str using '->', affected by [257.Binary Tree Paths](https://github.com/MuYunyun/blog/blob/master/LeetCode/257.Binary_Tree_Paths.md)\n * result: result array\n * extra: extra sum need to satisfy\n */\nvar analyzeSum = function(node, str, result, extra) {\n  if (!node) return\n  if (!node.left && !node.right && extra === node.val) {\n    str += node.val\n    result.push(str)\n    return\n  }\n\n  str += `${node.val}->`\n\n  analyzeSum(node.left, str, result, extra - node.val)\n  analyzeSum(node.right, str, result, extra - node.val)\n}\n")),(0,o.kt)("h3",null,"link"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",i({parentName:"li"},{href:"https://github.com/MuYunyun/blog/blob/master/LeetCode/112.Path_Sum.md"}),"112")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",i({parentName:"li"},{href:"https://github.com/MuYunyun/blog/blob/master/LeetCode/257.Binary_Tree_Paths.md"}),"257"))))}m.isMDXComponent=!0}}]);