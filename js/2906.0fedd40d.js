(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2906],{82906:n=>{n.exports="### HTTP 协议主要特点\n\n无状态, 无连接\n\n### HTTP 报文组成部分\n\n* 请求报文: 请求行 请求头 空行 请求体\n* 响应报文: 响应行 响应头 空行 响应体\n\n> 请求行里包括请求方法, url, http 版本; 响应行里包括状态码, http 版本, 状态说明;\n\n### HTTP 协议类: POST 和 GET 的区别\n\n* Get 有长度限制, Post 没有\n* Get 请求, 倒退按钮是无害的, Post 会重新发起请求\n* Get 会主动缓存, Post 不会\n* Get 请求通过 url 传递, Post 通过 request body 传递\n\n### HTTP 状态码\n\n> 1xx:\n\n* 101: 需要切换协议(使用 Websocket 开始阶段是 http 协议, 中间切换到 WebSocket 协议, 此时返回的状态码是 101 表示后续协议还需切换)\n\n> 2xx: 成功状态码\n\n> 3xx: 重定向状态码\n\n* 301: 永久重定向\n* 302: 临时重定向\n* 304: not Modified\n\n(永久重定向中搜索引擎不会保留原有的地址, 临时重定向中搜索引擎会保留原有的地址)\n\n> 4xx: 客户端错误状态码\n\n* 400: Bad Request(错误的请求)\n* 401: Unauthorized(未认证)\n* 403: Forbidden Request(拒绝访问)\n* 404: Not Found(未找到)\n\n> 5xx: 服务端错误状态码\n\n### HTTP 事物时延\n\nDNS 解析、连接、传输、处理。\n\n### HTTP 连接\n\n管道化连接: 依赖于 Http/1.1 是持久连接的。\n\n### 强缓存和协商缓存\n\n> 强缓存是不经过服务器的, 协商缓存是经过服务器的\n\n* 强缓存相关字段(Expires(响应头), Cache-Control(响应头))\n* 协商缓存相关字段(Last-Modified(响应头), If-Modified-Since(请求头), Etag(响应头), If-None-Match(请求头))\n\n如下为 HTTP 缓存机制流程图:\n\n![](http://with.muyunyun.cn/7aa47d51ccc2fe5a66f75c542f014f2e.jpg-400)\n\n### HTTP 2.0\n\n* 二进制流\n* 多路复用\n* 资源推送优先级\n\n### HTTPS\n\n客户端和服务端都有自己的公钥和私钥, 下面来表述下 HTTPS 的双向加密建立。\n\n1. 客户端通知服务端建立请求\n2. 服务端发送公钥\n3. 客户端发送'验证串+服务端公钥' && 客户端公钥\n4. 服务端使用私钥取得验证串与客户端公钥一起发送给客户端\n5. 客户端使用客户端私钥来获取验证串是否匹配\n\n#### 协议解析\n\n多了一个 `upgrade-insecure-requests` 的字段。该字段让页面打开后的请求自动变为 `https`。"}}]);