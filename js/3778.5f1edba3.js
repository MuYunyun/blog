(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3778],{93778:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>h});var l=t(59713),r=t.n(l),o=t(6479),a=t.n(o),i=(t(67294),t(3905));function u(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);n&&(l=l.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,l)}return t}function p(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?u(Object(t),!0).forEach((function(n){r()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):u(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var d={};function h(e){var n=e.components,t=a()(e,["components"]);return(0,i.kt)("wrapper",p(p(p({},d),t),{},{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h3",null,"450.Delete Node in a BST"),(0,i.kt)("p",null,"Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST."),(0,i.kt)("p",null,"Basically, the deletion can be divided into two stages:"),(0,i.kt)("p",null,"Search for a node to remove.\nIf the node is found, delete the node.\nFollow up: Can you solve it with time complexity O(height of tree)?"),(0,i.kt)("p",null,"Example 1:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"         5                             5\n       /   \\                         /   \\\n      3     6        ---\x3e           4     6\n     /  \\     \\                    /       \\\n    2    4     7                  2         7\n\nInput: root = [5,3,6,2,4,null,7], key = 3\nOutput: [5,4,6,2,null,null,7]\n")),(0,i.kt)("p",null,"Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.\nOne valid answer is ","[5,4,6,2,null,null,7]",", shown in the above BST.\nPlease notice that another valid answer is ","[5,2,6,null,4,null,7]"," and it's also accepted."),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"      5\n    /   \\\n   2     6\n    \\     \\\n     4     7\n")),(0,i.kt)("p",null,"Example 2:"),(0,i.kt)("p",null,"Input: root = ","[5,3,6,2,4,null,7]",", key = 0\nOutput: ","[5,3,6,2,4,null,7]","\nExplanation: The tree does not contain a node with value = 0."),(0,i.kt)("p",null,"Example 3:"),(0,i.kt)("p",null,"Input: root = [], key = 0\nOutput: []"),(0,i.kt)("p",null," \nConstraints:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The number of nodes in the tree is in the range ","[0, 104]","."),(0,i.kt)("li",{parentName:"ul"},"-105 <= Node.val <= 105"),(0,i.kt)("li",{parentName:"ul"},"Each node has ",(0,i.kt)("inlineCode",{parentName:"li"},"a unique value"),"."),(0,i.kt)("li",{parentName:"ul"},"root is a valid binary search tree."),(0,i.kt)("li",{parentName:"ul"},"-105 <= key <= 105")),(0,i.kt)("h3",null,"Analyze"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"      5\n    /   \\\n   3     6\n /  \\     \\\n2    4     7\n")),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"      3\n    /   \\\n   2     4\n          \\\n           6\n            \\\n             7\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"此时删除元素为 5, 此时含有左节点, 可以通过如下方法达到目的:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"将",(0,i.kt)("inlineCode",{parentName:"li"},"删除元素的左下方元素 3")," 替代",(0,i.kt)("inlineCode",{parentName:"li"},"删除元素 5"),";"),(0,i.kt)("li",{parentName:"ul"},"将",(0,i.kt)("inlineCode",{parentName:"li"},"左下方元素的右侧最下方子元素 4")," 衔接",(0,i.kt)("inlineCode",{parentName:"li"},"删除元素的右下方子元素 6"),";")))),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} key\n * @return {TreeNode}\n */\nvar deleteNode = function(root, key) {\n  if (!root) return null\n  // if key > root.val, delete node in root.right. Otherwise delete node in root.left.\n  if (key > root.val) {\n    const rightNode = deleteNode(root.right, key)\n    root.right = rightNode\n    return root\n  } else if (key < root.val) {\n    const leftNode = deleteNode(root.left, key)\n    root.left = leftNode\n    return root\n  } else {\n    // now root.val === key\n    if (!root.left) {\n      return root.right\n    }\n    if (!root.right) {\n      return root.left\n    }\n    // 将删除元素的左下方元素替代删除元素;\n    // 将左下方元素的右侧最下方子元素衔接删除元素的右下方子元素;\n    const rightChild = root.right\n    let newRightChild = root.left\n    while (newRightChild.right) {\n      newRightChild = newRightChild.right\n    }\n    newRightChild.right = rightChild\n    return root.left\n  }\n};\n")))}h.isMDXComponent=!0}}]);