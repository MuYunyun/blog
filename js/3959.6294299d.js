(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3959],{73959:n=>{n.exports="### 红皮书里的细节\n\n> 理念: 尽信书则不如无书\n\n### 重载\n\n`Java/C++` 中是有函数重载的(即相同函数名, 但传的参数不同是当成不同函数的), 而 `JavaScript` 没有函数重载, 旧其本质是因为 `JavaScrit` 中函数是一个对象。函数名类似一个指针。\n\n### label 语句的用法\n\n区分以下两段函数:\n\n```js\nlet num = 0\nfor (let i = 0; i < 10; i++) {\n  for (let j = 0; j < 10; j++) {\n    if (i === 5 && j === 5) {\n      break\n    }\n    num++\n  }\n}\nconsole.log(num) // 95\n```\n\n使用 label 语句:\n\n```js\nlet num = 0\noutPoint:\nfor (let i = 0; i < 10; i++) {\n  for (let j = 0; j < 10; j++) {\n    if (i === 5 && j === 5) {\n      break outPoint\n    }\n    num++\n  }\n}\nconsole.log(num) // 55\n```\n\n### 函数声明和函数表达式\n\n* 以 `function` 开头的是函数声明, 不是以 `function` 开头的则是函数表达式\n* 函数声明具有函数声明提升的概念(function decleration hoisting)\n\n```js\n// 函数声明\nfunction test() {}\n\n// 函数表达式\nconst test = function() {}\n\n// 函数表达式\n(function(){})()\n```\n\n函数声明提升\n\n```js\nvar a = function() {\n  test()\n  function test() {\n    console.log('函数声明提升')\n  }\n}\n\na()\n```\n\n### 属性类型\n\n大体针对 `Object.defineProperty()`、`Object.defineProperties` 这两个 api 来讲的。使用这两个 api 创建的对象里的数据类型和访问器类型默认为 false(Configuble、Enummerable、Writable) 以及 undefined(Value、Set、Get)。\n\n> 注意: 在对象上直接定义的属性, Configurable、Enumerable、Writable 默认为 true\n\n#### 数据类型\n\n* Configurable: 是否能 delete\n* Enumerable\n* Writable\n* Value\n\n#### 访问器类型\n\n* Configurable\n* Enumerable\n* Writable\n* Get\n* Set\n\n### 创建对象的方式\n\n这部分知识点和继承相通, 可联系起来；\n\n#### 工厂模式\n\n```js\nfunction createPeople(name, age) {\n  const obj = new Object()\n  obj.name = name\n  obj.age = age\n  return obj\n}\n\ncreatePeople('Jack', 10)\n```\n\n缺点: 不知道创造的对象属于什么类\n\n#### 构造函数模式\n\n```js\nfunction People(name, age) {\n  this.name = name\n  this.age = age\n  this.sayHi = function() { console.log('hi') }\n}\n\nconst people1 = new People('Jack', 10)\nconst people2 = new People('Lucy', 8)\n\npeople1.sayHi === people2.sayHi // false\n```\n\n优点: 能将自定义参数传入构造函数\n缺点: 没有解决公共方法的复用性(是缺点也是优点, 后面有用到这个特性)\n\n#### 原型链模式\n\n```js\nfunction People(name, age) {\n  this.name = name\n  this.age = age\n}\n\nPeople.prototype.sayHi = function() { console.log('hi') }\nPeople.prototype.habbit = ['reading']\n\nconst people1 = new People('Jack', 10)\nconst people2 = new People('Lucy', 8)\n```\n\n> 原型模式实际上必须结合构造函数一起使用, 但在这里为了说明原型模式的缺点, 单独列了出来。\n\n```js\n// 结果\npeople1.sayHi === people2.sayHi // true\n\npeople1.habbit.push('drawing')\npeople2.habbit // ['reading', drawing]\n```\n\n优点: 解决公共方法的复用性(sayHi)；\n缺点: 也正是复用性, 所以在一个实例上修改 prototype 上的属性会对其它实例也产生相同影响(habbit)；\n\n#### 构造函数模式 + 原型链模式\n\n这个模式也是目前被大家最为认可的一种方式, 对上述例子稍作修改:\n\n```js\nfunction People(name, age) {\n  this.name = name\n  this.age = age\n  this.habbit = ['reading']\n}\n\nPeople.prototype.sayHi = function() { console.log('hi') }\n\nconst people1 = new People('Jack', 10)\nconst people2 = new People('Lucy', 8)\n\n// 结果\npeople1.sayHi === people2.sayHi // true\n\npeople1.habbit.push('drawing')\npeople2.habbit // [\"reading\"]\n```\n\n现在能直观地看到, people1 和 people2 公用同一个 sayHi 方法, 但是其它的属性 name、age、habbit 都是各自独立拥有的。\n\n> 结论: 所谓的构造函数模式 + 原型链模式即公有方法使用原型链模式, 私有方法使用构造函数模式；从而发挥各自的优点。\n\n### 继承\n\n> [继承优化](https://github.com/MuYunyun/blog/blob/master/BasicSkill/readES6/继承.md)\n\n### const/let 出现的原因\n\n提到块级作用域可以联系到 'const/let 出现的原因' 或者 'var 的缺点'\n\n```js\n// 案例 1\nvar a = 1\nvar a\n\na // 1\n\n------------\n\n// 案例 2\nvar a = 1\nvar a = 2\n\na // 2\n```\n\n可以看到使用 var 并不会告知之前是否已经声明过该变量, 案例 1 直接无视了后续的声明, 案例 2 后续的声明覆盖了前面的声明, 这样子使用起来便有些混乱了。这也是 const/let 出现的原因, const 专注案例 1 的情形, let 则专注案例 2 的情形。\n\n```js\n// 案例 1\nconst a = 1\nconst a\n\n// Uncaught SyntaxError: Missing initializer in const declaration\n\n------------\n\n// 案例 2\nlet a = 1\nlet a = 2\n\na // 2\n```\n\n### 块级作用域\n\n关键字: 匿名函数\n\n```js\n(function() {\n  // 块级作用域\n})()\n```\n\n因为没有引用指向匿名函数, 所以执行完就可以垃圾回收, 不造成内存浪费。\n\n### 作用域安全的构造函数\n\n```js\nfunction Safe(value) {\n  if (this instanceof Safe) {\n    this.name = value\n  } else {\n    return new Safe(value)\n  }\n}\n```\n\n这种写法不管使用 `new Safe()` 还是 `Safe()` 能保证它们返回结果一致(作用域一致)。\n\n### 防篡改对象\n\n* `Object.preventExtensions(obj)`: obj 不能添加属性\n* `Object.seal(obj)`: obj 不能添加/删除属性\n* `Object.freeze(obj)`: obj 不能添加/删除/修改属性\n\n### 防抖和节流函数最简版\n\n防抖: 多次触发事件只执行一次(适用于断续的事件, 比如 `click`、`input`)\n\n```js\nfunction debounce(fn, time) {\n  let timeout\n  return () => {\n    if (timeout) {\n      clearTimeout(timeout)\n    }\n    timeout = setTimeout({\n      fn\n    }, time)\n  }\n}\n```\n\n> 建议: 面试的时候先写出如上形式, 如果有时间再考虑实现带 `immediate` 形式的防抖函数。\n\n节流: 在指定时间内多次触发事件只执行一次(适用于连续的事件, 比如 `scroll`)\n\n```js\nfunction throttle(fn, time) {\n  let preTime = 0\n  return () => {\n    const remainTime = time - (Date.now() - preTime)\n    if (remainTime <= 0) {\n      fn()\n      preTime = Date.now()\n    }\n  }\n}\n```"}}]);