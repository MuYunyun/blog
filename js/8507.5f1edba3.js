(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8507],{78507:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>s});var a=t(59713),o=t.n(a),r=t(6479),l=t.n(r),u=(t(67294),t(3905));function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function p(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var c={};function s(e){var n=e.components,t=l()(e,["components"]);return(0,u.kt)("wrapper",p(p(p({},c),t),{},{components:n,mdxType:"MDXLayout"}),(0,u.kt)("h3",null,"React Hooks 深入系列"),(0,u.kt)("p",null,"在 class 已经融入 React 生态的节点下, React 推出的 Hooks 具有如下优势:"),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},"更简洁的书写;"),(0,u.kt)("li",{parentName:"ul"},"相对类中的 ",(0,u.kt)("inlineCode",{parentName:"li"},"HOC")," 与 ",(0,u.kt)("inlineCode",{parentName:"li"},"render Props"),", Hooks 拥有更加自由地组合抽象的能力;")),(0,u.kt)("h3",null,"使用 Hooks 的注意项"),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("p",{parentName:"li"},"在 ",(0,u.kt)("inlineCode",{parentName:"p"},"hooks")," 中每一次 ",(0,u.kt)("inlineCode",{parentName:"p"},"render")," 都有自己的 ",(0,u.kt)("inlineCode",{parentName:"p"},"state")," 和 ",(0,u.kt)("inlineCode",{parentName:"p"},"props"),", 这与 ",(0,u.kt)("inlineCode",{parentName:"p"},"class")," 中存在差异, 见 ",(0,u.kt)("a",p({parentName:"p"},{href:"https://overreacted.io/a-complete-guide-to-useeffect/#each-render-has-its-own-everything"}),"Hooks 每次渲染都是闭包")),(0,u.kt)("ul",{parentName:"li"},(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"class")," 中可以用闭包模拟 ",(0,u.kt)("inlineCode",{parentName:"li"},"hooks")," 的表现, ",(0,u.kt)("a",p({parentName:"li"},{href:"https://codesandbox.io/s/w7vjo07055"}),"链接"),", ",(0,u.kt)("inlineCode",{parentName:"li"},"hooks")," 中可以使用 ",(0,u.kt)("inlineCode",{parentName:"li"},"ref")," 模拟 ",(0,u.kt)("inlineCode",{parentName:"li"},"class")," 的表现, ",(0,u.kt)("a",p({parentName:"li"},{href:"https://codesandbox.io/s/rm7z22qnlp"}),"链接"),";"))),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("p",{parentName:"li"},"写出 useEffect 的所用到的依赖"))),(0,u.kt)("p",null,"在以下 demo 中, ",(0,u.kt)("inlineCode",{parentName:"p"},"useEffect")," 的第二个参数传入 ",(0,u.kt)("inlineCode",{parentName:"p"},"[]"),", 希望的是 ",(0,u.kt)("inlineCode",{parentName:"p"},"useEffect")," 里的函数只执行一次(类似在 ",(0,u.kt)("inlineCode",{parentName:"p"},"componentDidMount")," 中执行一次, 但是注意这里仅仅是",(0,u.kt)("inlineCode",{parentName:"p"},"类似"),", 详细原因见上一条注意项), 页面上每隔 1s 递增 1。"),(0,u.kt)("pre",null,(0,u.kt)("code",p({parentName:"pre"},{className:"language-js"}),"function Demo() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n    return () => {\n      clearInterval(id);\n    };\n  }, []);\n\n  return count;\n}\n")),(0,u.kt)("p",null,"但这样达到我们预期的效果了么? ",(0,u.kt)("a",p({parentName:"p"},{href:"https://codesandbox.io/s/n3o2m1wpj4"}),"demo"),", 可以看到界面上只增加到 1 就停止了。原因就是传入的第二个参数 ",(0,u.kt)("inlineCode",{parentName:"p"},"[]")," 搞的鬼, ",(0,u.kt)("inlineCode",{parentName:"p"},"[]")," 表示没有外界状态对 ",(0,u.kt)("inlineCode",{parentName:"p"},"effect")," 产生干扰。流程大致如下:"),(0,u.kt)("ol",null,(0,u.kt)("li",{parentName:"ol"},"第一次调用 ",(0,u.kt)("inlineCode",{parentName:"li"},"useEffect")," 传入的 ",(0,u.kt)("inlineCode",{parentName:"li"},"count")," 为 0, 于是 ",(0,u.kt)("inlineCode",{parentName:"li"},"setCount(0 + 1)"),";"),(0,u.kt)("li",{parentName:"ol"},"受 ",(0,u.kt)("inlineCode",{parentName:"li"},"useEffect")," 第二个参数 ",(0,u.kt)("inlineCode",{parentName:"li"},"[]")," 的影响，",(0,u.kt)("inlineCode",{parentName:"li"},"count")," 仍然为 0, 所以相当于还是 ",(0,u.kt)("inlineCode",{parentName:"li"},"setCount(0 + 1)"),";")),(0,u.kt)("p",null,"那如何修正上述问题呢? 方法有两个(方法一为主, 方法二为辅):"),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},"方法一: 将 ",(0,u.kt)("inlineCode",{parentName:"li"},"[]")," 改为 ",(0,u.kt)("inlineCode",{parentName:"li"},"[count]")),(0,u.kt)("li",{parentName:"ul"},"方法二: 将 ",(0,u.kt)("inlineCode",{parentName:"li"},"setCount(count + 1)")," 改为 ",(0,u.kt)("inlineCode",{parentName:"li"},"setCount(count => count + 1)"),"。这种方法的思想是修正状态的值而不依赖外面传进的状态。")),(0,u.kt)("p",null,"不过遇到 ",(0,u.kt)("inlineCode",{parentName:"p"},"setCount(count => count + 1)")," 的情况就可以考虑使用 ",(0,u.kt)("inlineCode",{parentName:"p"},"useReducer")," 了。"),(0,u.kt)("h4",null,"何时使用 useReducer"),(0,u.kt)("p",null,"使用 ",(0,u.kt)("inlineCode",{parentName:"p"},"useState")," 的地方都能用 ",(0,u.kt)("inlineCode",{parentName:"p"},"useReducer")," 进行替代。相较 ",(0,u.kt)("inlineCode",{parentName:"p"},"useState"),", ",(0,u.kt)("inlineCode",{parentName:"p"},"useReducer")," 有如下优势:"),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"useReducer")," 将 ",(0,u.kt)("inlineCode",{parentName:"li"},"how"),"(reducer) 和 ",(0,u.kt)("inlineCode",{parentName:"li"},"what"),"(dispatch(action)) 进行抽离; 使用 ",(0,u.kt)("inlineCode",{parentName:"li"},"reducer")," 逻辑状态进行集中化维护;"),(0,u.kt)("li",{parentName:"ul"},"相比 useState, useReducer 没有",(0,u.kt)("a",p({parentName:"li"},{href:"https://overreacted.io/a-complete-guide-to-useeffect/#each-render-has-its-own-everything"}),"闭包问题"),";"),(0,u.kt)("li",{parentName:"ul"},"当状态的一个 state 依赖状态中的另一个 state 时, 这种情况最好使用 ",(0,u.kt)("inlineCode",{parentName:"li"},"useReducer"),"; 可以参考 ",(0,u.kt)("a",p({parentName:"li"},{href:"https://overreacted.io/a-complete-guide-to-useeffect/#decoupling-updates-from-actions"}),"decoupling-updates-from-actions")," 中 Dan 列举的 demo。")),(0,u.kt)("h4",null,"处理 useEffect 中的公用函数"),(0,u.kt)("pre",null,(0,u.kt)("code",p({parentName:"pre"},{className:"language-js"}),"function Demo() {\n  const [count, setCount] = useState(0);\n\n  function getFetchUrl(query) {\n    return `http://demo${query}`\n  }\n\n  useEffect(() => {\n    const url = getFetchUrl('react')\n  }, [getFetchUrl]);\n\n  useEffect(() => {\n    const url = getFetchUrl('redux')\n  }, [getFetchUrl]);\n\n  return count;\n}\n")),(0,u.kt)("p",null,"此时 ",(0,u.kt)("inlineCode",{parentName:"p"},"useEffect")," 中传入的第二个参数 ",(0,u.kt)("inlineCode",{parentName:"p"},"getFetchUrl")," 相当于每次都是新的, 所以每次都会请求数据, 那除了 ",(0,u.kt)("inlineCode",{parentName:"p"},"[getFetchUrl]")," 将改为 ",(0,u.kt)("inlineCode",{parentName:"p"},"[]")," 这种不推荐的写法外，有两种解决方法:"),(0,u.kt)("p",null,(0,u.kt)("em",{parentName:"p"},". 方法一: 提升 ",(0,u.kt)("inlineCode",{parentName:"em"},"getFetchUrl")," 的作用域;\n"),". 方法二: 使用 ",(0,u.kt)("inlineCode",{parentName:"p"},"useCallback")," 或者 ",(0,u.kt)("inlineCode",{parentName:"p"},"useMemo")," 来包裹 getFetchUrl;"),(0,u.kt)("blockquote",null,(0,u.kt)("p",{parentName:"blockquote"},(0,u.kt)("inlineCode",{parentName:"p"},"React.memo")," 修饰一个函数组件, ",(0,u.kt)("inlineCode",{parentName:"p"},"useMemo")," 修饰一个函数。它们本质都是运用缓存。")),(0,u.kt)("h3",null,"React Hooks 内部是怎么工作的"),(0,u.kt)("p",null,"为了理解 React Hooks 内部实现原理, 对 ",(0,u.kt)("inlineCode",{parentName:"p"},"useState"),"、",(0,u.kt)("inlineCode",{parentName:"p"},"useEffect")," 进行了简单的实现。"),(0,u.kt)("h4",null,"useState 的简单实现"),(0,u.kt)("p",null,"使用闭包来实现 ",(0,u.kt)("inlineCode",{parentName:"p"},"useState")," 的简单逻辑:"),(0,u.kt)("pre",null,(0,u.kt)("code",p({parentName:"pre"},{className:"language-js"}),"// 这里使用闭包\nconst React = (function() {\n  let _val\n\n  return {\n    useState(initialValue) {\n      _val = _val || initialValue\n\n      function setVal(value) {\n        _val = value\n      }\n\n      return [_val, setVal]\n    }\n  }\n})()\n")),(0,u.kt)("p",null,"测试如下:"),(0,u.kt)("pre",null,(0,u.kt)("code",p({parentName:"pre"},{className:"language-js"}),"function Counter() {\n  const [count, setCount] = React.useState(0)\n\n  return {\n    render: () => console.log(count),\n    click: () => setCount(count + 1)\n  }\n}\n\nCounter().render() // 0\nCounter().click()  // 模拟点击\nCounter().render() // 1\n")),(0,u.kt)("h4",null,"useEffect 的简单实现"),(0,u.kt)("pre",null,(0,u.kt)("code",p({parentName:"pre"},{className:"language-js"}),"var React = (function() {\n  let _val, _deps\n\n  return {\n    useState(initialValue) {\n      _val = _val || initialValue\n\n      function setVal(value) {\n        _val = value\n      }\n\n      return [_val, setVal]\n    },\n    useEffect(callback, deps) {\n      const ifUpdate = !deps\n\n      // 判断 Deps 中的依赖是否改变\n      const ifDepsChange = _deps ? !_deps.every((r, index) => r === deps[index]) : true\n\n      if (ifUpdate || ifDepsChange) {\n        callback()\n\n        _deps = deps || []\n      }\n    }\n  }\n})()\n")),(0,u.kt)("p",null,"测试代码如下:"),(0,u.kt)("pre",null,(0,u.kt)("code",p({parentName:"pre"},{className:"language-js"}),"var {useState, useEffect} = React\n\nfunction Counter() {\n  const [count, setCount] = useState(0)\n\n  useEffect(() => {\n    console.log('useEffect', count)\n  }, [count])\n\n  return {\n    render: () => console.log('render', count),\n    click: () => setCount(count + 1),\n    noop: () => setCount(count), // 保持不变, 观察 useEffect 是否被调用\n  }\n}\n\nCounter().render() // 'useEffect' 0, 'render', 0\nCounter().noop()\nCounter().render() // 'render', 0\nCounter().click()\nCounter().render() // 'useEffect' 1, 'render', 1\n")),(0,u.kt)("h4",null,"处理多次调用的情形"),(0,u.kt)("p",null,"为了在 ",(0,u.kt)("inlineCode",{parentName:"p"},"hooks")," 中能使用多次 ",(0,u.kt)("inlineCode",{parentName:"p"},"useState"),", ",(0,u.kt)("inlineCode",{parentName:"p"},"useEffect"),", 将各个 ",(0,u.kt)("inlineCode",{parentName:"p"},"useState"),", ",(0,u.kt)("inlineCode",{parentName:"p"},"useEffect")," 的调用存进一个数组中, 在上面基础上进行如下改造:"),(0,u.kt)("pre",null,(0,u.kt)("code",p({parentName:"pre"},{className:"language-js"}),"const React = (function() {\n  const hooks = []\n  let currentHook = 0\n\n  return {\n    render(Component) {\n      const component = Component()\n      component.render()\n      currentHook = 0 // 重置, 这里很关键, 将 hooks 的执行放到 hooks 队列中, 确保每次执行的顺序保持一致。\n      return component\n    },\n    useState(initialValue) {\n      hooks[currentHook] = hooks[currentHook] || initialValue\n\n      function setVal(value) {\n        hooks[currentHook] = value\n      }\n\n      return [hooks[currentHook++], setVal]\n    },\n    useEffect(callback, deps) {\n      const ifUpdate = !deps\n\n      // 判断 Deps 中的依赖是否改变\n      const ifDepsChange = hooks[currentHook] ? !hooks[currentHook].every((r, index) => r === deps[index]) : true\n\n      if (ifUpdate || ifDepsChange) {\n        callback()\n\n        hooks[currentHook++] = deps || []\n      }\n    }\n  }\n})()\n")),(0,u.kt)("p",null,"测试代码如下:"),(0,u.kt)("pre",null,(0,u.kt)("code",p({parentName:"pre"},{className:"language-js"}),"var {useState, useEffect} = React\n\nfunction Counter() {\n  const [count, setCount] = useState(0)\n  const [type, setType] = useState('hi')\n\n  useEffect(() => {\n    console.log('useEffect', count)\n    console.log('type', type)\n  }, [count, type])\n\n  return {\n    render: () => console.log('render', count),\n    click: () => setCount(count + 1),\n    noop: () => setCount(count), // 保持不变, 观察 useEffect 是否被调用\n  }\n}\n\n/* 如下 mock 执行了 useEffect、render; 这里使用 React.render 的原因是为了重置 currentHook 的值 */\nlet comp = React.render(Counter) // useEffect 0 type hi render 0\n\n/* 如下 mock 只执行了 render */\ncomp.noop()\ncomp = React.render(Counter) // render 0\n\n/* 如下 mock 重新执行了 useEffect、render */\ncomp.click()\nReact.render(Counter) // useEffect 1, render 1\n")),(0,u.kt)("h3",null,"相关资源"),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("a",p({parentName:"li"},{href:"https://github.com/rehooks/awesome-react-hooks"}),"awesome-react-hooks")),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("a",p({parentName:"li"},{href:"https://github.com/gragland/usehooks"}),"usehooks")),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("a",p({parentName:"li"},{href:"https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/"}),"deep-dive-how-do-react-hooks-really-work")),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("a",p({parentName:"li"},{href:"https://overreacted.io/a-complete-guide-to-useeffect/"}),"a-complete-guide-to-useeffect"),": 推荐 Dan 的这篇文章"),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("a",p({parentName:"li"},{href:"https://adamrackis.dev/state-and-use-reducer/"}),"Hooks, State, Closures, and useReducer"),": 作为 ",(0,u.kt)("a",p({parentName:"li"},{href:"https://overreacted.io/a-complete-guide-to-useeffect/#decoupling-updates-from-actions"}),"decoupling-updates-from-actions")," 的补充"),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("a",p({parentName:"li"},{href:"https://kentcdodds.com/blog/should-i-usestate-or-usereducer/"}),"Should I useState or useReducer"),":")))}s.isMDXComponent=!0}}]);