(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2605],{92605:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>i});var r=t(59713),a=t.n(r),l=t(6479),p=t.n(l),s=(t(67294),t(3905));function c(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?c(Object(t),!0).forEach((function(e){a()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var u={};function i(n){var e=n.components,t=p()(n,["components"]);return(0,s.kt)("wrapper",o(o(o({},u),t),{},{components:e,mdxType:"MDXLayout"}),(0,s.kt)("h3",null,"title"),(0,s.kt)("p",null,"给定一个字符串, 请将字符串里的字符按照出现的频率",(0,s.kt)("inlineCode",{parentName:"p"},"降序排列"),"。"),(0,s.kt)("p",null,"示例 1:"),(0,s.kt)("pre",null,(0,s.kt)("code",o({parentName:"pre"},{className:"language-js"}),'输入:\n"tree"\n\n输出:\n"eert"\n')),(0,s.kt)("p",null,"解释: 'e'出现两次，'r'和't'都只出现一次。\n因此'e'必须出现在'r'和't'之前。此外，\"eetr\"也是一个有效的答案。"),(0,s.kt)("p",null,"示例 2:"),(0,s.kt)("pre",null,(0,s.kt)("code",o({parentName:"pre"},{className:"language-js"}),'输入:\n"cccaaa"\n\n输出:\n"cccaaa"\n')),(0,s.kt)("p",null,"解释: 'c'和'a'都出现三次。此外，\"aaaccc\"也是有效的答案。\n注意\"cacaca\"是不正确的，因为相同的字母必须放在一起。"),(0,s.kt)("p",null,"示例 3:"),(0,s.kt)("pre",null,(0,s.kt)("code",o({parentName:"pre"},{className:"language-js"}),'输入:\n"Aabb"\n\n输出:\n"bbAa"\n')),(0,s.kt)("p",null,"解释: 此外，\"bbaA\"也是一个有效的答案，但\"Aabb\"是不正确的。\n注意'A'和'a'被认为是两种不同的字符。"),(0,s.kt)("h3",null,"题解"),(0,s.kt)("p",null,"思路: 根据题意, 本题用 Map 来存储字符出现的频率, 难点在如何处理 Map 中对象出现的频率? 以下解法使用 arr 将 map 里的值存储转化为 ",(0,s.kt)("inlineCode",{parentName:"p"},"[{ key, value }]")," 的形式, 最后使用 JS 的 sort 方法来完成题解。"),(0,s.kt)("pre",null,(0,s.kt)("code",o({parentName:"pre"},{className:"language-js"}),"/**\n * @param {string} s\n * @return {string}\n */\nvar frequencySort = function(s) {\n  const map = new Map()\n  for (let i = 0; i < s.length; i++) {\n    const getMap = map.get(s[i])\n    if (!getMap) {\n      map.set(s[i], 1)\n    } else {\n      map.set(s[i], getMap + 1)\n    }\n  }\n\n  const arr = []\n  for (let key of map.keys()) {\n    arr.push({\n      key,\n      value: map.get(key)\n    })\n  }\n\n  // todo 后续实现下以下排序\n  arr.sort((a, b) => b.value - a.value)\n\n  const result = arr.map(r => {\n    let str = ''\n    for (let i = 0; i < r.value; i++) {\n      str = str + r.key\n    }\n    return str\n  }).join('')\n\n  return result\n};\n")),(0,s.kt)("h3",null,"归类"),(0,s.kt)("p",null,"map"))}i.isMDXComponent=!0}}]);