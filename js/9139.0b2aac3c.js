(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9139],{99139:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>u});var r=t(59713),o=t.n(r),a=t(6479),p=t.n(a),c=(t(67294),t(3905));function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function l(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){o()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var s={};function u(n){var e=n.components,t=p()(n,["components"]);return(0,c.kt)("wrapper",l(l(l({},s),t),{},{components:e,mdxType:"MDXLayout"}),(0,c.kt)("h3",null,"发布订阅模式"),(0,c.kt)("p",null,"事件发布/订阅模式 (PubSub) 在异步编程中帮助我们完成更松的解耦, 甚至在 MVC、MVVC 的架构中以及设计模式中也少不了发布-订阅模式的参与。"),(0,c.kt)("p",null,"优点: 在异步编程中实现更深的解耦"),(0,c.kt)("p",null,"缺点: 如果过多的使用发布订阅模式, 会增加维护的难度"),(0,c.kt)("h3",null,"实现一个发布订阅模式"),(0,c.kt)("pre",null,(0,c.kt)("code",l({parentName:"pre"},{className:"language-js"}),"var Event = function() {\n  this.obj = {}\n}\n\nEvent.prototype.on = function(eventType, fn) {\n  if (!this.obj[eventType]) {\n    this.obj[eventType] = []\n  }\n  this.obj[eventType].push(fn)\n}\n\nEvent.prototype.emit = function() {\n  var eventType = Array.prototype.shift.call(arguments)\n  var arr = this.obj[eventType]\n  for (let i = 0; i < arr.length; i++) {\n    arr[i].apply(arr[i], arguments)\n  }\n}\n\nvar ev = new Event()\n\nev.on('click', function(a) { // 订阅函数\n  console.log(a) // 1\n})\n\nev.emit('click', 1)          // 发布函数\n")),(0,c.kt)("h3",null,"订阅函数逻辑一定要优先于发布函数吗"),(0,c.kt)("p",null,"考虑以下场景:"),(0,c.kt)("pre",null,(0,c.kt)("code",l({parentName:"pre"},{className:"language-js"}),"$.ajax('', () => {\n  // 异步订阅函数逻辑\n})\n\n// 在其他地方执行发布函数, 此时并不能保证执行发布函数的时候, 订阅函数已经执行\n")),(0,c.kt)("p",null,"我们需要实现这样的逻辑:"),(0,c.kt)("pre",null,(0,c.kt)("code",l({parentName:"pre"},{className:"language-js"}),"var ev = new Event()\nev.emit('click', 1)\n\nev.on('click', function(a) {\n  console.log(a) // 1\n})\n")),(0,c.kt)("p",null,"目标明确后, 来着手实现它:"),(0,c.kt)("pre",null,(0,c.kt)("code",l({parentName:"pre"},{className:"language-js"}),"var Event = function() {\n  this.obj = {}\n  this.cacheList = []\n}\n\nEvent.prototype.on = function(eventType, fn) {\n  if (!this.obj[eventType]) {\n    this.obj[eventType] = []\n  }\n  this.obj[eventType].push(fn)\n\n  for (let i = 0; i < this.cacheList.length; i++) {\n    this.cacheList[i]()\n  }\n}\n\nEvent.prototype.emit = function() {\n  const arg = arguments\n  const that = this\n  function cache() {\n    var eventType = Array.prototype.shift.call(arg)\n    var arr = that.obj[eventType]\n    for (let i = 0; i < arr.length; i++) {\n      arr[i].apply(arr[i], arg)\n    }\n  }\n  this.cacheList.push(cache)\n}\n")),(0,c.kt)("p",null,"以上代码实现思路就是把原本在 emit 里触发的函数存到 cacheList, 再转交到 on 中触发。从而实现了发布函数先于订阅函数执行。"))}u.isMDXComponent=!0}}]);