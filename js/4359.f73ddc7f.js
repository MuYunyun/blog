(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4359],{94359:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>c});var r=n(59713),a=n.n(r),l=n(6479),p=n.n(l),s=(n(67294),n(3905));function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a()(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var u={};function c(e){var t=e.components,n=p()(e,["components"]);return(0,s.kt)("wrapper",i(i(i({},u),n),{},{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h3",null,"205. Isomorphic Strings"),(0,s.kt)("p",null,"Given two strings s and t, determine if they are isomorphic."),(0,s.kt)("p",null,"Two strings are isomorphic if the characters in s can be replaced to get t."),(0,s.kt)("p",null,"All occurrences of a character must be replaced with another character while preserving the order of characters. ",(0,s.kt)("inlineCode",{parentName:"p"},"No two characters may map to the same character")," but ",(0,s.kt)("inlineCode",{parentName:"p"},"a character may map to itself"),"."),(0,s.kt)("p",null,"Example 1:"),(0,s.kt)("pre",null,(0,s.kt)("code",i({parentName:"pre"},{className:"language-js"}),'Input: s = "egg", t = "add"\nOutput: true\n')),(0,s.kt)("p",null,"Example 2:"),(0,s.kt)("pre",null,(0,s.kt)("code",i({parentName:"pre"},{className:"language-js"}),'Input: s = "foo", t = "bar"\nOutput: false\n')),(0,s.kt)("p",null,"Example 3:"),(0,s.kt)("pre",null,(0,s.kt)("code",i({parentName:"pre"},{className:"language-js"}),'Input: s = "paper", t = "title"\nOutput: true\n')),(0,s.kt)("p",null,"Note:\nYou may assume both s and t have the same length."),(0,s.kt)("h3",null,"题解"),(0,s.kt)("p",null,"方法一: 字典哈希"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"遍历字符串, 使用",(0,s.kt)("inlineCode",{parentName:"li"},"字典 map")," 构建 s 中字符串与 t 中字符串(以及 t 中字符串与 s 中字符串)的映射关系;",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"若发现存在",(0,s.kt)("inlineCode",{parentName:"li"},"一对多"),"的情况, 则 s 与 t 不是同构的;"))),(0,s.kt)("li",{parentName:"ul"},"遍历结束, 则 s 与 t 是同构的;")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"一对多: 比如 s 为 'aa', t 为 'ab', 此时 ’a' 字符就对应了 'a'、'b' 两个字符, 即为一对多。")),(0,s.kt)("pre",null,(0,s.kt)("code",i({parentName:"pre"},{className:"language-js"}),"/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isIsomorphic = function(s, t) {\n  const mapS = new Map()\n  const mapT = new Map()\n  for (let i = 0; i < s.length; i++) {\n    const getS = mapS.get(s[i])\n    const getT = mapT.get(t[i])\n    if ((getS && getS !== t[i]) || (getT && getT !== s[i])) {\n      return false\n    }\n    mapS.set(s[i], t[i])\n    mapT.set(t[i], s[i])\n  }\n\n  return true\n}\n")),(0,s.kt)("p",null,"方法二: 判断 s 与 t 字符串中字符出现的第一个位置。(针对本题的巧妙解法, 不过推荐优先掌握方法一)"),(0,s.kt)("pre",null,(0,s.kt)("code",i({parentName:"pre"},{className:"language-js"}),"/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isIsomorphic = function(s, t) {\n  for (let i = 0; i < s.length; i++) {\n    if (s.indexOf(s[i]) !== t.indexOf(t[i])) {\n      return false\n    }\n  }\n  return true\n};\n")),(0,s.kt)("h3",null,"相关题目"),(0,s.kt)("p",null,"202、242、290、349、350、451"))}c.isMDXComponent=!0}}]);