(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5890],{45890:n=>{n.exports="### 基本类型和引用类型\n\n| 类型种类 |  访问类型  | 存储类型 |\n| :------: | :--------: | :------: |\n| 基本类型 |  按值访问  |  栈内存  |\n| 引用类型 | 按引用访问 |  堆内存  |\n\n#### 函数参数是'按值传递'的\n\n此处的按值传递和上面提到的按值访问是两个不一样的概念, 此处指的是给函数传入参数后, 我们操作的是`复制参数后的值`。\n\n①.当传入参数为基本类型时:\n\n```js\nconst count = 0\n\nfunction add(num) {\n  num = ++num\n  return num\n}\n\nconst result = add(count)\n\nconsole.log(count)  // 0 可以看到传入参数仍然是 0\nconsole.log(result) // 1\n```\n\n当 count 作为参数传入函数 add 时, 在栈内存中就会复制一份 count 的值, 我们操作的其实是复制后的这个值。可用下图表示:\n\n![](http://with.muyunyun.cn/dae97b9a4ef1022ae56e9bf5b9c1c727.jpg-200)\n\n②.当传入参数为引用类型时:\n\n```js\nconst reference = { num: 0 }\n\nfunction add(obj) {\n  obj.num = 1\n  obj = new Object() // ① 此处函数参数的引用发生改变\n  obj.num = 2\n  return obj\n}\n\nconst result = add(reference)\n\nconsole.log(reference) // { num: 1 }\nconsole.log(result)    // { num: 2 }\n```\n\n类似的, reference 作为参数传入函数 add 时, 栈内存中会多出一个指向堆内存的值(类似 hash 值)。可用下图表示:\n\n![](http://with.muyunyun.cn/b12b36ce345d26881486de403b79cbee.jpg)\n\n当执行 `obj = new Object()` 实际上是更改了 hash2 的指向(hash1 的指向并没有发生变化), 所以更改函数参数的引用是不会影响到原参数的。"}}]);