(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6168],{46168:n=>{n.exports="### 题目\n\n给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。\n\n`不要使用额外的数组空间`，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n\n示例 1:\n\n给定 `nums = [1,1,1,2,2,3]`,\n\n函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。\n\n你`不需要考虑数组中超出新长度后面的元素`。\n\n示例 2:\n\n给定 `nums = [0,0,1,1,1,1,2,3,3]`,\n\n函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。\n\n你不需要考虑数组中超出新长度后面的元素。\n\n说明:\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n```js\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n### 解题\n\n![](http://with.muyunyun.cn/e1ebb0d0612908377d6aca476611f03d.jpg)\n\n```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n  if (nums.length <= 2) return nums.length\n  let cur = 1 // 新数组的下标位数\n  for (let i = 2; i < nums.length; i++) {\n    // 对题目中每个元素最多出现两次的条件作限制\n    if (nums[i] !== nums[cur - 1]) {\n      nums[cur + 1] = nums[i]\n      cur++\n    }\n  }\n  return cur + 1\n}\n```\n\n### 同类题目\n\n关键词: 双指针。\n\n26、27、283。"}}]);