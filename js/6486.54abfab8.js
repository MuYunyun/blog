(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6486],{46486:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>k});var a=t(59713),r=t.n(a),l=t(6479),p=t.n(l),i=(t(67294),t(3905));function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function c(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){r()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var m={};function k(n){var e=n.components,t=p()(n,["components"]);return(0,i.kt)("wrapper",c(c(c({},m),t),{},{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h3",null,"什么是动态规划"),(0,i.kt)("p",null,"动态规划",(0,i.kt)("inlineCode",{parentName:"p"},"将一个大问题拆分成若干个子问题"),", 同时保存子问题的答案, 使得每个子问题只求解一次, 最终获得原问题的答案。其本质也是",(0,i.kt)("inlineCode",{parentName:"p"},"递归问题"),"。"),(0,i.kt)("h3",null,"动态规划是自下而上的递归"),(0,i.kt)("p",null,"通常自上而下的递归会产生",(0,i.kt)("inlineCode",{parentName:"p"},"重复的函数调用栈"),", 以",(0,i.kt)("a",c({parentName:"p"},{href:"./recursive.md"}),"递归")," 章节中",(0,i.kt)("inlineCode",{parentName:"p"},"斐波那契数列"),"为例, 其使用了",(0,i.kt)("inlineCode",{parentName:"p"},"自上而下"),"的思路来解决问题。"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"关于重复的函数调用栈解释: 比如求斐波那契数列 f(4) 的值时, 其转化为 ",(0,i.kt)("inlineCode",{parentName:"p"},"f(3) + f(2)"),", 进而转化为 ",(0,i.kt)("inlineCode",{parentName:"p"},"2f(2) + f(1)"),", 可以看到此时重复调用了 f(2)。")),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-js"}),"                            fn(n) = fn(n - 1) + fn(n - 2)\n                                     /                 \\\n        fn(n - 1) = fn(n - 2) + fn(n - 3)          fn(n - 2) = fn(n - 3) + fn(n - 4)\n                        /             \\                            /             \\\n                      ...             ...                         ...            ...\n")),(0,i.kt)("p",null,"动态规划则与其相反, 其使用了",(0,i.kt)("inlineCode",{parentName:"p"},"自下而上"),"的思路来解决问题。伪代码示意如下:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-js"}),"fn(n) = fn(1) + fn(2) + ... + f(n)\n")),(0,i.kt)("p",null,"具体实现:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-js"}),"var fibonacci = function(n) {\n  const arr = [1, 1]\n  for (let i = 2; i <= n; i++) {\n    arr[i] = arr[i - 1] + arr[i - 2]\n  }\n\n  return arr[n]\n}\n")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",c({parentName:"tr"},{align:"center"}),"递归方向"),(0,i.kt)("th",c({parentName:"tr"},{align:"center"}),"优点"),(0,i.kt)("th",c({parentName:"tr"},{align:"center"}),"缺点"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",c({parentName:"tr"},{align:"center"}),"自上而下"),(0,i.kt)("td",c({parentName:"tr"},{align:"center"}),"思路容易理顺"),(0,i.kt)("td",c({parentName:"tr"},{align:"center"}),"会出现函数栈重复的调用")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",c({parentName:"tr"},{align:"center"}),"自下而上(动态规划)"),(0,i.kt)("td",c({parentName:"tr"},{align:"center"}),"思路不易理顺"),(0,i.kt)("td",c({parentName:"tr"},{align:"center"}),"不会出现函数栈重复的调用")))),(0,i.kt)("h3",null,"动态规划解题思路"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"确定子问题"),(0,i.kt)("li",{parentName:"ol"},"确定终止条件")),(0,i.kt)("h3",null,"案例 —— 最小找零硬币数"),(0,i.kt)("p",null,"场景: 假如有 1, 5, 10, 20 美分的硬币"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{}),"[1, 5, 10, 20]\n\n4              // 找零数\n[1, 1, 1, 1]   // 需 4 个 1 美分的硬币\n\n5              // 找零数\n[5]            // 需 1 个 5 美分的硬币\n\n36             // 找零数\n[20, 10, 5, 1] // 需 20、10、5、1美分的硬币各一个\n")),(0,i.kt)("p",null,"下面用代码来实现:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-js"}),"var MinChange = function (changeType) {\n  this.changeType = changeType\n  this.cache = {}\n}\n\nMinChange.prototype.makeChange = function (amount) {\n  let min = []\n  if (!amount) {\n    return []\n  }\n  if (this.cache[amount]) {   // 读缓存\n    return this.cache[amount]\n  }\n\n  for (let i = 0; i < this.changeType.length; i++) {\n    const leftAmount = amount - this.changeType[i]\n    let newMin\n    if (leftAmount >= 0) {\n      newMin = this.makeChange(leftAmount) // 这一句是动态规划的提现\n    }\n    if (leftAmount >= 0\n      && (newMin.length < min.length - 1 || !min.length)) { // 如果存在更小的找零硬币数, 则执行后面语句\n      min = [this.changeType[i]].concat(newMin)\n    }\n  }\n\n  return this.cache[amount] = min\n}\n")),(0,i.kt)("p",null,"下面进行测试:"),(0,i.kt)("pre",null,(0,i.kt)("code",c({parentName:"pre"},{className:"language-js"}),"var minChange = new MinChange([1, 5, 10, 20])\n\nminChange.makeChange(2)  // [1, 1]\nminChange.makeChange(5)  // [5]\nminChange.makeChange(36) // [1, 5, 10, 20]\n")))}k.isMDXComponent=!0}}]);