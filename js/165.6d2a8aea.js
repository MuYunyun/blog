(self.webpackChunkblog=self.webpackChunkblog||[]).push([[165],{80165:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>b});var r=n(59713),o=n.n(r),p=n(6479),u=n.n(p),a=(n(67294),n(3905));function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o()(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var s={};function b(e){var t=e.components,n=u()(e,["components"]);return(0,a.kt)("wrapper",c(c(c({},s),n),{},{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h3",null,"疑问"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"在知乎上提了个 ",(0,a.kt)("a",c({parentName:"p"},{href:"https://www.zhihu.com/question/297323663"}),"使用 immutable.js 后有什么优势？"))),(0,a.kt)("h3",null,"自答"),(0,a.kt)("p",null,"假如要更新 4, immutable.js 只在绿色这条线做了特殊处理, 其它紫色的部分保持不变。相当于是优化了深拷贝的实现, 数据结构方面可以想象成链表, 因此在深拷贝的时候没有递归那么耗费性能, 同时也更利于数据的获取。"),(0,a.kt)("p",null,"因为最顶部的对象变化了, React 就提前知道需要重新渲染了(可以弥补 PureComponent 只作浅比较的不足)。不过 Updated tree 里的每一个节点还是会重新 diff 的, 不过在数据前后比较的这个层面上讲, immutable.js 的效率确实会高一些。"),(0,a.kt)("p",null,(0,a.kt)("img",c({parentName:"p"},{src:"http://with.muyunyun.cn/aeef08a94abebda30e9a5fa68e201fa8.jpg",alt:null}))),(0,a.kt)("p",null,"另外, 使用 immutable.js 的话需要将所有的 state,props 都转化成其定义的形式。成本还是有的。"))}b.isMDXComponent=!0}}]);