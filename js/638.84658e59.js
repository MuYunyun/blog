(self.webpackChunkblog=self.webpackChunkblog||[]).push([[638],{17583:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>d});var a=t(59713),r=t.n(a),l=t(6479),o=t.n(l),s=(t(67294),t(3905));function c(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function m(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?c(Object(t),!0).forEach((function(n){r()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var p={};function d(e){var n=e.components,t=o()(e,["components"]);return(0,s.kt)("wrapper",m(m(m({},p),t),{},{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h3",null,"JSX 和 虚拟 DOM"),(0,s.kt)("pre",null,(0,s.kt)("code",m({parentName:"pre"},{className:"language-js"}),'const element = (\n  <div className="title">\n    hello<span className="content">world!</span>\n  </div>\n)\n')),(0,s.kt)("p",null,"JSX 是一种语法糖, 经过 ",(0,s.kt)("a",m({parentName:"p"},{href:"https://babeljs.io/en/repl"}),"babel")," 转换结果如下, 可以发现实际上转化成 ",(0,s.kt)("inlineCode",{parentName:"p"},"React.createElement()")," 的形式:"),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"扩展: ",(0,s.kt)("a",m({parentName:"p"},{href:"https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E7%95%AA%E5%A4%96%E7%AF%87/babel%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.md"}),"babel 执行机制"))),(0,s.kt)("pre",null,(0,s.kt)("code",m({parentName:"pre"},{className:"language-js"}),'var element = React.createElement(\n  "div",\n  { className: "title" },\n  "hello",\n  React.createElement(\n    "span",\n    { className: "content" },\n    "world!"\n  )\n);\n')),(0,s.kt)("p",null,(0,s.kt)("a",m({parentName:"p"},{href:"https://preactjs.com/repl"}),"打印")," element, 结果如下:"),(0,s.kt)("pre",null,(0,s.kt)("code",m({parentName:"pre"},{className:"language-js"}),'{\n  attributes: {className: "title"}\n  children: ["hello", t] // t 和外层对象相同\n  key: undefined\n  nodeName: "div"\n}\n')),(0,s.kt)("p",null,"因此, 我们得出结论: JSX 语法糖经过 Babel 编译后转换成一种对象, 该对象即所谓的",(0,s.kt)("inlineCode",{parentName:"p"},"虚拟 DOM"),", 使用虚拟 DOM 能让页面进行更为高效的渲染。"),(0,s.kt)("p",null,"我们按照这种思路进行函数的构造:"),(0,s.kt)("pre",null,(0,s.kt)("code",m({parentName:"pre"},{className:"language-js"}),'const React = {\n  createElement\n}\n\nfunction createElement(tag, attr, ...child) {\n  return {\n    attributes: attr,\n    children: child,\n    key: undefined,\n    nodeName: tag,\n  }\n}\n\n// 测试\nconst element = (\n  <div className="title">\n    hello<span className="content">world!</span>\n  </div>\n)\n\nconsole.log(element) // 打印结果符合预期\n// {\n//   attributes: {className: "title"}\n//   children: ["hello", t] // t 和外层对象相同\n//   key: undefined\n//   nodeName: "div"\n// }\n')),(0,s.kt)("h3",null,"虚拟 DOM 转化为真实 DOM"),(0,s.kt)("p",null,"上个小节介绍了 JSX 转化为虚拟 DOM 的过程, 这个小节接着来实现将虚拟 DOM 转化为真实 DOM (页面上渲染的是真实 DOM)。"),(0,s.kt)("p",null,"我们知道在 React 中, 将虚拟 DOM 转化为真实 DOM 是使用 ",(0,s.kt)("inlineCode",{parentName:"p"},"ReactDOM.render")," 实现的, 使用如下:"),(0,s.kt)("pre",null,(0,s.kt)("code",m({parentName:"pre"},{className:"language-js"}),"import ReactDOM from 'react-dom'\n\nReactDOM.render(\n  element, // 上文的 element, 即虚拟 dom\n  document.getElementById('root')\n)\n")),(0,s.kt)("p",null,"接着来实现 ",(0,s.kt)("inlineCode",{parentName:"p"},"ReactDOM.render")," 的逻辑:"),(0,s.kt)("pre",null,(0,s.kt)("code",m({parentName:"pre"},{className:"language-js"}),"const ReactDOM = {\n  render\n}\n\n/**\n * 将虚拟 DOM 转化为真实 DOM\n * @param {*} vdom      虚拟 DOM\n * @param {*} container 需要插入的位置\n */\nfunction render(vdom, container) {\n  if (_.isString(vdom) || _.isNumber(vdom)) {\n    container.innerText = container.innerText + vdom // fix <div>I'm {this.props.name}</div>\n    return\n  }\n  const dom = document.createElement(vdom.nodeName)\n  for (let attr in vdom.attributes) {\n    setAttribute(dom, attr, vdom.attributes[attr])\n  }\n  vdom.children.forEach(vdomChild => render(vdomChild, dom))\n  container.appendChild(dom)\n}\n\n/**\n * 给节点设置属性\n * @param {*} dom   操作元素\n * @param {*} attr  操作元素属性\n * @param {*} value 操作元素值\n */\nfunction setAttribute(dom, attr, value) {\n  if (attr === 'className') {\n    attr = 'class'\n  }\n  if (attr.match(/on\\w+/)) {   // 处理事件的属性:\n    const eventName = attr.toLowerCase().substr(2)\n    dom.addEventListener(eventName, value)\n  } else if (attr === 'style') { // 处理样式的属性:\n    let styleStr = ''\n    let standardCss\n    for (let klass in value) {\n      standardCss = humpToStandard(klass) // 处理驼峰样式为标准样式\n      value[klass] = _.isNumber(+value[klass]) ? value[klass] + 'px' : value[klass] // style={{ className: '20' || '20px' }}>\n      styleStr += `${standardCss}: ${value[klass]};`\n    }\n    dom.setAttribute(attr, styleStr)\n  } else {                       // 其它属性\n    dom.setAttribute(attr, value)\n  }\n}\n")),(0,s.kt)("p",null,"至此, 我们成功将虚拟 DOM 复原为真实 DOM, 展示如下:"),(0,s.kt)("p",null,(0,s.kt)("img",m({parentName:"p"},{src:"http://with.muyunyun.cn/a898514bd3d08df4366e5ceb7843cddf.jpg-400",alt:null}))),(0,s.kt)("p",null,"另外配合热更新, 在热更新的时候清空之前的 dom 元素, 改动如下:"),(0,s.kt)("pre",null,(0,s.kt)("code",m({parentName:"pre"},{className:"language-js"}),"const ReactDOM = {\n  render(vdom, container) {\n    container.innerHTML = null\n    render(vdom, container)\n  }\n}\n")),(0,s.kt)("h3",null,"小结"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"JSX")," 经过 babel 编译为 React.createElement() 的形式, 其返回结果就是 ",(0,s.kt)("inlineCode",{parentName:"p"},"Virtual DOM"),", 最后通过 ReactDOM.render() 将 Virtual DOM 转化为真实的 DOM 展现在界面上。流程图如下:"),(0,s.kt)("p",null,(0,s.kt)("img",m({parentName:"p"},{src:"http://with.muyunyun.cn/5e451855ccc9017708b57164f9e221c6.jpg-400",alt:null}))),(0,s.kt)("h3",null,"思考题"),(0,s.kt)("p",null,"如下是一个 react/preact 的常用组件的写法, 那么为什么要 import 一个 React 或者 h 呢？"),(0,s.kt)("pre",null,(0,s.kt)("code",m({parentName:"pre"},{className:"language-jsx"}),"import React, { Component } from 'react' // react\n// import { h, Component } from 'preact' // preact\n\nclass A extends Component {\n  render() {\n    return <div>I'm componentA</div>\n  }\n}\n\nrender(<A />, document.body) // 组件的挂载\n")))}d.isMDXComponent=!0}}]);