(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8633],{58633:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>f});var r=t(59713),o=t.n(r),a=t(6479),l=t.n(a),c=(t(67294),t(3905));function s(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function u(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?s(Object(t),!0).forEach((function(e){o()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var p={};function f(n){var e=n.components,t=l()(n,["components"]);return(0,c.kt)("wrapper",u(u(u({},p),t),{},{components:e,mdxType:"MDXLayout"}),(0,c.kt)("h3",null,"装饰者模式"),(0,c.kt)("p",null,"装饰器模式: 动态地给函数赋能。"),(0,c.kt)("h3",null,"JavaScript 的装饰者模式"),(0,c.kt)("p",null,"生活中的例子: 天气冷了, 就添加衣服来保暖；天气热了, 就将外套脱下；这个例子很形象地含盖了装饰器的神韵, 随着天气的冷暖变化, 衣服可以动态的穿上脱下。"),(0,c.kt)("pre",null,(0,c.kt)("code",u({parentName:"pre"},{className:"language-js"}),"let wear = function() {\n  console.log('穿上第一件衣服')\n}\n\nconst _wear1 = wear\n\nwear = function() {\n  _wear1()\n  console.log('穿上第二件衣服')\n}\n\nconst _wear2 = wear\n\nwear = function() {\n  _wear2()\n  console.log('穿上第三件衣服')\n}\n\nwear()\n\n// 穿上第一件衣服\n// 穿上第二件衣服\n// 穿上第三件衣服\n")),(0,c.kt)("p",null,"这种方式有以下缺点: 1: 临时变量会变得越来越多；2: this 指向有时会出错"),(0,c.kt)("h3",null,"AOP 装饰函数"),(0,c.kt)("pre",null,(0,c.kt)("code",u({parentName:"pre"},{className:"language-js"}),"// 前置代码\nFunction.prototype.before = function(fn) {\n  const self = this\n  return function() {\n    fn.apply(new(self), arguments)  // https://github.com/MuYunyun/blog/pull/30#event-1817065820\n    return self.apply(new(self), arguments)\n  }\n}\n\n// 后置代码\nFunction.prototype.after = function(fn) {\n  const self = this\n  return function() {\n    self.apply(new(self), arguments)\n    return fn.apply(new(self), arguments)\n  }\n}\n")),(0,c.kt)("p",null,"用后置代码来实验下上面穿衣服的 demo,"),(0,c.kt)("pre",null,(0,c.kt)("code",u({parentName:"pre"},{className:"language-js"}),"const wear1 = function() {\n  console.log('穿上第一件衣服')\n}\n\nconst wear2 = function() {\n  console.log('穿上第二件衣服')\n}\n\nconst wear3 = function() {\n  console.log('穿上第三件衣服')\n}\n\nconst wear = wear1.after(wear2).after(wear3)\nwear()\n\n// 穿上第一件衣服\n// 穿上第二件衣服\n// 穿上第三件衣服\n")),(0,c.kt)("p",null,"但这样子有时会污染原生函数, 可以做点通变"),(0,c.kt)("pre",null,(0,c.kt)("code",u({parentName:"pre"},{className:"language-js"}),"const after = function(fn, afterFn) {\n  return function() {\n    fn.apply(this, arguments)\n    afterFn.apply(this, arguments)\n  }\n}\n\nconst wear = after(after(wear1, wear2), wear3)\nwear()\n")))}f.isMDXComponent=!0}}]);