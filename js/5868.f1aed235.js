(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5868],{75868:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>s});var r=n(59713),a=n.n(r),l=n(6479),c=n.n(l),o=(n(67294),n(3905));function p(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function u(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?p(Object(n),!0).forEach((function(t){a()(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):p(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var m={};function s(e){var t=e.components,n=c()(e,["components"]);return(0,o.kt)("wrapper",u(u(u({},m),n),{},{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h3",null,"基本类型和引用类型"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",u({parentName:"tr"},{align:"center"}),"类型种类"),(0,o.kt)("th",u({parentName:"tr"},{align:"center"}),"访问类型"),(0,o.kt)("th",u({parentName:"tr"},{align:"center"}),"存储类型"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",u({parentName:"tr"},{align:"center"}),"基本类型"),(0,o.kt)("td",u({parentName:"tr"},{align:"center"}),"按值访问"),(0,o.kt)("td",u({parentName:"tr"},{align:"center"}),"栈内存")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",u({parentName:"tr"},{align:"center"}),"引用类型"),(0,o.kt)("td",u({parentName:"tr"},{align:"center"}),"按引用访问"),(0,o.kt)("td",u({parentName:"tr"},{align:"center"}),"堆内存")))),(0,o.kt)("h4",null,"函数参数是'按值传递'的"),(0,o.kt)("p",null,"此处的按值传递和上面提到的按值访问是两个不一样的概念, 此处指的是给函数传入参数后, 我们操作的是",(0,o.kt)("inlineCode",{parentName:"p"},"复制参数后的值"),"。"),(0,o.kt)("p",null,"①.当传入参数为基本类型时:"),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"const count = 0\n\nfunction add(num) {\n  num = ++num\n  return num\n}\n\nconst result = add(count)\n\nconsole.log(count)  // 0 可以看到传入参数仍然是 0\nconsole.log(result) // 1\n")),(0,o.kt)("p",null,"当 count 作为参数传入函数 add 时, 在栈内存中就会复制一份 count 的值, 我们操作的其实是复制后的这个值。可用下图表示:"),(0,o.kt)("p",null,(0,o.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/dae97b9a4ef1022ae56e9bf5b9c1c727.jpg-200",alt:null}))),(0,o.kt)("p",null,"②.当传入参数为引用类型时:"),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"const reference = { num: 0 }\n\nfunction add(obj) {\n  obj.num = 1\n  obj = new Object() // ① 此处函数参数的引用发生改变\n  obj.num = 2\n  return obj\n}\n\nconst result = add(reference)\n\nconsole.log(reference) // { num: 1 }\nconsole.log(result)    // { num: 2 }\n")),(0,o.kt)("p",null,"类似的, reference 作为参数传入函数 add 时, 栈内存中会多出一个指向堆内存的值(类似 hash 值)。可用下图表示:"),(0,o.kt)("p",null,(0,o.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/b12b36ce345d26881486de403b79cbee.jpg",alt:null}))),(0,o.kt)("p",null,"当执行 ",(0,o.kt)("inlineCode",{parentName:"p"},"obj = new Object()")," 实际上是更改了 hash2 的指向(hash1 的指向并没有发生变化), 所以更改函数参数的引用是不会影响到原参数的。"))}s.isMDXComponent=!0}}]);