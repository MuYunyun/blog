(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9981],{79981:(e,t,a)=>{"use strict";a.r(t),a.d(t,{default:()=>s});var n=a(59713),r=a.n(n),l=a(6479),c=a.n(l),p=(a(67294),a(3905));function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r()(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}var u={};function s(e){var t=e.components,a=c()(e,["components"]);return(0,p.kt)("wrapper",o(o(o({},u),a),{},{components:t,mdxType:"MDXLayout"}),(0,p.kt)("h3",null,"解读 IoC 框架 InversifyJS"),(0,p.kt)("p",null,"InversityJS 是一个 IoC 框架。IoC(Inversion of Control) 包括依赖注入(Dependency Injection) 和依赖查询(Dependency Lookup)。"),(0,p.kt)("p",null,"相比于类继承的方式, 控制反转解耦了父类和子类的联系。"),(0,p.kt)("h3",null,"案例解析"),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-ts"}),"import 'reflect-metadata'\nimport { inject, injectable, Container } from 'inversify'\n\nconst container = new Container()\n\n@injectable()\nclass PopMusic {\n  getName() {\n    return '流行音乐'\n  }\n}\ncontainer.bind('request1').to(PopMusic)\n\n@injectable()\nclass ClassicalMusic {\n  getName() {\n    return '古典音乐'\n  }\n}\ncontainer.bind('request2').to(ClassicalMusic)\n\n@injectable()\nclass Music {\n  pm: any\n  cm: any\n  constructor(\n    @inject('request1') popMusic: any,\n    @inject('request2') classicalMusic: any) {\n    this.pm = popMusic\n    this.cm = classicalMusic\n  }\n\n  getName() {\n    const result = this.pm.getName() + this.cm.getName()\n    return result\n  }\n}\ncontainer.bind('Plan').to(Music)\n\nconst music: any = container.get('Plan')\nconsole.log(music.getName()) // 流行音乐古典音乐\n")),(0,p.kt)("p",null,"上述案例可以抽象为下图:"),(0,p.kt)("p",null,(0,p.kt)("img",o({parentName:"p"},{src:"http://with.muyunyun.cn/8a9ccba28d00ea0c752c3601d716ebcd.jpg-400",alt:"explain"}))),(0,p.kt)("blockquote",null,(0,p.kt)("p",{parentName:"blockquote"},"虚线表示可以注入, 但在代码中没有表现出来。")),(0,p.kt)("p",null,"代码流程可概括如下:"),(0,p.kt)("p",null,"1.将所有相关类(这里指 Music、popMusic、classicMusic) 通过 ",(0,p.kt)("inlineCode",{parentName:"p"},"@injectable")," 声明进 ",(0,p.kt)("inlineCode",{parentName:"p"},"container")," 容器;"),(0,p.kt)("p",null,"2.通过 ",(0,p.kt)("inlineCode",{parentName:"p"},"container.get()")," 获取 ",(0,p.kt)("inlineCode",{parentName:"p"},"container.bind().to(target)")," 中的目标对象(这里指 Music);"),(0,p.kt)("p",null,"3.如果目标对象中的 constructor() 里有 ",(0,p.kt)("inlineCode",{parentName:"p"},"@inject()"),", 则将相应的实例(这里指 PopMusic 与 classicalMusic 的实例)当作构造函数的参数'注入';"),(0,p.kt)("h3",null,"inject/injectable 相关源码"),(0,p.kt)("p",null,"inject 源码简化如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"// 这是一个属性装饰器\nfunction inject(serviceIdentifier) {\n  return function (target, targetKey) {\n    const metadataValue = { [targetKey]: [Metadata { key: 'inject', value: serviceIdentifier })] }\n    Reflect.defineMetadata('inversify:tagged_props', metadataValue, target.constructor);\n  }\n}\n")),(0,p.kt)("p",null,"injectable 源码简化如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"// 这是一个类装饰器\nfunction injectable() {\n  return function (target) {\n    const metadataValue = []\n    Reflect.defineMetadata('inversify:paramtypes', metadataValue, target)\n    return target\n  }\n}\n")),(0,p.kt)("p",null,"从简化版源码中可以看到 inject/injectable 最终是对 ",(0,p.kt)("inlineCode",{parentName:"p"},"Reflect.defineMetadata()")," 的一个使用。可以将 metadata 看成是一种相对高效的数据结构。"),(0,p.kt)("h4",null,"reflect-metadata"),(0,p.kt)("p",null,"InversityJS 深度结合了 ",(0,p.kt)("a",o({parentName:"p"},{href:"https://github.com/rbuckton/reflect-metadata"}),"reflect-metadata"),", reflect-metadata 在 Reflect 基础上对其 api 进行了扩展。"),(0,p.kt)("blockquote",null,(0,p.kt)("p",{parentName:"blockquote"},"metadata 本质上是一个 ",(0,p.kt)("inlineCode",{parentName:"p"},"WeakMap")," 对象。扩展: ",(0,p.kt)("a",o({parentName:"p"},{href:"https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/%E5%AD%97%E5%85%B8.md#map-%E5%92%8C-weakmap-%E7%9A%84%E5%8C%BA%E5%88%AB"}),"Map 和 WeakMap 的区别"))),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"Reflect.defineMetadata(metadataKey, metadataValue, target[, propertyKey])")," 简化版实现如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"const Metadata = new WeakMap()\n\nfunction defineMetadata(metadataKey, metadataValue, target, propertyKey) {\n  metadataMap = new Map()\n  metadataMap.set(metadataKey, metadataValue)\n  targetMetadata = new Map()\n  targetMetadata.set(propertyKey, metadataMap)\n  Metadata.set(target, targetMetadata)\n}\n")),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"Reflect.getOwnMetadata(metadataKey, target[, propertyKey])")," 简化版实现如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"function getOwnMetadata(metadataKey, target, propertyKey) {\n  var targetMetadata = Metadata.get(target)\n  var metadataMap = targetMetadata.get(propertyKey)\n  return metadataMap.get(metadataKey)\n}\n")),(0,p.kt)("p",null,"其数据结构可表示如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"WeakMap {\n  target: Map {\n    propertyKey: Map {\n      metadataKey: metadataValue\n    }\n  }\n}\n")),(0,p.kt)("h3",null,"相关链接"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("a",o({parentName:"li"},{href:"https://github.com/inversify/InversifyJS/blob/master/wiki/architecture.md"}),"Architecture overview"))))}s.isMDXComponent=!0}}]);