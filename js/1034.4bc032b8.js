(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1034],{41034:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>s});var r=t(59713),a=t.n(r),p=t(6479),o=t.n(p),c=(t(67294),t(3905));function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){a()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var u={};function s(e){var n=e.components,t=o()(e,["components"]);return(0,c.kt)("wrapper",i(i(i({},u),t),{},{components:n,mdxType:"MDXLayout"}),(0,c.kt)("h3",null,"React.Children.map"),(0,c.kt)("pre",null,(0,c.kt)("code",i({parentName:"pre"},{className:"language-js"}),"function Parent(props) {\n  // React.Children.map 会对第二个函数输出的值进行铺平操作\n  console.log(React.Children.map(props.children, r => [[r], r]));\n  return React.Children.map(props.children, r => [[r], r]);\n}\n\nfunction App() {\n  return (\n    <Parent>\n      <div>React.Children.map</div>\n    </Parent>\n  );\n}\n")),(0,c.kt)("blockquote",null,(0,c.kt)("p",{parentName:"blockquote"},(0,c.kt)("a",i({parentName:"p"},{href:"https://codesandbox.io/s/4r08jvpk9w"}),"React.Children.map"))),(0,c.kt)("h3",null,"React.Children.map 源码流程图"),(0,c.kt)("p",null,(0,c.kt)("inlineCode",{parentName:"p"},"React.Children.map")," 的源码中有两个递归, 一个是针对 ",(0,c.kt)("inlineCode",{parentName:"p"},"React.Children")," 的递归, 另外个是针对 React.Children.map 传入的第二个参数, 如果其返回的是数组则会再次递归, 目的是对数组中的数据进行铺平。"),(0,c.kt)("p",null,(0,c.kt)("img",i({parentName:"p"},{src:"https://github.com/MuYunyun/blog/blob/master/React/image/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/React.Children.map.png",alt:null}))))}s.isMDXComponent=!0}}]);