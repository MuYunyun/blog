(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2599],{22599:n=>{n.exports='### Carousel(走马灯) 组件\n\n事件是交给原生事件还是交由 React 的合成事件呢? 在最初的实现中参考 [react-swipe](https://github.com/voronianski/react-swipe/blob/gh-pages/src/index.js) 相当于是自己封装原生事件。\n\n但是在 React 的生态下，还是尽量用 `React` 封装的合成事件更为妥当。举几个原因:\n\n1. 兼容性方面的东西不用自己维护了;\n2. 测试用例用 `.simulate` 的时候能统一;\n\n> 原生事件和 React 合成事件类似鱼和熊掌不可兼得。\n\n### 前置知识\n\n* touchStart\n* touchMove\n* touchEnd\n* transitionend\n\n> e.touches[0].pageX, cdn 讲了其包含水平滚动的位置\n\n### 核心思路\n\n![](http://with.muyunyun.cn/8151b27a39eb385305185d0a67736011.jpg-400)\n\n* 比如当前位于第 3 张图片位于中央的时候, 第 1、2 张图片位于左侧的 `rest`, 第 4、5 张图片位于右侧的 `rest`;\n\n初始化阶段对任何窗口执行以下算法:\n\n1. `向左平移当前窗口数 * width`\n2. 给除了当前展示页加上/减去 `width`\n\n* 每次只操作当前的 `index`, 和其左右的元素 `index - 1`、`index + 1`;\n* 自动滑动用的是 css 中的 `transitionDuration` 属性以及 `transform` 属性来完成\n\n### 理解易错点\n\n```js\ndelta = {\n  x: touches.pageX - start.x,\n  y: touches.pageY - start.y\n};\n```\n\n* 手势从左往右滑动是向左滑动 `delta.x > 0`, 手势从右往左滑动是向右滑动 `delta.x < 0`\n\n### 坑点\n\n#### 不必要的 id 传入\n\n为了解决在一个页面中使用多处 `Swipe` 组件，首先提供了一个 id 参数来进行区分多个 Swipe 组件, 思路是在封装的组件内部通过 `document.getElementById(id)` 获取到这个 dom 节点，然后进行位置的初始化。\n\n```js\n<Swipe\n  id="demo"\n>\n</Swipe>\n```\n\n传入额外的 id 这对使用者是一个不必要的负担, 可以在组件内使用 `ref` 获取到对应的 `dom`。\n\n#### 如何改造成受控组件\n\n目前的实现为非受控组件, 若要将其改为受控组件, 改的地方比较多, 必须使用 `state` 来替换全局参数。另外位置的信息在 `React.cloneElement()` 中进行处理。\n\n#### 测试用例之坑\n\n`jest` 跑如下测试用例, 当跑到 `componentDidMount` 里的 `document.getElementById(\'demo\')` 并不拿到相应元素。\n\n```js\nmount(<Swipe>\n  <div key="1">PANE 1</div>\n  <div key="2">PANE 2</div>\n  <div key="3">PANE 3</div>\n  <div key="4">PANE 4</div>\n</Swipe>)\n```\n\n```jsx\ncomponentDidMount() {\n  document.getElementById(\'demo\')\n}\n\nrender() {\n  return (\n    <div id="demo">...</div>\n  )\n}\n```\n\n原因是因为 `mount` 渲染组件是挂载到 [jsdom](https://github.com/jsdom/jsdom) 上而非真实 `dom` 上, 当时的解决思路如下:\n\n```js\nmount(<Swipe>\n  <div key="1">PANE 1</div>\n  <div key="2">PANE 2</div>\n  <div key="3">PANE 3</div>\n  <div key="4">PANE 4</div>\n</Swipe>, { attatch: document.body })\n```\n\n经过上述去除步骤去掉 `document.getElementById` 使用 ref 后, `{ attatch: document.body }` 也便去掉了。\n\n### CSS 方案?\n\n* scroll-snap-type\n  * mandatory: the visual viewport of this scroll container will `rest on a snap point` if it isn\'t currently scrolled.\n  * proximity: The visual viewport of this scroll container may come to `rest on a snap point` if it isn\'t currently scrolled considering the user agent\'s scroll parameters.\n\n![](http://with.muyunyun.cn/56583153afaa5ae1edad7bea4b728234.jpg-400)\n\n* scroll-snap-align: start;\n* scroll-snap-stop(experiment)\n  * always: defining whether the scroll container is allowed to "pass over" possible snap positions(Used with scroll-snap-align can).\n\n阅读文档后, 该 api 浏览器兼容情况不是特别好(ios 要 11 以上), 此外, 比如循环轮播是无法实现的。\n'}}]);