(self.webpackChunkblog=self.webpackChunkblog||[]).push([[814],{60814:(t,e,n)=>{"use strict";n.r(e),n.d(e,{default:()=>m});var r=n(59713),u=n.n(r),l=n(6479),a=n.n(l),s=(n(67294),n(3905));function p(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?p(Object(n),!0).forEach((function(e){u()(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):p(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}var o={};function m(t){var e=t.components,n=a()(t,["components"]);return(0,s.kt)("wrapper",i(i(i({},o),n),{},{components:e,mdxType:"MDXLayout"}),(0,s.kt)("h3",null,"90.Subsets II"),(0,s.kt)("p",null,"Given a collection of integers that ",(0,s.kt)("inlineCode",{parentName:"p"},"might contain duplicates nums"),", return all possible subsets (the power set)."),(0,s.kt)("p",null,"Note: The solution set must not contain duplicate subsets."),(0,s.kt)("p",null,"Example:"),(0,s.kt)("p",null,"Input: ","[1,2,2]","\nOutput:\n[\n","[2]",",\n","[1]",",\n","[1,2,2]",",\n","[2,2]",",\n","[1,2]",",\n[]\n]"),(0,s.kt)("h3",null,"Analyze"),(0,s.kt)("p",null,"回溯法解",(0,s.kt)("inlineCode",{parentName:"p"},"组合问题"),"。"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"1"),(0,s.kt)("li",{parentName:"ul"},"1",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"2"))),(0,s.kt)("li",{parentName:"ul"},"1",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"2",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"2"))))),(0,s.kt)("li",{parentName:"ul"},"2"),(0,s.kt)("li",{parentName:"ul"},"2",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"2")))),(0,s.kt)("pre",null,(0,s.kt)("code",i({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsetsWithDup = function(nums) {\n  const result = []\n  const sortedNums = nums.sort((r1, r2) => r1 - r2)\n  iterator(sortedNums, 0, [], result)\n  return result\n};\n\nvar iterator = function(nums, start, temp, result) {\n  result.push([...temp])\n\n  for (let i = start; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1] && i !== start) { continue }\n    temp.push(nums[i])\n    iterator(nums, i + 1, temp, result)\n    temp.pop(nums[i])\n  }\n}\n")))}m.isMDXComponent=!0}}]);