(self.webpackChunkblog=self.webpackChunkblog||[]).push([[398],{70398:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>p});var a=t(59713),s=t.n(a),h=t(6479),l=t.n(h),r=(t(67294),t(3905));function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function u(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){s()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var o={};function p(e){var n=e.components,t=l()(e,["components"]);return(0,r.kt)("wrapper",u(u(u({},o),t),{},{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h3",null,"哈希表"),(0,r.kt)("p",null,"哈希表算是一种特殊的字典。它在实际的键值和存入的哈希值之间存在一层映射。如下例子:"),(0,r.kt)("p",null,(0,r.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/963b04e081590a419bfc97c30d915a01.jpg-300",alt:null}))),(0,r.kt)("p",null,"上图中通过哈希函数将键值转换成哈希值, 然后再将哈希值指向具体的值。接着我们来构造 HashTable 类, 代码如下:"),(0,r.kt)("pre",null,(0,r.kt)("code",u({parentName:"pre"},{className:"language-js"}),"function HashTable() {\n  this.items = {}\n}\n\n// 哈希算法\nfunction keyToHash(key) {\n  let hash = 0\n  for (let i = 0; i < key.length; i++) {\n    hash += key.charCodeAt(i)\n  }\n  hash = hash % 37 // 为了避免 hash 的值过大\n  return hash\n}\n\nHashTable.prototype.put = function(key, value) {\n  const hash = keyToHash(key)\n  this.items[hash] = value\n}\n\nHashTable.prototype.get = function(key) {\n  return this.items[keyToHash(key)]\n}\n\nHashTable.prototype.remove = function(key) {\n  delete(this.items[keyToHash(key)])\n}\n")),(0,r.kt)("p",null,"跑如下测试用例:"),(0,r.kt)("pre",null,(0,r.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var test = new HashTable()\ntest.put('ab', 'ab@gmail.com')\ntest.put('cd', 'cd@gmail.com')\ntest.put('ef', 'ef@gmail.com')\n\ntest.get('cd') // \"cd@gmail.com\"\ntest.remove('cd')\ntest.get('cd') // undefined\n")),(0,r.kt)("p",null,"但是这样子实现的哈希表有一个问题, 比如进行如下调用就会产生冲突:"),(0,r.kt)("pre",null,(0,r.kt)("code",u({parentName:"pre"},{className:"language-js"}),"test.put('ab', 'ab@gmail.com')\ntest.put('ba', 'ba@gmail.com') // ab 和 ba 的哈希值相同, 后者会把前者覆盖\n")),(0,r.kt)("p",null,"接着我们来尝试解决该问题"),(0,r.kt)("h4",null,"链表法"),(0,r.kt)("p",null,"顾名思义, 这个方法就是在每个哈希值上引人链表。如下图所示:"),(0,r.kt)("p",null,(0,r.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/bd07ad706f4d494a9df8fb63621a6036.jpg-200",alt:null}))),(0,r.kt)("p",null,"对之前 put、get、remove 方法做如下修改, 其中使用到的链表的代码参考之前的 ",(0,r.kt)("a",u({parentName:"p"},{href:"https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/%E9%93%BE%E8%A1%A8.md#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"}),"链表")),(0,r.kt)("pre",null,(0,r.kt)("code",u({parentName:"pre"},{className:"language-js"}),"function HashTable() {\n  this.items = {}\n}\n\nfunction keyToHash(key) {\n  let hash = 0\n  for (let i = 0; i < key.length; i++) {\n    hash += key.charCodeAt(i)\n  }\n  hash = hash % 37\n  return hash\n}\n\n// 存入链表的值\nfunction Node(key, value) {\n  this.key = key\n  this.value = value\n}\n\n// 添加接口\nHashTable.prototype.put = function(key, value) {\n  const hash = keyToHash(key)\n  if (!this.items[hash]) {\n    this.items[hash] = new LinkedList() // 这里将之前实现的链表拿来使用\n  }\n  let linkList = this.items[hash].getHead()\n  let ifAppend = true\n  while (linkList) {                        // 以下为 append 逻辑\n    if (linkList.element.key === key) {     // key 值重复逻辑\n      linkList.element = new Node(key, value)\n      ifAppend = false\n      break\n    }\n    linkList = linkList.next\n  }\n  if (ifAppend) {\n    this.items[hash].append(new Node(key, value))\n  }\n}\n\nHashTable.prototype.has = function (hash) {\n  if (this.items.hasOwnProperty(hash)) {\n    return true\n  }\n  return false\n}\n\n// 获取接口\nHashTable.prototype.get = function(key) {\n  const hash = keyToHash(key)\n  if (this.has(hash)) {\n    let current = this.items[hash].getHead()\n    while (current) {\n      if (current.element.key === key) {\n        return current.element.value\n      }\n      current = current.next\n    }\n  }\n  return undefined\n}\n\n// 移除接口\nHashTable.prototype.remove = function(key) {\n  const hash = keyToHash(key)\n  if (this.has(hash)) {\n    let current = this.items[hash].getHead()\n    while (current) {\n      if (current.element.key === key) {\n        this.items[hash].remove(current.element)\n        return true\n      }\n      current = current.next\n    }\n    return false\n  }\n  return false\n}\n")),(0,r.kt)("p",null,"接着来测试下完成的哈希表, 测试用例如下:"),(0,r.kt)("pre",null,(0,r.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var test = new HashTable()\ntest.put('ab', 'ab@gmail.com')\ntest.put('ba', 'ba~@gmail.com')\ntest.put('ba', 'ba@gmail.com') // 验证重复字段\ntest.put('cd', 'cd@gmail.com')\n\ntest.get('ab') // ab@gmail.com\ntest.get('ba') // ba@gmail.com\ntest.get('cd') // cd@gmail.com\n\ntest.remove('ba')\ntest.get('ba') // undefined\n")),(0,r.kt)("h4",null,"线性探查法"),(0,r.kt)("p",null,"思想: 如果当前所要存储的 hash 值已存在于存储空间, 则判断存储空间里是否已存储 hash + 1, 若无则存储 hash + 1, 若有则判断存储空间里是否已存储 hash + 2, 依次类推。参考图如下:"),(0,r.kt)("p",null,(0,r.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/9212ee6899520f888f774ca7a2dc0519.jpg-200",alt:null}))),(0,r.kt)("p",null,"接着进入代码实现环节, 同样是修改 put、get、remove 方法:"),(0,r.kt)("pre",null,(0,r.kt)("code",u({parentName:"pre"},{className:"language-js"}),"function HashTable() {\n  this.items = {}\n}\n\n// 哈希算法\nfunction keyToHash(key) {\n  let hash = 0\n  for (let i = 0; i < key.length; i++) {\n    hash += key.charCodeAt(i)\n  }\n  hash = hash % 37 // 为了避免 hash 的值过大\n  return hash\n}\n\n// 后面会用之锁定\nfunction Node(key, value) {\n  this.key = key\n  this.value = value\n}\n\nHashTable.prototype.put = function(key, value) {\n  let hash = keyToHash(key)\n  while (this.items[hash]) {             // 当 this.items[index] 不存在时终止\n    if (this.items[hash].key === key) {  // 对已存在的 key 值进行覆盖\n      break\n    }\n    hash++\n  }\n  this.items[hash] = new Node(key, value)\n}\n\nHashTable.prototype.has = function(hash) {\n  if (this.items.hasOwnProperty(hash)) {\n    return true\n  }\n  return false\n}\n\nHashTable.prototype.get = function(key) {\n  let hash = keyToHash(key)\n  if (this.items[hash]) {\n    while (this.items[hash].key !== key) { // 找到存储的 index\n      hash++\n    }\n    return this.items[hash].value\n  }\n  return undefined\n}\n\nHashTable.prototype.remove = function(key) {\n  let hash = keyToHash(key)\n  if (this.has(hash)) {\n    while (this.items[hash].key !== key) { // 找到存储的 index\n      hash++\n    }\n    this.items[hash] = undefined\n    return true\n  }\n  return false\n}\n")),(0,r.kt)("p",null,"接着跑如下测试用例:"),(0,r.kt)("pre",null,(0,r.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var test = new HashTable()\ntest.put('ab', 'ab@gmail.com')\ntest.put('ba', 'ba@gmail.com')\ntest.put('ab', 'ab@gmail.com')\n\ntest.get('ab') // 'ab@gmail.com'\n\ntest.remove('ab')\ntest.get('ab') // undefined\n")),(0,r.kt)("h4",null,"更好的哈希函数"),(0,r.kt)("p",null,"另外在本文实现的哈希函数中, 性能不是特别好（因为容易产生相同的哈希值）, 给出一段更好的散列函数的实现, 数学知识的原理暂时不深究了"),(0,r.kt)("pre",null,(0,r.kt)("code",u({parentName:"pre"},{className:"language-js"}),"// 哈希算法\nfunction keyToHash(key) {\n  let hash = 5381    // 取一个素数\n  for (let i = 0; i < key.length; i++) {\n    hash = hash * 33 + key.charCodeAt(i)\n  }\n  hash = hash % 1013 // 除以另外一个素数\n  return hash\n}\n")),(0,r.kt)("h4",null,"哈希表的应用"),(0,r.kt)("p",null,"笔者认为业务中, 哈希表的数据结构能应用需要加密处理的数据存储中。"))}p.isMDXComponent=!0}}]);