(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5678],{75678:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>c});var o=t(59713),r=t.n(o),a=t(6479),l=t.n(a),i=(t(67294),t(3905));function s(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,o)}return t}function p(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?s(Object(t),!0).forEach((function(e){r()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var d={};function c(n){var e=n.components,t=l()(n,["components"]);return(0,i.kt)("wrapper",p(p(p({},d),t),{},{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h3",null,"235. Lowest Common Ancestor of a Binary Search Tree"),(0,i.kt)("p",null,"Given a ",(0,i.kt)("inlineCode",{parentName:"p"},"binary search tree")," (BST), find the ",(0,i.kt)("inlineCode",{parentName:"p"},"lowest common ancestor")," (LCA) of two given nodes in the BST."),(0,i.kt)("p",null,"According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”"),(0,i.kt)("p",null,"Given binary search tree: root = ","[6,2,8,0,4,7,9,null,null,3,5]"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"       6\n     /   \\\n    2      8\n   / \\    / \\\n  0   4  7   9\n     / \\\n    3   5\n")),(0,i.kt)("p",null,"Example 1:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\nOutput: 6\n")),(0,i.kt)("p",null,"Explanation: The LCA of nodes 2 and 8 is 6."),(0,i.kt)("p",null,"Example 2:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\nOutput: 2\n``` \n\nExplanation: The LCA of nodes 2 and 4 is 2, since `a node can be a descendant of itself` according to the LCA definition.\n\nConstraints:\n\n* `All of the nodes' values will be unique`.\n* `p and q are different and both values will exist in the BST`.\n\n### Analyze\n\n1. if `p` node and `q` node are in `two` side of current iterator node `n`, the LCA is `n`;\n2. if `p` node and `q` node are in `one` side of current iterator node `n`, to loop the one step in the other side node;\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nvar lowestCommonAncestor = function(root, p, q) {\n  return lca(root, p, q)\n};\n\nvar lca = function(node, p, q) {\n  if (!node) return null\n  if ((p.val - node.val) * (q.val - node.val) <= 0) {\n    return node\n  } else if (p.val - node.val < 0) {\n    return lca(node.left, p, q)\n  } else {\n    return lca(node.right, p, q)\n  }\n}\n")))}c.isMDXComponent=!0}}]);