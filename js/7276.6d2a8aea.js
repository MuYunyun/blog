(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7276],{47276:(n,e,l)=>{"use strict";l.r(e),l.d(e,{default:()=>c});var a=l(59713),t=l.n(a),p=l(6479),r=l.n(p),u=(l(67294),l(3905));function m(n,e){var l=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),l.push.apply(l,a)}return l}function k(n){for(var e=1;e<arguments.length;e++){var l=null!=arguments[e]?arguments[e]:{};e%2?m(Object(l),!0).forEach((function(e){t()(n,e,l[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(l)):m(Object(l)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(l,e))}))}return n}var s={};function c(n){var e=n.components,l=r()(n,["components"]);return(0,u.kt)("wrapper",k(k(k({},s),l),{},{components:e,mdxType:"MDXLayout"}),(0,u.kt)("h2",null,"文件操作"),(0,u.kt)("h3",null,"head"),(0,u.kt)("p",null,"显示文件的头部内容，如果不指定参数默认显示 10 行"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 显示前 10 行内容\nhead README.md\n\n# 或者显示多个文件\nhead README.md package.json\n\n# -n 指定显示行数\nhead -n 100 README.md\n")),(0,u.kt)("h3",null,"tail"),(0,u.kt)("p",null,"显示文件的末尾部分"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 默认显示末尾10行\ntail README.md\n\n# -n 指定显示末尾20行\ntail -n 20 README.md\n")),(0,u.kt)("h3",null,"ls"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 显示当前目录列表\nls\n\n# 显示目录列表的详细信息\nls -l\n\n# 显示指定目录\nls ./src\n\n# 可读性地显示目录列表详细信息, h means human-readable\nls -lh\n\n# 列出所有文件包括隐藏文件\nls -a\n\n# -F 可以显示类型，用以区分是文件还是目录\nls -F # 后缀为 ”/“ 代表是目录，”*“ 为可执行文件，没有则为文件\n\n# -i 查看 inode 编号, 每一个文件或目录都有一个唯一的编号，这个数字由内核分配给文件系统中的每一个对象\nls -i\n\n# 过滤文件列表, * 代表 0 个或多个字符, ? 代表一个字符\nls READ*\n")),(0,u.kt)("h3",null,"pwd"),(0,u.kt)("p",null,"显示当前路径"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# pwd means pathname of the current working directory\npwd\n")),(0,u.kt)("h3",null,"wc"),(0,u.kt)("p",null,"统计文件的行数、字数、字节数, 常见用于",(0,u.kt)("inlineCode",{parentName:"p"},"统计代码行数")),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 统计行数\nwc -l README.md\n\n# 统计字数\nwc -w README.md\n\n# 统计字符数, 中文占两个字符, 英文占一个字符\nwc -m README.md\n")),(0,u.kt)("h3",null,"find"),(0,u.kt)("p",null,"指定某个目录下查找文件"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),'# 在当前目录递归搜索文件名为 README.md 文件\nfind . -name README.md\n\n# 通过通配符进行查找, 必须用引号括着, 这里查找所有后缀为 .md 文件\nfind . -name "*.md"\nfind . -iname "*.md"  # 忽略文件大小写\n\n# 排除文件，只要加 ! , 排除掉所有 .md 后缀的文件\nfind . ! -name "*.md"\n\n# 根据类型进行过滤搜索\n# f 普通文件 d 目录\nfind . -type f\n\n# 限定目录递归深度\nfind . -maxdepth 3  # 最大为3个目录\nfind . -mindepth 3  # 最小为3个目录\n\n# 查找文件大小大于 25k 文件\nfind . -size +25k\n\n# 查找 10 天前文件 -mtime 修改时间、 -ctime 创建时间、 -atime 访问时间\nfind . -mtime +10\n')),(0,u.kt)("h3",null,"mkdir"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 在当前目录下创建 temp 目录\nmkdir temp\n\n# 创建多层目录, p means parent\nmkdir -p temp/temp2/temp3\n\n# 基于权限创建, m means mode\nmkdir -m 777 temp\n")),(0,u.kt)("h3",null,"more"),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},"空格 - 查看下一屏内容"),(0,u.kt)("li",{parentName:"ul"},"B - 查看上一屏内容"),(0,u.kt)("li",{parentName:"ul"},"回车 - 查看下一行内容"),(0,u.kt)("li",{parentName:"ul"},"Q - 退出")),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"more README.md\n\n# 从第 10 行开始显示\nmore +10 README.md\n")),(0,u.kt)("h3",null,"paste"),(0,u.kt)("p",null,"合并 N 个文件的",(0,u.kt)("inlineCode",{parentName:"p"},"列"),"。"),(0,u.kt)("blockquote",null,(0,u.kt)("p",{parentName:"blockquote"},"并不是纵向合并, 而是横向合并。")),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 1.txt 和 2.txt 合并输出\npaste 1.txt 2.txt\n\n# 1.txt 2.txt 合并后保存为 3.txt\npaste 1.txt 2.txt > 3.txt\n")),(0,u.kt)("h3",null,"stat"),(0,u.kt)("p",null,"用于显示文件或目录的状态信息"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-js"}),'16777220 8702541224 -rw-r--r-- 1 mac staff 0 15857 "Nov  1 13:02:02 2020" "Nov  1 13:02:02 2020" "Nov  1 13:02:02 2020" "Oct 25 18:48:15 2020" 4096 32 0 README.md\n')),(0,u.kt)("h3",null,"grep"),(0,u.kt)("p",null,"强大的文本搜索工具, 被称为 Linux 命令三剑客。"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),'# 从 README.md 文件中搜索 linux 关键字\ngrep "linux" README.md\ngrep "linux" README.md README2.md # 多个文件搜索\n\n# 输出时高亮显示\ngrep "linux" README.md --color\n\n# -o 只输出匹配部分\ngrep -o "linux" README.md --color\n\n# -n 输出到匹配的行数\ngrep -n "linux" README.md\n\n# -c 输出到匹配次数\ngrep -c "linux" README.md\n\n# -r 递归目录文件搜索\ngrep -r "linux" ./src\n\n# 使用 glob 风格表达式搜索\negrep "[0-9]" # 等价于 grep -E "[0-9]" README.md\n')),(0,u.kt)("h3",null,"touch"),(0,u.kt)("p",null,"创建一个空文件, 如果文件存在只会修改文件的创建时间"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"touch README.md\n")),(0,u.kt)("h3",null,"cd"),(0,u.kt)("p",null,"进入指定目录"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 进入当前 src 目录\ncd src\n\n# 回到上一次目录\ncd -\n\n# 返回上一级目录\ncd ..\ncd ../../..   # 返回多级\n\n# 进入家目录\ncd ~\ncd # 或者不带任何参数\n\n# 将上一个命令的参数作为cd参数使用\ncd !$\n\n# 模糊匹配目录，有时目录名很长一个一个敲效率就很低\n# * 代表0个或多个字符， ? 代表一个字符\ncd READ*\n")),(0,u.kt)("h3",null,"rm"),(0,u.kt)("p",null,"删除指定目录或文件"),(0,u.kt)("blockquote",null,(0,u.kt)("p",{parentName:"blockquote"},"使用此命令需要非常小心, 一但删除无法恢复")),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 删除当前 1.txt 文件\nrm 1.txt\n\n# -i 删除前询问是否真的要删除，因为一旦删除无法恢复\nrm -i README.md\n\n# 这条命令比较常用, 强制删除目录或文件\n# -r 如果是目录递归删除, -f 强制删除 不发出任何警告\nrm -rf ./src\n")),(0,u.kt)("h3",null,"cp"),(0,u.kt)("p",null,"拷贝文件或目录"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 将当前 README.md 文件拷贝到上一层\ncp ./README.md ../README.md\n\n# -a 将原文件属性一同拷贝, 修改时间、创建时间等\ncp -a ./README.md ../README.md\n\n# -r 用于递归拷贝目录\ncp -r home ../home\n\n# -i 如果目标文件存在会询问用户是否需要覆盖\ncp -i README.md README.md\n")),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("a",k({parentName:"li"},{href:"https://github.com/xjh22222228/linux-manual#cat"}),"to read"))),(0,u.kt)("h3",null,"cat"),(0,u.kt)("p",null,"查看指定整个文件内容"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 查看 README.md 文件所有内容\ncat README.md\ncat README.md README2.md  # 或者一次性显示多个文件\n\n# -n 每一行显示行号\ncat -n README.md\n\n# -b 只给有内容的行显示行号\ncat -b README.md\n")),(0,u.kt)("h3",null,"mv"),(0,u.kt)("p",null,"mv 有 2 个用途："),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},"将文件或目录移动到另一个位置"),(0,u.kt)("li",{parentName:"ul"},"将文件或目录重命名")),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 将 README.md 重命名为 README-2.md, 如果 README-2.md 存在会直接覆盖。\nmv README.md README-2.md\n\n# 将 README.md 移动到上一层目录\nmv README.md ../README.md\n\n# -i 交互式操作，如果目标文件存在则进行询问是否覆盖\nmv -i README.md ../README.md\n")),(0,u.kt)("h3",null,"open"),(0,u.kt)("p",null,"open 命令可在 linux / mac 具有可视化界面下进行文本编辑、打开应用程序等功能。"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 在mac下用Finder打开当前目录\nopen .\n\n# 用默认应用程序打开文件\nopen README.md\n\n# 用默认编辑器打开文件\nopen -e README.md\n\n# 如果是一个URL用默认浏览器打开页面\nopen https://github.com/MuYunyun/blog.git\n\n# 指定某个应用程序打开某个文件, 如果不指定文件默认直接打开程序\nopen -a /Applications/Google\\ Chrome.app README.md\n")),(0,u.kt)("h3",null,"source"),(0,u.kt)("p",null,"在当前 Shell 环境中从指定文件读取和执行命令， 通常用于重新执行环境。"),(0,u.kt)("p",null,"它有个别名 . 点操作符号。"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 等价 . ~/.bash_profile\nsource ~/.bash_profile\n")),(0,u.kt)("p",null,"实际上大部分开发者都没搞懂 source 命令。 可以把它理解为编程语言中的 import, java/python/js 都有这个，就是用来导入文件。"),(0,u.kt)("p",null,"下面演示 source 用于 shell 脚本中"),(0,u.kt)("p",null,"util.sh"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),'#!/bin/bash\ngetName() {\n  echo "Linux"\n}\n')),(0,u.kt)("p",null,"main.sh"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"#!/bin/bash\n# 加载文件\nsource ./util.sh\n\n# 这样就可以调用 util 文件中的函数了\necho $(getName)\n")),(0,u.kt)("h3",null,"tree"),(0,u.kt)("p",null,"生成目录树结构, 通常用于描述项目结构。"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),'# 递归当前目录下所有文件并生成目录树\ntree\n\n# -I 忽略某些目录\ntree -I "node_modules"\n\n# 只显示目录\ntree -d\n\n# 指定要递归的目录层级\ntree -L 3\n')),(0,u.kt)("h3",null,"ln"),(0,u.kt)("p",null,"将某一个文件在另外一个位置建立并产生同步的链接。当不同的 2 个目录需要同时引用某一个文件时此命令就派上用场了。"),(0,u.kt)("blockquote",null,(0,u.kt)("p",{parentName:"blockquote"},"这个命令的应用场景: 比如 yarn link")),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},"软链接也可以叫符号链接：",(0,u.kt)("ul",{parentName:"li"},(0,u.kt)("li",{parentName:"ul"},"软链接，以路径的形式存在。类似于 Windows 操作系统中的快捷方式;"),(0,u.kt)("li",{parentName:"ul"},"软链接可以 跨文件系统, 硬链接不可以;"),(0,u.kt)("li",{parentName:"ul"},"软链接可以对一个不存在的文件名进行链接;"),(0,u.kt)("li",{parentName:"ul"},"软链接可以对目录进行链接;"))),(0,u.kt)("li",{parentName:"ul"},"硬链接:",(0,u.kt)("ul",{parentName:"li"},(0,u.kt)("li",{parentName:"ul"},"硬链接，以文件副本的形式存在。但不占用实际空间, 从根本上而言就是同一个文件;"),(0,u.kt)("li",{parentName:"ul"},"不允许给目录创建硬链接;"),(0,u.kt)("li",{parentName:"ul"},"硬链接只有在同一个文件系统中才能创建;")))),(0,u.kt)("blockquote",null,(0,u.kt)("p",{parentName:"blockquote"},"理解: 文件系统博主理解: 比如在 mac 系统中装了个虚拟机, 虚拟机里面跑了另外一个 window 系统, 那此时 mac 和虚拟机里面的系统就是两个不同的文件系统。")),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 默认创建硬链接，修改 README.md 内容， a.md 也会同步修改, 修改 a.md, README.md 也会同步修改\nln README.md a.md\n\n# -s 创建软链接\nln -s README.md a.md # 如果删除了 README.md  a.md 将失效\n\n# -f 强制执行\nln -f README.md ./src/a.md\n")),(0,u.kt)("h3",null,"file"),(0,u.kt)("p",null,"查看文件类型, 比如文件、目录、二进制、符号链接等。"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"file README.md\nREADME.md: HTML document text, UTF-8 Unicode text\n")),(0,u.kt)("h3",null,"tar"),(0,u.kt)("p",null,"全称: ",(0,u.kt)("inlineCode",{parentName:"p"},"tape archive")),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},"tar ","[-j|-z][cv]"," ","[-f 建立的档案名]"," filename... 打包与压缩"),(0,u.kt)("li",{parentName:"ul"},"tar ","[-j|-z][tv]"," ","[-f 建立的档案名]","             查看档案"),(0,u.kt)("li",{parentName:"ul"},"tar ","[-j|-z][xv]"," ","[-f 建立的档案名][-C 目录]","    解压缩")),(0,u.kt)("p",null,"选项与参数："),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},"-c: 建立打包档案，可搭配 -v 来观察过程中被打包的档案名 (filename)"),(0,u.kt)("li",{parentName:"ul"},"-t: 查看打包档案的内容含有那些档案"),(0,u.kt)("li",{parentName:"ul"},"-x: 解压缩的功能，可以搭配 -C 在特定的目录解开; -c、-t、-x 不能同时出现在一串指令列中。"),(0,u.kt)("li",{parentName:"ul"},"-j: 透过 bzip2 的支持进行压缩/解压缩: 此时档案名最好为 *.tar.bz2"),(0,u.kt)("li",{parentName:"ul"},"-z: 透过 gzip 的支持进行压缩/解压缩: 此时档案名最好为 *.tar.gz"),(0,u.kt)("li",{parentName:"ul"},"-v: 在压缩/解压缩的过程中, 将正在处理文件名显示出来"),(0,u.kt)("li",{parentName:"ul"},"-f filename: -f 后面要立刻接被处理的档案名! 建议 -f 单独写一个选项"),(0,u.kt)("li",{parentName:"ul"},"-C 目录: 指定特定目录")),(0,u.kt)("h2",null,"系统管理"),(0,u.kt)("h3",null,"ping"),(0,u.kt)("p",null,"测试目标地址是否可连接、延迟度"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 测试 github.com 连通性, 按 ctrl + C 停止\nping github.com\n\n# ping 5 次后断开\nping -c 5 github.com\n\n# 每 5 秒 ping 一次\nping -i 5 github.com\n")),(0,u.kt)("h3",null,"which"),(0,u.kt)("p",null,"查找某个命令存储在哪个位置, 输出绝对路径, which 会在环境变量 $PATH 设置的目录里去查找。"),(0,u.kt)("p",null,"注: 可以通过 echo $PATH 查看设置的目录."),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"which top  # /usr/bin/top\n\n# 打印多个命令\nwhich ping top\n")),(0,u.kt)("h3",null,"uptime"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 当前系统运行的天数，小时，分钟 (从上次开机起计算), 当前系统登录用户数。一分钟、5分钟、15分钟平均负载, 这 3 个值不能大于 CPU 个数，如果大于了说明系统负载高，性能低。\nuptime # 13:25  up 2 days, 18:57, 7 users, load averages: 2.06 2.06 2.15\n")),(0,u.kt)("h3",null,"uname"),(0,u.kt)("p",null,"打印系统信息"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 不带任何参数打印当前操作系统内核名称\nuname # Darwin , 等价于 uname -s\n\n# 打印系统所有信息, cloud-2.local: 网络节点主机名称, x86_64: 主机的硬件架构名称\nuname -a # Darwin cloud-2.local 19.4.0 Darwin Kernel Version 19.4.0: Wed Mar  4 22:28:40 PST 2020; root:xnu-6153.101.6~15/RELEASE_X86_64 x86_64\n\n# 打印主机的硬件架构名称\nuname -m # x86_64\n")),(0,u.kt)("h3",null,"ifconfig"),(0,u.kt)("p",null,"配置或显示系统网卡的网络参数。"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 显示所有网络参数信息\nifconfig\n")),(0,u.kt)("h3",null,"lsof"),(0,u.kt)("p",null,"列出当前系统打开文件的工具"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"## 打印所有打开文件的的列表\nlsof\n\n# 查看指定端口被占用情况\nlsof -i:8080\n")),(0,u.kt)("h3",null,"alias"),(0,u.kt)("p",null,"设置命令别名，用于简化较长的命令。"),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 列出所有已设置的别名\nalias\n\n# 删除所有别名\nunalias -a\n\n# 设置别名\nalias ll='ls -l'\n")),(0,u.kt)("h2",null,"系统进程"),(0,u.kt)("h3",null,"ps"),(0,u.kt)("p",null,"ps 命令涵盖命令参数三大风格"),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},"Unix 风格, ",(0,u.kt)("inlineCode",{parentName:"li"},"前面加单破折线")),(0,u.kt)("li",{parentName:"ul"},"BSD 风格, 全称伯克利软件发行版(Berkeley software distribution), ",(0,u.kt)("inlineCode",{parentName:"li"},"前面不加破折线")),(0,u.kt)("li",{parentName:"ul"},'GNU 风格, 全称 "Gnu\'s Not Unix", ',(0,u.kt)("inlineCode",{parentName:"li"},"前面加双破折线"))),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"# 配合 grep 查询指定进程, -a means: all, -f means full\nps -af | grep nginx\n")),(0,u.kt)("h2",null,"其它"),(0,u.kt)("h3",null,"clear"),(0,u.kt)("p",null,"用于清除当前终端所有信息，本质上只是向后翻了一页，往上滚动还能看到之前的操作信息"),(0,u.kt)("blockquote",null,(0,u.kt)("p",{parentName:"blockquote"},"注：效果等用于 ",(0,u.kt)("inlineCode",{parentName:"p"},"command + K")," 可以完全清除终端所有操作信息。")),(0,u.kt)("pre",null,(0,u.kt)("code",k({parentName:"pre"},{className:"language-bash"}),"clear\n")),(0,u.kt)("h3",null,"link"),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},"thanks for ",(0,u.kt)("a",k({parentName:"li"},{href:"https://github.com/xjh22222228/linux-manual"}),"Read Linux"),".")))}c.isMDXComponent=!0}}]);