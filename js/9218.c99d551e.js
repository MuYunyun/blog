(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9218],{29218:(t,n,e)=>{"use strict";e.r(n),e.d(n,{default:()=>c});var s=e(59713),r=e.n(s),u=e(6479),l=e.n(u),p=(e(67294),e(3905));function a(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);n&&(s=s.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,s)}return e}function i(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?a(Object(e),!0).forEach((function(n){r()(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):a(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}var o={};function c(t){var n=t.components,e=l()(t,["components"]);return(0,p.kt)("wrapper",i(i(i({},o),e),{},{components:n,mdxType:"MDXLayout"}),(0,p.kt)("h3",null,"78.Subsets"),(0,p.kt)("p",null,"Given an integer array nums, return all possible subsets (the power set).\n",(0,p.kt)("inlineCode",{parentName:"p"},"The solution set must not contain duplicate subsets"),"."),(0,p.kt)("p",null,"Example 1:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-js"}),"Input: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n")),(0,p.kt)("p",null,"Example 2:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-js"}),"Input: nums = [0]\nOutput: [[],[0]]\n")),(0,p.kt)("p",null," \nConstraints:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"1 <= nums.length <= 10"),(0,p.kt)("li",{parentName:"ul"},"-10 <= nums","[i]"," <= 10")),(0,p.kt)("h3",null,"Analyze"),(0,p.kt)("p",null,"由题意可知该题是组合问题, 可以使用回溯法解决。"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function (nums) {\n  const list = []\n  const tmpList = []\n\n  backTrack(list, tmpList, nums, 0)\n\n  return list\n};\n\nfunction backTrack(list, tmpList, nums, start) {\n  list.push(tmpList.slice())\n\n  for (let i = start; i < nums.length; i++) {\n    tmpList.push(nums[i])\n    backTrack(list, tmpList, nums, i + 1)\n    tmpList.splice(tmpList.length - 1, 1)\n  }\n}\n")))}c.isMDXComponent=!0}}]);