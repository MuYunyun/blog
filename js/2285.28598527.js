(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2285],{82285:(n,e,o)=>{"use strict";o.r(e),o.d(e,{default:()=>i});var t=o(59713),p=o.n(t),l=o(6479),c=o.n(l),r=(o(67294),o(3905));function a(n,e){var o=Object.keys(n);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(n);e&&(t=t.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),o.push.apply(o,t)}return o}function m(n){for(var e=1;e<arguments.length;e++){var o=null!=arguments[e]?arguments[e]:{};e%2?a(Object(o),!0).forEach((function(e){p()(n,e,o[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(o,e))}))}return n}var s={};function i(n){var e=n.components,o=c()(n,["components"]);return(0,r.kt)("wrapper",m(m(m({},s),o),{},{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h3",null,"生命周期"),(0,r.kt)("p",null,"先来回顾 React 的生命周期, 用流程图表示如下:"),(0,r.kt)("p",null,(0,r.kt)("img",m({parentName:"p"},{src:"http://with.muyunyun.cn/77e8b5ceaa1d697f280053be91a87bb3.jpg",alt:null}))),(0,r.kt)("p",null,"该流程图比较清晰地呈现了 react 的生命周期。其分为 3 个阶段 —— 生成期, 存在期, 销毁期。"),(0,r.kt)("p",null,"因为生命周期钩子函数存在于自定义组件中, 将之前 _render 函数作些调整如下:"),(0,r.kt)("pre",null,(0,r.kt)("code",m({parentName:"pre"},{className:"language-js"}),"// 原来的 _render 函数, 为了将职责拆分得更细, 将 virtual dom 转为 real dom 的函数单独抽离出来\nfunction vdomToDom(vdom) {\n  if (_.isFunction(vdom.nodeName)) {        // 为了更加方便地书写生命周期逻辑, 将解析自定义组件逻辑和一般 html 标签的逻辑分离开\n    const component = createComponent(vdom) // 构造组件\n    setProps(component)                     // 更改组件 props\n    renderComponent(component)              // 渲染组件, 将 dom 节点赋值到 component\n    return component.base                   // 返回真实 dom\n  }\n  ...\n}\n")),(0,r.kt)("p",null,"我们可以在 setProps 函数内（渲染前）加入 ",(0,r.kt)("inlineCode",{parentName:"p"},"componentWillMount"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"componentWillReceiveProps")," 方法, setProps 函数如下:"),(0,r.kt)("pre",null,(0,r.kt)("code",m({parentName:"pre"},{className:"language-js"}),"function setProps(component) {\n  if (component && component.componentWillMount) {\n    component.componentWillMount()\n  } else if (component.base && component.componentWillReceiveProps) {\n    component.componentWillReceiveProps(component.props) // 后面待实现\n  }\n}\n")),(0,r.kt)("p",null,"而后我们在 renderComponent 函数内加入 ",(0,r.kt)("inlineCode",{parentName:"p"},"componentDidMount"),"、",(0,r.kt)("inlineCode",{parentName:"p"},"shouldComponentUpdate"),"、",(0,r.kt)("inlineCode",{parentName:"p"},"componentWillUpdate"),"、",(0,r.kt)("inlineCode",{parentName:"p"},"componentDidUpdate")," 方法"),(0,r.kt)("pre",null,(0,r.kt)("code",m({parentName:"pre"},{className:"language-js"}),"function renderComponent(component) {\n  if (component.base && component.shouldComponentUpdate) {\n    const bool = component.shouldComponentUpdate(component.props, component.state)\n    if (!bool && bool !== undefined) {\n      return false // shouldComponentUpdate() 返回 false, 则生命周期终止\n    }\n  }\n  if (component.base && component.componentWillUpdate) {\n    component.componentWillUpdate()\n  }\n\n  const rendered = component.render()\n  const base = vdomToDom(rendered)\n\n  if (component.base && component.componentDidUpdate) {\n    component.componentDidUpdate()\n  } else if (component && component.componentDidMount) {\n    component.componentDidMount()\n  }\n\n  if (component.base && component.base.parentNode) { // setState 进入此逻辑\n    component.base.parentNode.replaceChild(base, component.base)\n  }\n\n  component.base = base  // 标志符\n}\n")),(0,r.kt)("h3",null,"测试生命周期"),(0,r.kt)("p",null,"测试如下用例:"),(0,r.kt)("pre",null,(0,r.kt)("code",m({parentName:"pre"},{className:"language-jsx"}),"class A extends Component {\n  componentWillReceiveProps(props) {\n    console.log('componentWillReceiveProps')\n  }\n\n  render() {\n    return (\n      <div>{this.props.count}</div>\n    )\n  }\n}\n\nclass B extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      count: 1\n    }\n  }\n\n  componentWillMount() {\n    console.log('componentWillMount')\n  }\n\n  componentDidMount() {\n    console.log('componentDidMount')\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('shouldComponentUpdate', nextProps, nextState)\n    return true\n  }\n\n  componentWillUpdate() {\n    console.log('componentWillUpdate')\n  }\n\n  componentDidUpdate() {\n    console.log('componentDidUpdate')\n  }\n\n  click() {\n    this.setState({\n      count: ++this.state.count\n    })\n  }\n\n  render() {\n    console.log('render')\n    return (\n      <div>\n        <button onClick={this.click.bind(this)}>Click Me!</button>\n        <A count={this.state.count} />\n      </div>\n    )\n  }\n}\n\nReactDOM.render(\n  <B />,\n  document.getElementById('root')\n)\n")),(0,r.kt)("p",null,"页面加载时输出结果如下:"),(0,r.kt)("pre",null,(0,r.kt)("code",m({parentName:"pre"},{}),"componentWillMount\nrender\ncomponentDidMount\n")),(0,r.kt)("p",null,"点击按钮时输出结果如下:"),(0,r.kt)("pre",null,(0,r.kt)("code",m({parentName:"pre"},{}),"shouldComponentUpdate\ncomponentWillUpdate\nrender\ncomponentDidUpdate\n")),(0,r.kt)("h3",null,"React 16.3 生命周期调研"),(0,r.kt)("p",null,"在这个版本中, 新加入了两个生命周期:"),(0,r.kt)("pre",null,(0,r.kt)("code",m({parentName:"pre"},{}),"getDerivedStateFromProps(nextProps, prevState): 更加语义化, 可以代替 componentWillMount、componentWillReceiveProps(nextProps);\n\ngetSnapshotBeforeUpdate(prevProps, prevState): 可以将结果传入 componentDidUpdate 里, 从而达到 dom 数据统一, 可以替代 componentWillUpdate()（缺点就是前面讲的 react 开启异步渲染, componentWillUpdate() 与 componentDidUpdate() 间获取的 dom 会不统一）。\n")),(0,r.kt)("p",null,"后文考虑实现上述 api。"),(0,r.kt)("p",null,"React 16.3 生命周期相关文献"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",m({parentName:"li"},{href:"https://zhuanlan.zhihu.com/p/36062486"}),"React v16.3 版本新生命周期函数浅析及升级方案")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",m({parentName:"li"},{href:"https://react.docschina.org/docs/react-component.html"}),"中文官方文档"))))}i.isMDXComponent=!0}}]);