(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4362],{64362:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>c});var r=n(59713),l=n.n(r),o=n(6479),i=n.n(o),a=(n(67294),n(3905));function p(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function u(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?p(Object(n),!0).forEach((function(t){l()(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):p(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var s={};function c(e){var t=e.components,n=i()(e,["components"]);return(0,a.kt)("wrapper",u(u(u({},s),n),{},{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h3",null,"101. Symmetric Tree"),(0,a.kt)("p",null,"Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center)."),(0,a.kt)("p",null,"For example, this binary tree ","[1,2,2,3,4,4,3]"," is symmetric:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-js"}),"    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n")),(0,a.kt)("p",null,"But the following ","[1,2,2,null,3,null,3]"," is not:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-js"}),"    1\n   / \\\n  2   2\n   \\   \\\n    3   3\n")),(0,a.kt)("p",null,"Follow up: Solve it both recursively and iteratively."),(0,a.kt)("h3",null,"Analyze"),(0,a.kt)("p",null,"解法一: 递归解法。"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isSymmetric = function (root) {\n  if (root === null) {\n    return true\n  }\n  return isMirror(root.left, root.right)\n};\n\nfunction isMirror(leftNode, rightNode) {\n  if (leftNode === null && rightNode === null) {\n    return true\n  }\n\n  if (leftNode === null || rightNode === null) {\n    return false\n  }\n\n  if (leftNode.val === rightNode.val) {\n    return isMirror(leftNode.left, rightNode.right) && isMirror(leftNode.right, rightNode.left)\n  } else {\n    return false\n  }\n}\n")),(0,a.kt)("p",null,"解法二: 迭代解法:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-js"}),"        1\n      /   \\\n    2       2\n   / \\     / \\\n  3   4   4   3\n / \\ / \\ / \\ / \\\n5  6 7 8 8 7 6  5\n")),(0,a.kt)("p",null,"解析:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"第一步: ",(0,a.kt)("inlineCode",{parentName:"li"},"stack = [2, 2]"),";"),(0,a.kt)("li",{parentName:"ul"},"第二步: 取出 ",(0,a.kt)("inlineCode",{parentName:"li"},"[2, 2]"),", 推入 ",(0,a.kt)("inlineCode",{parentName:"li"},"[3, 3, 4, 4]"),";"),(0,a.kt)("li",{parentName:"ul"},"第三步: 取出 ",(0,a.kt)("inlineCode",{parentName:"li"},"[4, 4]"),", 推入 ",(0,a.kt)("inlineCode",{parentName:"li"},"[7, 7, 8, 8]"),";"),(0,a.kt)("li",{parentName:"ul"},"第四步: 取出 ",(0,a.kt)("inlineCode",{parentName:"li"},"[8, 8]"),";"),(0,a.kt)("li",{parentName:"ul"},"第五步: 取出 ",(0,a.kt)("inlineCode",{parentName:"li"},"[7, 7]"),", 取出 ",(0,a.kt)("inlineCode",{parentName:"li"},"[3, 3]"),";"),(0,a.kt)("li",{parentName:"ul"},"第六步: 推入 ",(0,a.kt)("inlineCode",{parentName:"li"},"[5, 5, 6, 6]"),";"),(0,a.kt)("li",{parentName:"ul"},"第七步: 取出 ",(0,a.kt)("inlineCode",{parentName:"li"},"[6, 6]"),";"),(0,a.kt)("li",{parentName:"ul"},"第八步: 取出 ",(0,a.kt)("inlineCode",{parentName:"li"},"[5, 5]"),";")),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isSymmetric = function (root) {\n  if (!root) return true\n  if (!root.left && !root.right) return true\n  if (root.left && root.right && root.left.val !== root.right.val) return false\n\n  const stack = []\n\n  stack.push(root.right)\n  stack.push(root.left)\n\n  while (stack.length > 0) {\n    const popItemLeft = stack.pop()\n    const popItemRight = stack.pop()\n\n    if (!popItemLeft && !popItemRight) continue\n    if (!popItemLeft || !popItemRight || popItemLeft.val !== popItemRight.val) return false\n\n    stack.push(popItemRight.right, popItemLeft.left, popItemRight.left, popItemLeft.right)\n  }\n\n  return true\n};\n")))}c.isMDXComponent=!0}}]);