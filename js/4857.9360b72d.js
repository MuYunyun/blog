(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4857],{64857:n=>{n.exports="### HTML5 DOM\n\n1. getElementsByClassName\n2. 遍历相关, 如下左侧属性\n\n> 只涉及元素节点的操作(不涉及其它节点), 建议使用左侧的属性替代右侧的属性:\n\n| 属性名 | 被替代的属性 |\n| :-: | :-: |\n| children | childNodes |\n| childElementCount | childNodes.length |\n| previousElementSibling | previousSibling |\n| nextElementSibling | nextSibling |\n| firstElementChild | firstChild |\n| lastElementChild | lastChild |\n\n3. ele.scrollIntoView()\n\n调用 ele.scrollIntoView(), ele 元素顶端会移动到可视区域的顶端; 若传入参数 alignToTop: false, 则 ele 移到屏幕底部;\n\n### HTML5 事件\n\n1. contextmenu\n\n<details>\n  <summary>contextmenu 使用 demo</summary>\n\n```html\n<ul id=\"myMenu\" style=\"position: absolute;visibility: hidden;background-color: silver\">\n  <li>111</li>\n  <li>222</li>\n  <li>333</li>\n</ul>\n<script>\n  var menu = document.getElementById('myMenu')\n  document.addEventListener('contextmenu', (event) => {\n    event.preventDefault()\n    menu.style.left = event.clientX + 'px'\n    menu.style.top = event.clientY + 'px'\n    menu.style.visibility = 'visible'\n  }, false)\n  document.addEventListener('click', (event) => {\n    menu.style.visibility = 'hidden'\n  }, false)\n<\/script>\n```\n</details>\n\n2. DOMContentLoaded\n\n优于 window.onload 执行\n\n3. readystatechange\n\n可用来判断动态载入的 script、link 标签是否加载完成。demo 如下:\n\n```js\nconst script = document.createElement('script')\nscript.addEventListener('readystatechange', function eventListener(event) {\n  if (event.readyState === 'loaded' || event.readyState === 'complete') { // hack 的手段, 浏览器自身的问题\n    script.removeEventListener('readystatechange', eventListener)\n  }\n})\n\nscript.src = 'example.js'\ndocument.body.appendChild(script)\n```\n\n4. hashchange\n\n### HTML5 表单\n\n* input/textarea 里新增 `autoFocus()` 字段\n* 表单校验 api\n\n使用 `checkValidate()` 校验 `required`、`pattern=\"\\d+\"` 属性\n\n### HTML5 脚本\n\n* 跨文档消息传输(XDM), 核心是 `postMessage`\n* 拖放 api\n\n<details>\n<summary>拖放 api 使用示例</summary>\n\n```html\n<head>\n\t<style>\n\t\t#draggable {\n\t\t\twidth: 200px;\n\t\t\theight: 20px;\n\t\t\ttext-align: center;\n\t\t\tbackground: white;\n\t\t}\n\n\t\t.dropzone {\n\t\t\twidth: 200px;\n\t\t\theight: 20px;\n\t\t\tbackground: blueviolet;\n\t\t\tmargin-bottom: 10px;\n\t\t\tpadding: 10px;\n\t\t}\n\t</style>\n</head>\n\n<body>\n\t<div class=\"dropzone\">\n\t\t<div id=\"draggable\" draggable=\"true\" ondragstart=\"event.dataTransfer.setData('text/plain',null)\">\n\t\t\tThis div is draggable\n\t\t</div>\n\t</div>\n\t<div class=\"dropzone\"></div>\n\t<div class=\"dropzone\"></div>\n\t<div class=\"dropzone\"></div>\n\t<script>\n\t\twindow.onload = function () {\n\t\t\tvar dragged\n\n\t\t\tdocument.addEventListener(\"dragstart\", function (event) {\n\t\t\t\tdragged = event.target\n\t\t\t}, false)\n\n\t\t\tdocument.addEventListener(\"dragover\", function (event) {\n\t\t\t\t// prevent default to allow drop\n\t\t\t\tevent.preventDefault()\n\t\t\t}, false)\n\n\t\t\tdocument.addEventListener(\"drop\", function (event) {\n\t\t\t\t// prevent default action (open as link for some elements)\n\t\t\t\tevent.preventDefault()\n\t\t\t\tif (event.target.className == \"dropzone\") {\n\t\t\t\t\tdragged.parentNode.removeChild(dragged)\n\t\t\t\t\tevent.target.appendChild(dragged)\n\t\t\t\t}\n\t\t\t}, false)\n\t\t}\n\t<\/script>\n</body>\n```\n</details>\n\n* 媒体元素 `<video>`、`<audio>`\n* 浏览器状态管理(history)\n\n### HTML5 存储\n\n* `sessionStorage`: 大小上限为 2.5Mb(不同浏览器会有差异), 页面关闭时便清空;\n* `localStorage`: 大小上限为 2.5Mb(不同浏览器会有差异), 页面关闭时不会清空;\n\n它们的 api 也是一致的, 有如下几个:\n\n* setItem(key, value)\n* getItem(key)\n* removeItem(key)\n* clear()\n\n> 在 HTML5 范围之外与存储相关的技术还有 cookie(存放在客户端, 可以由客户端也可以由服务端生成, 大小上限为 4 kb)、IndexedDB(大小上限为 5 Mb)、cacheStorage(ServiceWorker)。\n\n### HTML5 JavaScript Api\n\n* `requestAnimationFrame(callback)`: 表示在下次重绘前执行指定的回调函数，下面通过一个简单的 demo 来认识它。\n\n```js\nlet frame\nlet n = 5\nfunction callback(timeStamp) {\n\tconsole.log(timeStamp) // 开始执行回调的时间戳\n\t// 如果想要产生循环动画的效果, 需在回调函数中再次调用 requestAnimationFrame()\n\twhile (n > 0) {\n\t\trequestAnimationFrame(callback)\n\t\tconsole.log('测试执行顺序')\n\t\tn--\n\t}\n}\n\nframe = requestAnimationFrame(callback) // 在下次重绘之前调用回调\n\n// 如果想要销毁该回调, 可以执行 cancelAnimationFrame(frame)\n```\n\n执行上述代码, 控制台(chrome)打印如下数据:\n\n```\n先输出 5 次 '测试执行顺序'\n1795953.649\n1795970.318\n1795986.987\n1796003.656\n1796020.325\n...\n```\n\n可以看到在浏览器上一帧的时间大致为 `16ms`。同时可以看到 `requestAnimation(callback)` 中的 callback 也是异步的(只不过它是基于帧与帧间的异步), 所以上述打印结果是先打印出 5 次 '测试执行顺序' 后再依次打印出 5 个时间戳。requestAnimation 不仅可以用在动画上, 更是被 React 团队用来 hack requestIdleCallback 的实现。可以阅读[你不知道的 requestIdleCallback](https://github.com/MuYunyun/blog/blob/master/React/requestIdleCallback.md)\n\n* `Web Worker`\n\nJavaScript 是一门单线程的语言, 借助 Web Worker 能在浏览器上模拟线程的概念。\n\n* `Service Worker`: 基于 Web Worker 的 api 来处理网络请求以及缓存, 可以将其理解为是 `Web Worker + cache storage` 的组合。同时其也是 PWA 依赖的最为重要的技术。\n\n### 浏览器支持 HTML5 情况\n\n可以在 html5test.com 查询浏览器支持 HTML5 情况。"}}]);