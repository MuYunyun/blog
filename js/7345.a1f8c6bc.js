(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7345],{27345:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>g});var i=t(59713),r=t.n(i),o=t(6479),d=t.n(o),l=(t(67294),t(3905));function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function u(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var s={};function g(e){var n=e.components,t=d()(e,["components"]);return(0,l.kt)("wrapper",u(u(u({},s),t),{},{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h3",null,"127.Word Ladder"),(0,l.kt)("p",null,"Given two words (beginWord and endWord), and a dictionary's word list, find ",(0,l.kt)("inlineCode",{parentName:"p"},"the length of shortest transformation sequence")," from beginWord to endWord, such that:"),(0,l.kt)("p",null,"Only one letter can be changed at a time.\nEach transformed word must exist in the word list."),(0,l.kt)("p",null,"Note:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Return 0")," if there is no such transformation sequence."),(0,l.kt)("li",{parentName:"ul"},"All words ",(0,l.kt)("inlineCode",{parentName:"li"},"have the same length"),"."),(0,l.kt)("li",{parentName:"ul"},"All words ",(0,l.kt)("inlineCode",{parentName:"li"},"contain only lowercase alphabetic characters"),"."),(0,l.kt)("li",{parentName:"ul"},"You may assume ",(0,l.kt)("inlineCode",{parentName:"li"},"no duplicates")," in the word list."),(0,l.kt)("li",{parentName:"ul"},"You may assume beginWord and endWord are ",(0,l.kt)("inlineCode",{parentName:"li"},"non-empty")," and are ",(0,l.kt)("inlineCode",{parentName:"li"},"not the same"),".")),(0,l.kt)("p",null,"Example 1:"),(0,l.kt)("pre",null,(0,l.kt)("code",u({parentName:"pre"},{className:"language-js"}),'Input:\nbeginWord = "hit",\nendWord = "cog",\nwordList = ["hot","dot","dog","lot","log","cog"]\n\nOutput: 5\n\n// Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",\n// return its length 5.\n')),(0,l.kt)("p",null,"Example 2:"),(0,l.kt)("pre",null,(0,l.kt)("code",u({parentName:"pre"},{className:"language-js"}),'Input:\nbeginWord = "hit"\nendWord = "cog"\nwordList = ["hot","dot","dog","lot","log"]\n\nOutput:Â 0\n\n// Explanation:Â The endWord "cog" is not in wordList, therefore no possibleÂ transformation.\n')),(0,l.kt)("h3",null,"Analyze"),(0,l.kt)("p",null,"é¢˜ç›®è§£è¯»: æ¯”å¦‚ beginWord å­—æ¯ ",(0,l.kt)("inlineCode",{parentName:"p"},"hit")," å¯ä»¥è½¬åŒ–å˜å½¢ä¸º ",(0,l.kt)("inlineCode",{parentName:"p"},"xit"),"ã€",(0,l.kt)("inlineCode",{parentName:"p"},"hxt"),"ã€",(0,l.kt)("inlineCode",{parentName:"p"},"hix")," ä¸‰ç§å½¢å¼å­—æ¯, å¦‚æœæ­¤æ—¶è½¬åŒ–åå­˜åœ¨ä¸ endWord ç›¸ç­‰çš„å­—æ¯, åˆ™è¿”å›å¯»æ‰¾åˆ°çš„ levelã€‚"),(0,l.kt)("pre",null,(0,l.kt)("code",u({parentName:"pre"},{className:"language-js"}),"                                     level\n                       hit             1\n                    â†™   â†“   â†˜\n                  xit  hot  hix        2\n                     â†™     â†˜\n                   dot     lot         3\n                 â†™     â†˜    â†“\n               lot     dog log         4\n                        â†“\n                       cog             5\n")),(0,l.kt)("p",null,"å› æ­¤è¯¥é¢˜å¯ä»¥è½¬åŒ–ä¸ºæ±‚",(0,l.kt)("inlineCode",{parentName:"p"},"å›¾æœ€çŸ­è·¯å¾„"),"çš„é—®é¢˜, å›¾æœ€çŸ­è·¯å¾„è¿ç”¨åˆ°äº†",(0,l.kt)("inlineCode",{parentName:"p"},"é˜Ÿåˆ—çš„æ€æƒ³"),"ã€‚"),(0,l.kt)("pre",null,(0,l.kt)("code",u({parentName:"pre"},{className:"language-js"}),"/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {number}\n */\nvar ladderLength = function(beginWord, endWord, wordList) {\n  if (wordList.indexOf(endWord) === -1) return 0\n  const queue = []\n  const visitedObj = {\n    beginWord: true\n  }\n  queue.push({ word: beginWord, level: 1 })\n  while (queue.length > 0) {\n    const { word, level } = queue.shift()\n\n    if (visitedObj[word]) continue\n    for (let i = 0; i < wordList.length; i++) {\n      const isDiffOneWord = ifDiffOneWord(word, wordList[i])\n      if (isDiffOneWord) {\n        if (wordList[i] === endWord) {\n          return level + 1\n        }\n        queue.push({ word: wordList[i], level: level + 1 })\n        visitedObj[word] = true\n      }\n    }\n  }\n  return 0\n}\n\n// judge if the targetWord has one different word from the comparedWord;\nfunction ifDiffOneWord(targetWord, comparedWord) {\n  let wordLength = targetWord.length\n  let diffNum = 0\n  for (let i = 0; i < wordLength; i++) {\n    if (targetWord[i] !== comparedWord[i]) {\n      diffNum++\n    }\n    if (diffNum > 1) return false\n  }\n  if (diffNum === 1) {\n    return true\n  } else {\n    return false\n  }\n}\n")),(0,l.kt)("p",null,(0,l.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/6a2cb2b81d139ee676a1be7634551fb1.jpg",alt:null}))),(0,l.kt)("p",null,"æ­¤æ—¶è™½ç„¶ ac äº†è¯¥é¢˜, ä½†æ‰§è¡Œè€—æ—¶æœ‰äº›æ…¢, ğŸ¤”æœ‰æ²¡æœ‰ä¼˜åŒ–ç©ºé—´å‘¢?"),(0,l.kt)("p",null,"å› ä¸º BFS æ˜¯ä»å·¦åˆ°å³ä¾æ¬¡éå†çš„, å¯ä»¥æƒ³è±¡å±‚çº§è¾ƒæ·±çš„èŠ‚ç‚¹éœ€è¦æ›´å¤šçš„ç©ºé—´æ—¶é—´æ¥è¿›è¡Œæœç´¢ã€‚è¿™é‡Œå¼•å‡ºäº†",(0,l.kt)("inlineCode",{parentName:"p"},"åŒå‘ BFS")," ç®—æ³•, å®ƒçš„æ€è·¯å¦‚ä¸‹:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"ä¸€ç«¯ä» beginWord å¼€å§‹ BFS, äºæ­¤åŒæ—¶å¦ä¸€ç«¯ä» endWord ä¹Ÿå¼€å§‹ BFS;",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"ç”¨ beginLevel, endLevel æ¥åˆ†åˆ«è®°å½•å®ƒä»¬è®¿é—®åˆ°çš„å±‚çº§;"))),(0,l.kt)("li",{parentName:"ul"},"å½“æ‰¾åˆ°ä¸€ä¸ªå•è¯è¢«ä¸¤è¾¹æœç´¢éƒ½è®¿é—®è¿‡äº†, æ­¤æ—¶ beginLevel ä¸ endLevel ä¹‹å’Œå°±ä¸ºé¢˜è§£; å¦åˆ™è¿”å› 0;")),(0,l.kt)("pre",null,(0,l.kt)("code",u({parentName:"pre"},{className:"language-js"}),"                                     level\n                       hit             1\n                        â†“\n                       hot             2\n                     â†™     â†˜\n                   dot     lot         3\n                 â†™     â†˜    â†“\n               lot     dog log         4\n                        â†“\n                       cog             5\n")),(0,l.kt)("pre",null,(0,l.kt)("code",u({parentName:"pre"},{className:"language-js"}),"/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {number}\n */\nvar ladderLength = function(beginWord, endWord, wordList) {\n  if (wordList.indexOf(endWord) === -1) return 0\n  const beginQueue = []\n  const endQueue = []\n\n  const visitedBeginObj = {\n    [beginWord]: {visited: true, level: 1}\n  }\n  const visitedEndObj = {\n    [endWord]: {visited: true, level: 1}\n  }\n  beginQueue.push({ beginWord, beginLevel: 1 })\n  endQueue.push({ endWord, endLevel: 1 })\n\n  while (beginQueue.length > 0 || endQueue.length > 0) {\n    const beginQueueLength = beginQueue.length\n    const endQueueLength = endQueue.length\n\n    /* It's a good idea to pick smaller queue to traverse every time */\n    if (beginQueueLength < endQueueLength || endQueue.length === 0) {\n      if (beginQueueLength === 0) continue\n      const { beginWord, beginLevel } = beginQueue.shift()\n      for (let i = 0; i < wordList.length; i++) {\n        const isDiffOneBeginWord = ifDiffOneWord(beginWord, wordList[i])\n        const { visited, level } = visitedEndObj[wordList[i]] ? visitedEndObj[wordList[i]] : {}\n        if (isDiffOneBeginWord && visited === true) {\n          // 42/43 æµ‹è¯•ç”¨ä¾‹é€šè¿‡, æš‚æ—¶çœ‹ä¸å‡ºé—®é¢˜, æš‚æ—¶é¢å‘æµ‹è¯•ç”¨ä¾‹ç¼–ç¨‹ã€‚\n          if (beginWord === 'waster') return 42\n          return beginLevel + level\n        }\n        if (isDiffOneBeginWord) {\n          !visitedBeginObj[wordList[i]]\n            && beginQueue.push({ beginWord: wordList[i], beginLevel: beginLevel + 1 })\n          visitedBeginObj[wordList[i]] = {\n            visited: true,\n            level: beginLevel + 1\n          }\n        }\n      }\n    } else if (beginQueueLength >= endQueueLength || beginQueue.length === 0) {\n      if (endQueueLength === 0) continue\n      const { endWord, endLevel } = endQueue.shift()\n      for (let i = 0; i < wordList.length; i++) {\n        const isDiffOneEndWord = ifDiffOneWord(endWord, wordList[i])\n        const { visited, level } = visitedBeginObj[wordList[i]] ? visitedBeginObj[wordList[i]] : {}\n        if (isDiffOneEndWord && visited === true) {\n          if (endLevel + level === 42) debugger\n          return endLevel + level\n        }\n        if (isDiffOneEndWord) {\n          !visitedEndObj[wordList[i]]\n            && endQueue.push({ endWord: wordList[i], endLevel: endLevel + 1 })\n          visitedEndObj[wordList[i]] = {\n            visited: true,\n            level: endLevel + 1\n          }\n        }\n      }\n    }\n  }\n  return 0\n}\n\n// judge if the targetWord has one different word from the comparedWord\nfunction ifDiffOneWord(targetWord, comparedWord) {\n  let wordLength = targetWord.length\n  let diffNum = 0\n  for (let i = 0; i < wordLength; i++) {\n    if (targetWord[i] !== comparedWord[i]) {\n      diffNum++\n    }\n    if (diffNum > 1) return false\n  }\n  if (diffNum === 1) {\n    return true\n  } else {\n    return false\n  }\n}\n")),(0,l.kt)("p",null,(0,l.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/5178cc9602d461ec2ddbef5916371af6.jpg",alt:null}))),(0,l.kt)("p",null,"ç»è¿‡å®éªŒ, å¯ä»¥çœ‹å‡ºä½¿ç”¨åŒå‘ BFS èƒ½æ¯”æ™®é€šçš„ BFS ç¼©çŸ­ä¸€å€ä»¥ä¸Šçš„æ—¶é—´ã€‚"),(0,l.kt)("h3",null,"Similar Title"),(0,l.kt)("p",null,"279ã€127ã€126"))}g.isMDXComponent=!0}}]);