(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6424],{46424:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>c});var r=t(59713),a=t.n(r),l=t(6479),p=t.n(l),i=(t(67294),t(3905));function u(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?u(Object(t),!0).forEach((function(e){a()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):u(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var s={};function c(n){var e=n.components,t=p()(n,["components"]);return(0,i.kt)("wrapper",o(o(o({},s),t),{},{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h3",null,"70.Climbing Stairs"),(0,i.kt)("p",null,"You are climbing a staircase. It takes n steps to reach the top."),(0,i.kt)("p",null,"Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?"),(0,i.kt)("p",null,"Example 1:"),(0,i.kt)("pre",null,(0,i.kt)("code",o({parentName:"pre"},{className:"language-js"}),"Input: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n")),(0,i.kt)("p",null,"Example 2:"),(0,i.kt)("pre",null,(0,i.kt)("code",o({parentName:"pre"},{className:"language-js"}),"Input: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n")),(0,i.kt)("h3",null,"Analyze"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"到达当前的台阶的方法有两种:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"一种方法是从",(0,i.kt)("inlineCode",{parentName:"li"},"上一级台阶加一"),";"),(0,i.kt)("li",{parentName:"ul"},"另一种方法是从",(0,i.kt)("inlineCode",{parentName:"li"},"上上一级台阶加二"),";")))),(0,i.kt)("p",null,"所以到达当前台阶的方法之和可以用以下式子表示: ",(0,i.kt)("inlineCode",{parentName:"p"},"f(n) = f(n - 1) + f(n - 2)"),"。"),(0,i.kt)("p",null,"因此该问题与解斐波那契数列是相同的场景。以下提供",(0,i.kt)("inlineCode",{parentName:"p"},"记忆化递归"),"与",(0,i.kt)("inlineCode",{parentName:"p"},"动态规划"),"两种解法:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"记忆化递归方法:")),(0,i.kt)("pre",null,(0,i.kt)("code",o({parentName:"pre"},{className:"language-js"}),"const arr = [1, 2]\n\n/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function (n) {\n  if (n === 1) return arr[0]\n  if (n === 2) return arr[1]\n\n  if (arr[n]) return arr[n]\n  arr[n] = climbStairs(n - 1) + climbStairs(n - 2)\n  return arr[n]\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",o({parentName:"li"},{href:"https://github.com/MuYunyun/blog/blob/main/Algorithm/algorithm/dynamic_programming.md"}),"动态规划"),"方法:")),(0,i.kt)("pre",null,(0,i.kt)("code",o({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function (n) {\n  const arr = [1, 2]\n  for (let i = 2; i < n; i++) {\n    arr[i] = arr[i - 1] + arr[i - 2]\n  }\n\n  return arr[n - 1]\n}\n")))}c.isMDXComponent=!0}}]);