(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5540],{5540:n=>{n.exports="`...` 是 ES6 新出来的符号, 称为扩展运算符。它在不同情况下有不同的作用, 下文我们将对之进行梳理。\n\n### 对象中的扩展运算符\n\n1. `...` 当作对象扩展符使用时可以用来*浅拷贝*目标对象的*自有属性中的可枚举属性*。\n\n> 对象中的扩展运算符的作用等同于 Object.assign()。\n\n下面举例证明上述结论:\n\n* 验证对象扩展符只能 `copy` 自有属性, 原型链上的属性不能 `copy`\n\n```js\nclass Demo {\n  constructor() {\n    this.name = 'Lily'\n  }\n\n  testFn() {}\n}\n\nconst test = new Demo()\nconst cpObj = { ...test }\n\ncpObj.name === 'Lily' // true\ncpObj.testFn()        // Uncaught TypeError: cpTest.testFn is not a function\n```\n\n* 验证只能 copy 可枚举属性\n\n```js\nconst obj = Object.defineProperty({ a: 1 }, 'b', {\n  enumerable: false,\n  value: 2\n})\n\nconst cpObj = { ...obj }\nobj.a   // 1\nobj.b   // 2\n\ncpObj.a // 1\ncpObj.b // undefined\n```\n\n2. 解构赋值\n\n```js\nconst obj = { a: 1, b: 2, c: 3 }\nconst { a, ...x } = obj\nconst { a: data } = obj // 重命名\n\na // 1\nx // { b: 2, c: 3 }\n\ndata // 1\n```\n\n### 数组中的扩展运算符\n\n1. 浅拷贝\n\n```js\nconst arr = [1, 2, 3]\nconst cpArr = [...arr]\n\ncpArr // [1, 2, 3]\n```\n\n> 下面这种写法也是浅拷贝的变种:\n\n```js\nconst arr = [1, 2, 3]\nconst cpArr = []\n\ncpArr.push(...arr)\ncpArr // [1, 2, 3]\n```\n\n因为这个特性, 我们还可以合并数组, 如下所示:\n\n```js\nconst arr1 = [1, 2, 3]\nconst arr2 = [4, 5, 6]\n\nconst mergeArr = [...arr1, ...arr2]\n\nmergeArr // [1, 2, 3, 4, 5, 6]\n```\n\n2. 解构赋值\n\n```js\n[a, ...b] = [1, 2, 3]\n\na // 1\nb // [2, 3]\n```\n\n> 扩展运算符用来做解构赋值时, 只能放在最后一位\n\n3. 传参中使用, 将所传的参数变为数组\n\n```js\nfunction Demo(...args) {\n  console.log(args)\n}\n\nDemo(1, 2, 3) // [1, 2, 3]\n```\n\n### 相关链接\n\n* [对象扩展符简易指南](https://www.zcfy.cc/article/an-easy-guide-to-object-rest-spread-properties-in-javascript)"}}]);