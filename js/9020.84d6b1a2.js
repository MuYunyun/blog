(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9020],{29020:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>h});var r=t(59713),a=t.n(r),p=t(6479),l=t.n(p),u=(t(67294),t(3905));function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){a()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var s={};function h(n){var e=n.components,t=l()(n,["components"]);return(0,u.kt)("wrapper",o(o(o({},s),t),{},{components:e,mdxType:"MDXLayout"}),(0,u.kt)("h3",null,"图"),(0,u.kt)("p",null,"图是一种",(0,u.kt)("inlineCode",{parentName:"p"},"非线性数据结构"),"。它的表示有以下几种:"),(0,u.kt)("ol",null,(0,u.kt)("li",{parentName:"ol"},"邻接矩阵"),(0,u.kt)("li",{parentName:"ol"},"邻接表"),(0,u.kt)("li",{parentName:"ol"},"关联矩阵")),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"邻接矩阵"))),(0,u.kt)("p",null,"邻接矩阵是表示图的常用方法, ",(0,u.kt)("inlineCode",{parentName:"p"},"用二维数组来表示"),", 数组的每个下标对应每个点。当两个点有连线则二维数组的值为 1, 否则二维数组的值为 0。但是这种表示方法会照成存储空间的浪费(因存在大量 0)。"),(0,u.kt)("p",null,(0,u.kt)("img",o({parentName:"p"},{src:"http://with.muyunyun.cn/79f5520b6028aa16491649c846430b04.jpg-300",alt:null}))),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"邻接表"))),(0,u.kt)("p",null,"如下图: ",(0,u.kt)("inlineCode",{parentName:"p"},"左侧为存储的顶点, 右侧为与之想对应的点"),", 后文会采用这种方式实现图。"),(0,u.kt)("p",null,(0,u.kt)("img",o({parentName:"p"},{src:"http://with.muyunyun.cn/0a1d5ab4a96e83dca8c7aafc948e2f4b.jpg-300",alt:null}))),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"关联矩阵"))),(0,u.kt)("p",null,"行表示点, 列表示边。"),(0,u.kt)("p",null,(0,u.kt)("img",o({parentName:"p"},{src:"http://with.muyunyun.cn/48a4bf7ee32827ad4d9016f24a8ffca5.jpg-300",alt:null}))),(0,u.kt)("pre",null,(0,u.kt)("code",o({parentName:"pre"},{className:"language-js"}),"function Graph() {\n  this.topPointArr = []    // 存储顶点, 笔者认为图的顶点是不会重复的\n  this.edgeMap = new Map() // 存储边\n}\n\n// 往图里添加顶点\nGraph.prototype.addTopPoint = function(point) {\n  this.topPointArr.push(point)\n  this.edgeMap.set(point, [])\n}\n\n// 往指定的点添加相邻的点\nGraph.prototype.addEdge = function(point1, point2) {\n  this.edgeMap.get(point1).push(point2)\n  this.edgeMap.get(point2).push(point1) // 这里默认没有方向, 所以两个点互相指向\n}\n\n// 将图给打印出来\nGraph.prototype.log = function() {\n  let str = ''\n  let neighbour\n  for (let i of this.topPointArr) {\n    str += i + ' -> '\n    neighbour = this.edgeMap.get(i).join(' ')\n    str += neighbour + '\\n'\n  }\n  return str\n}\n")),(0,u.kt)("p",null,"按之前邻接表的图示, 跑如下测试用例:"),(0,u.kt)("pre",null,(0,u.kt)("code",o({parentName:"pre"},{className:"language-js"}),"var graph = new Graph()\nvar topArr = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']\nfor (let i of topArr) {\n  graph.addTopPoint(i)\n}\n\ngraph.addEdge('A', 'B')\ngraph.addEdge('A', 'C')\ngraph.addEdge('A', 'D')\ngraph.addEdge('B', 'E')\ngraph.addEdge('B', 'F')\ngraph.addEdge('C', 'D')\ngraph.addEdge('C', 'G')\ngraph.addEdge('D', 'G')\ngraph.addEdge('D', 'H')\ngraph.addEdge('E', 'I')\n")),(0,u.kt)("p",null,"使用自定义打印函数 graph.log(), 打印结果如下, 结果符合预期"),(0,u.kt)("pre",null,(0,u.kt)("code",o({parentName:"pre"},{className:"language-js"}),"A -> B C D\nB -> A E F\nC -> A D G\nD -> A C G H\nE -> B I\nF -> B\nG -> C D\nH -> D\nI -> E\n")),(0,u.kt)("h3",null,"广度优先遍历(BFS)"),(0,u.kt)("p",null,"顾名思义, 广度优先即横向优先, 英文名为 ",(0,u.kt)("inlineCode",{parentName:"p"},"breadth first search"),"(BFS), 它示意图如下:"),(0,u.kt)("p",null,(0,u.kt)("img",o({parentName:"p"},{src:"http://with.muyunyun.cn/4547193af1645f33359e875559092c6b.jpg-200",alt:null}))),(0,u.kt)("p",null,"思想: 用到了",(0,u.kt)("inlineCode",{parentName:"p"},"队列"),"的思想。思路如下: (标白: 未发现; 标灰: 已找寻)"),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},"创建队列 u, 将标灰的顶点插入队列;"),(0,u.kt)("li",{parentName:"ul"},"若队列 u 不为空;",(0,u.kt)("ul",{parentName:"li"},(0,u.kt)("li",{parentName:"ul"},"从队列取出值 v;"),(0,u.kt)("li",{parentName:"ul"},"将 v 的相邻节点标灰并插入队列 u;")))),(0,u.kt)("p",null,"代码中用到队列相关的方法可参考 ",(0,u.kt)("a",o({parentName:"p"},{href:"https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/%E9%98%9F%E5%88%97.md"}),"队列")),(0,u.kt)("details",null,(0,u.kt)("summary",null,"Queue实现"),(0,u.kt)("pre",null,(0,u.kt)("code",o({parentName:"pre"},{className:"language-js"}),"function Queue() {\n  this.items = []\n}\n\nQueue.prototype.push = function(item) {\n  this.items.push(item)\n}\n\nQueue.prototype.shift = function() {\n  return this.items.shift()\n}\n\nQueue.prototype.isEmpty = function() {\n  return this.items.length === 0\n}\n\nQueue.prototype.size = function() {\n  return this.items.length\n}\n\nQueue.prototype.clear = function() {\n  this.items = []\n}\n"))),(0,u.kt)("pre",null,(0,u.kt)("code",o({parentName:"pre"},{className:"language-js"}),"Graph.prototype.bfs = function(v, callback) {\n  const obj = {}\n\n  for (let i of this.topPointArr) { // 初始化颜色\n    obj[i] = 'white'\n  }\n\n  const queue = new Queue()\n  obj[v] = 'gray'\n\n  queue.push(v)\n\n  let shiftQueue, neighbour\n\n  while (!queue.isEmpty()) {\n    shiftQueue = queue.shift()\n    neighbour = this.edgeMap.get(shiftQueue)\n\n    for (let i of neighbour) {\n      if (obj[i] === 'white') {\n        obj[i] = 'gray'\n        queue.push(i)\n      }\n    }\n\n    if (callback) {\n      callback(shiftQueue)\n    }\n  }\n}\n")),(0,u.kt)("p",null,"检验完成的 bfs 函数, 进行如下调用,"),(0,u.kt)("pre",null,(0,u.kt)("code",o({parentName:"pre"},{className:"language-js"}),"graph.bfs('A', (shiftQueue) => {\n  console.log(shiftQueue)\n})\n")),(0,u.kt)("p",null,"打印结果为 ",(0,u.kt)("inlineCode",{parentName:"p"},"A B C D E F G H I"),", 符合预期。"),(0,u.kt)("h4",null,"广度优先遍历求最短路径"),(0,u.kt)("p",null,"在上述 bfs 函数实现的基础上, 加入两个变量分别存储距离以及最短路径上先前的点"),(0,u.kt)("pre",null,(0,u.kt)("code",o({parentName:"pre"},{className:"language-js"}),"Graph.prototype.BFS = function(v) {\n  const obj = {}\n\n  const d = {}    // 新加入的变量存储距离\n  const prev = {} // 新加入的变量存储最短路径上先前的点\n\n  for (let i of this.topPointArr) { // 初始化颜色\n    obj[i] = 'white'\n    d[i] = 0\n    prev[i] = null\n  }\n\n  const queue = new Queue()\n  obj[v] = 'gray'\n\n  queue.push(v)\n\n  let shiftQueue, neighbour\n\n  while (!queue.isEmpty()) {\n    shiftQueue = queue.shift()\n    neighbour = this.edgeMap.get(shiftQueue)\n\n    for (let i of neighbour) {\n      if (obj[i] === 'white') {\n        obj[i] = 'gray'\n        queue.push(i)\n        d[i] = d[shiftQueue] + 1  // 这个地方卡主了~~~, 思路: 第二行的点距离第一行的点相差为 1, 第三行的点距离第二行的点相差为 1, 以此类推。\n        prev[i] = shiftQueue\n      }\n    }\n  }\n\n  return {\n    distance: d,\n    prev: prev\n  }\n}\n")),(0,u.kt)("p",null,"调用 ",(0,u.kt)("inlineCode",{parentName:"p"},"graph.BFS('A')"),", 得如下结果:"),(0,u.kt)("pre",null,(0,u.kt)("code",o({parentName:"pre"},{className:"language-js"}),'{\n  distance: { A: 0, B: 1, C: 1, D: 1, E: 2, F: 2, G: 2, H: 2, I: 3 }\n  prev: { A: null, B: "A", C: "A", D: "A", E: "B", F: "B", G: "C", H: "D", I: "E" }\n}\n')),(0,u.kt)("p",null,"接下来我们处理上述返回的 prev 将最短路径打印出来:"),(0,u.kt)("pre",null,(0,u.kt)("code",o({parentName:"pre"},{className:"language-js"}),"Graph.prototype.logMinPath = function(v) {\n  const { distance, prev } = this.BFS(v)\n  let path = ''\n  const arr = []\n  Object.keys(distance).map(r => {\n    path = r\n    while (prev[r]) { // 终止条件为 prev 中值为 null 时\n      path = prev[r] + ' - ' + path\n      r = prev[r]\n    }\n    arr.push(path)\n  })\n  return arr.join('\\n')\n}\n")),(0,u.kt)("p",null,"调用 ",(0,u.kt)("inlineCode",{parentName:"p"},"graph.logMinPath('A')"),", 打印结果如下:"),(0,u.kt)("pre",null,(0,u.kt)("code",o({parentName:"pre"},{}),"A\nA - B\nA - C\nA - D\nA - B - E\nA - B - F\nA - C - G\nA - D - H\nA - B - E - I\n")),(0,u.kt)("h3",null,"深度优先遍历(DFS)"),(0,u.kt)("p",null,"深度优先遍历用到了栈的思想。英文名为 ",(0,u.kt)("inlineCode",{parentName:"p"},"depth first search"),"(DFS), 其示意图如下:"),(0,u.kt)("p",null,(0,u.kt)("img",o({parentName:"p"},{src:"http://with.muyunyun.cn/b4fa9641c9f086cf2702f868b283dbee.jpg-200",alt:null}))),(0,u.kt)("p",null,"代码实现如下:"),(0,u.kt)("pre",null,(0,u.kt)("code",o({parentName:"pre"},{className:"language-js"}),"Graph.prototype.dfs = function (v, callback) {\n  const obj = {}\n\n  for (let i of this.topPointArr) { // 初始化颜色\n    obj[i] = 'white'\n  }\n\n  let neighbour\n  const that = this\n  const find = function (v, color, cb) {\n    color[v] = 'gred'\n    if (cb) {\n      cb(v)\n    }\n    neighbour = that.edgeMap.get(v)\n    for (let i of neighbour) {\n      if (color[i] === 'white') {\n        find(i, color, cb)\n      }\n    }\n  }\n\n  find(v, obj, callback)\n}\n")),(0,u.kt)("p",null,"进行如下函数调用"),(0,u.kt)("pre",null,(0,u.kt)("code",o({parentName:"pre"},{className:"language-js"}),"graph.dfs('A', (shiftQueue) => {\n  console.log(shiftQueue)  // 打印结果: A B E I F C D G H\n})\n")))}h.isMDXComponent=!0}}]);