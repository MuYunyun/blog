(self.webpackChunkblog=self.webpackChunkblog||[]).push([[688],{10688:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>d});var l=t(59713),r=t.n(l),a=t(6479),u=t.n(a),i=(t(67294),t(3905));function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(n);e&&(l=l.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,l)}return t}function p(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){r()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var s={};function d(n){var e=n.components,t=u()(n,["components"]);return(0,i.kt)("wrapper",p(p(p({},s),t),{},{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h3",null,"Reverse Nodes in k-Group"),(0,i.kt)("p",null,"Given a linked list, reverse the nodes of a linked list k at a time and return its modified list."),(0,i.kt)("p",null,"k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("p",null,"Given this linked list: 1->2->3->4->5"),(0,i.kt)("p",null,"For k = 2, you should return: 2->1->4->3->5"),(0,i.kt)("p",null,"For k = 3, you should return: 3->2->1->4->5"),(0,i.kt)("p",null,"Note:"),(0,i.kt)("p",null,"Only constant extra memory is allowed.\nYou may not alter the values in the list's nodes, only nodes itself may be changed."),(0,i.kt)("h3",null,"Analyze"),(0,i.kt)("p",null,"初始分析:"),(0,i.kt)("p",null,"每间隔 k 个值进行链表反转, 目前的思考是替换链表的同时维护一个 count, count 达到 k 以后 count 清 0, 同时根据 count 是否达到 k 来判断当前组列表的下一组列表是指向原列表还是反转后的列表, 但是这样的思路需要额外的内存来存储下一组列表。有没有更好的方法呢?"),(0,i.kt)("p",null,"参考网友的 ",(0,i.kt)("inlineCode",{parentName:"p"},"尾插法")," 思路。"),(0,i.kt)("p",null,"① 将 tail 移到要翻转部分的最后一个元素, 若移动 k 元素之前已到达链表末尾则完成每间隔 k 个值的链表翻转;"),(0,i.kt)("p",null,"② 接着依次把 cur 移到 tail 后面;"),(0,i.kt)("p",null,"该方法的难点一个是如何确定 tail(尾巴) 节点, 另一个是如何穿针引线将 cur 节点移到 tail 节点后面。(这题卡了好久","[OMG]",")"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"k === 3\n\nprev\ntail   head1\ndummy    1     2     3     4     5\n\nprev   head1        tail\ndummy    1     2     3     4     5\n          cur\n\nprev          tail head1\ndummy    2     3    1     4     5\n          cur\n\nprev    tail       head1\ndummy    3     2    1     4     5\n            cur\n")),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar reverseKGroup = function(head, k) {\n  const dummyHead = new ListNode(0)\n  dummyHead.next = head\n  let prev = dummyHead\n  let tail = dummyHead\n\n  while (true) {\n    let count = 0\n    while (tail.next && count !== k) {\n      tail = tail.next\n      count++\n    }\n    if (count !== k) break\n\n    let head1 = prev.next\n\n    while (prev.next !== tail) {\n      let cur = prev.next\n      prev.next = cur.next\n      cur.next = tail.next\n      tail.next = cur\n    }\n\n    prev = head1\n    tail = head1\n  }\n\n  return dummyHead.next\n}\n")),(0,i.kt)("p",null,(0,i.kt)("img",p({parentName:"p"},{src:"http://with.muyunyun.cn/27da17a1a3c81ffe4aa6beefaef0de18.jpg",alt:null}))))}d.isMDXComponent=!0}}]);