(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9614],{19614:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>m});var u=t(59713),r=t.n(u),l=t(6479),a=t.n(l),p=(t(67294),t(3905));function c(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var u=Object.getOwnPropertySymbols(n);e&&(u=u.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,u)}return t}function s(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?c(Object(t),!0).forEach((function(e){r()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var o={};function m(n){var e=n.components,t=a()(n,["components"]);return(0,p.kt)("wrapper",s(s(s({},o),t),{},{components:e,mdxType:"MDXLayout"}),(0,p.kt)("h3",null,"题目"),(0,p.kt)("p",null,"给定一个",(0,p.kt)("inlineCode",{parentName:"p"},"排序数组"),", 你需要",(0,p.kt)("inlineCode",{parentName:"p"},"在原地删除重复出现的元素, 使得每个元素只出现一次, 返回移除后数组的新长度"),"。"),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"不要使用额外的数组空间, 你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成"),"。"),(0,p.kt)("p",null,"示例 1:"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-js"}),"给定数组 nums = [1,1,2],\n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。\n\n你不需要考虑数组中超出新长度后面的元素。\n")),(0,p.kt)("p",null,"示例 2:"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-js"}),"给定 nums = [0,0,1,1,1,2,2,3,3,4],\n\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n\n你不需要考虑数组中超出新长度后面的元素。\n")),(0,p.kt)("p",null,"说明:"),(0,p.kt)("p",null,"为什么返回数值是整数, 但输出的答案是数组呢?"),(0,p.kt)("p",null,"请注意, 输入数组是以“引用”方式传递的, 这意味着在函数里修改输入数组对于调用者是可见的。"),(0,p.kt)("p",null,"你可以想象内部操作如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-js"}),"// nums 是以“引用”方式传递的。也就是说, 不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n")),(0,p.kt)("h3",null,"解题"),(0,p.kt)("p",null,"解法一: 一般思路"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function (nums) {\n  const cacheObj = {}\n  let count = 0\n  while (count < nums.length) {\n    if (cacheObj[nums[count]]) {\n      nums.splice(count, 1)\n      count--\n    } else {\n      cacheObj[nums[count]] = nums[count].toString() // 防止 0 被判断为 false\n    }\n    count++\n  }\n  return nums.length\n}\n")),(0,p.kt)("p",null,"解法二: 双指针"),(0,p.kt)("p",null,(0,p.kt)("img",s({parentName:"p"},{src:"http://with.muyunyun.cn/d3b1ba4aff45282b1ae4740d530c8834.jpg",alt:null}))),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function (nums) {\n  if (nums.length <= 1) return nums.length\n  let cur = 0 // 新数组的下标\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] !== nums[cur]) {\n      nums[cur + 1] = nums[i]\n      cur++\n    }\n  }\n  return cur + 1\n}\n")),(0,p.kt)("h3",null,"同类题目"),(0,p.kt)("p",null,"27、80、283。"))}m.isMDXComponent=!0}}]);