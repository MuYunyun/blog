(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2335],{92335:n=>{n.exports="### Heap\n\n堆是通过一维数组来实现的树结构。\n\n### 堆节点的访问\n\n在数组起始位置为 0 的情形中:\n\n* 父节点 i 的左子节点在位置 `(2i + 1)`;\n* 父节点 i 的右子节点在位置 `(2i + 2)`;\n* 子节点 i 的父节点在位置 `Math.floor((i - 1) / 2)`;\n\n### Max Heap && Min Heap\n\n* `Max Heap`: 每个节点都`大于等于左右子节点`的值。用于`升序排序`。见 [heap_sort](https://github.com/MuYunyun/blog/blob/master/Algorithm/algorithm/sort/heap_sort.md)\n\n```js\n           8\n        ↙     ↘\n     3          7\n  ↙    ↘      ↙   ↘\n2        1  5        4\n```\n\n* `Min Heap`: 每个节点都`小于等于左右子节点`的值。用于`降序排序`。\n\n```js\n          1\n        ↙    ↘\n      2        4\n   ↙    ↘    ↙   ↘\n  5       3 8      7\n```\n\n### Priority Queue Based Heap\n\nIt's usually to use the two ways called enqueue and dequeue:\n\n* `enqueue(value)`: insert value into the heap;\n  * Because the value is inserted into the last heap, we'll use `sift up` to adjust position;\n\n```js\n           10\n        ↙     ↘\n     3          7\n           |\n           ↓\n      `enqueue(9)`\n           10\n        ↙     ↘\n     3          7\n  ↙ sift up\n9\n           |\n           ↓\n           10\n        ↙     ↘\n     9          7\n  ↙ sift up\n3\n```\n\n* `dequeue()`: to pick the smallest or the biggest element from the heap;\n  * It'll swap the endest element with the first element, and then keep the heap length reduce 1. If so, only do once `sift down` operation in the first element to heapify.\n\n```js\n           8\n        ↙     ↘\n     3          7\n  ↙    ↘      ↙   ↘\n2        1  5       4\n          |\n  pick 8, move 4 to top\n          ↓\n\n           4\n        ↙     ↘ (swap)\n     3          7\n  ↙    ↘      ↙\n2        1  5\n          |\n  sift down 4 to rebuild max heap.\n          ↓\n\n           7\n        ↙     ↘\n     3          4\n  ↙    ↘      ↙\n2        1  5\n          |\n  redo the last steps\n          ↓\n           7\n        ↙     ↘\n     3          5\n  ↙    ↘      ↙\n2        1  4\n```\n\n```js\nvar len\n\n/**\n * to build max heapify from bottom to top;\n * the last subscript's parent subscript is Math.floor((len - 1) / 2)\n */\nvar buildMaxHeapify = function(arr) {\n  len = arr.length\n\n  for (let i = Math.floor((len - 1) / 2); i >= 0; i--) {\n    siftDown(arr, i)\n  }\n  return arr\n}\n\n/**\n * Insert a value into heap. It's an operation called sift up.\n */\nvar enqueue = function(arr, value) {\n  arr.splice(len, 0, value)\n  len++\n  siftUp()\n}\n\n/**\n * to keep max heap, it's an operation called sift up.\n */\nvar siftUp = function() {\n  let enqueueValSubscript = len - 1\n  let parent = Math.floor(enqueueValSubscript / 2)\n  while (parent > 0 && arr[parent] < arr[enqueueValSubscript]) {\n    swap(arr, parent, enqueueValSubscript)\n    enqueueValSubscript = parent\n    parent = Math.floor(enqueueValSubscript / 2)\n  }\n}\n\n/*\n * to pick the smallest or the biggest element from the heap and return it;\n * Then t'll swap the endest element with the first element, and then keep the\n * heap length reduce one. If so, only do once sift down operation in the first element to keep heapify.\n */\nvar dequeue = function() {\n  const maxValue = arr[0]\n  swap(arr, len - 1, 0)\n  len--\n  siftDown(arr, 0)\n  return maxValue\n}\n\n/**\n * to keep max heap, it's an operation called sift down.\n */\nvar siftDown = function(arr, i) {\n  const left = 2 * i + 1\n  const right = 2 * i + 2\n  let maxSubscript = i\n\n  if (left < len && arr[left] > arr[maxSubscript]) {\n    maxSubscript = left\n  }\n\n  if (right < len && arr[right] > arr[maxSubscript]) {\n    maxSubscript = right\n  }\n\n  if (maxSubscript !== i) {\n    swap(arr, maxSubscript, i)\n    siftDown(arr, maxSubscript)\n  }\n}\n\n// swap two value in arr\nvar swap = function(arr, pointOne, pointTwo) {\n  const tmp = arr[pointOne]\n  arr[pointOne] = arr[pointTwo]\n  arr[pointTwo] = tmp\n}\n```\n\nTest case one:\n\n```js\ninput: var arr = [5, 2, 7, 3, 1, 8, 4]\n\nbuildMaxHeapify(arr) // [8, 3, 7, 2, 1, 5, 4]\n           8                                           8\n        ↙     ↘          enqueue(arr, 6)            ↙     ↘\n     3          7        ---------------\x3e         6          7\n  ↙    ↘      ↙   ↘                            ↙    ↘      ↙   ↘\n2        1  5       4                        3        1   5       4\n                                           ↙\n                                         2\n\n                                     7\n        return 8                  ↙     ↘\n        dequeue()               6         5\n    ----------------\x3e        ↙    ↘     ↙   ↘\n                           3       1   2      4\n```\n"}}]);