(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6782],{96782:(n,t,e)=>{"use strict";e.r(t),e.d(t,{default:()=>a});var u=e(59713),o=e.n(u),r=e(6479),l=e.n(r),c=(e(67294),e(3905));function s(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var u=Object.getOwnPropertySymbols(n);t&&(u=u.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,u)}return e}function i(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?s(Object(e),!0).forEach((function(t){o()(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):s(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}var p={};function a(n){var t=n.components,e=l()(n,["components"]);return(0,c.kt)("wrapper",i(i(i({},p),e),{},{components:t,mdxType:"MDXLayout"}),(0,c.kt)("h3",null,"题目"),(0,c.kt)("p",null,"给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。"),(0,c.kt)("p",null,"此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。"),(0,c.kt)("p",null,"注意:"),(0,c.kt)("p",null,"不能使用代码库中的排序函数来解决这道题。"),(0,c.kt)("p",null,"示例:"),(0,c.kt)("pre",null,(0,c.kt)("code",i({parentName:"pre"},{className:"language-js"}),"输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]\n")),(0,c.kt)("p",null,"进阶:"),(0,c.kt)("p",null,"一个直观的解决方案是使用计数排序的两趟扫描算法。\n首先，迭代计算出 0、1 和 2 元素的个数，然后按照 0、1、2 的排序，重写当前数组。\n你能想出一个仅使用常数空间的一趟扫描算法吗？"),(0,c.kt)("h3",null,"解题"),(0,c.kt)("p",null,"解法一: 计数排序, 在该题目中分别统计出 0、1、2 出现的个数, 并将相应个数的 0、1、2 放回数组。"),(0,c.kt)("blockquote",null,(0,c.kt)("p",{parentName:"blockquote"},"计数排序适用于数组元素非常有限的场景。")),(0,c.kt)("pre",null,(0,c.kt)("code",i({parentName:"pre"},{className:"language-js"}),"输入\n[2,0,2,1,1,0]\n输出\n[0,1,2,1,1,0]\n预期结果\n[0,0,1,1,2,2]\n")),(0,c.kt)("pre",null,(0,c.kt)("code",i({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar sortColors = function (nums) {\n  let countObj = {}\n  for (let i = 0; i < nums.length; i++) {\n    const key = nums[i]\n    if (typeof(countObj[`${key}`]) === 'number') {\n      countObj[`${key}`] = countObj[`${key}`] + 1\n    } else {\n      countObj[`${key}`] = 1\n    }\n  }\n\n  const count0 = countObj[0] || 0\n  const count1 = countObj[1] || 0\n  const count2 = countObj[2] || 0\n  for (let i = 0; i < count0 + count1 + count2; i++) {\n    if (i < count0) {\n      nums[i] = 0\n    } else if (i >=count0 && i < count0 + count1) {\n      nums[i] = 1\n    } else if (i >= count1 && i < count0 + count1 + count2) {\n      nums[i] = 2\n    }\n  }\n}\n")),(0,c.kt)("p",null,"解法二: 三路快排"),(0,c.kt)("p",null,"思路: 三路快排的思想是同时排序小于选定值，等于选定值和大于选定值三种情况。在这里我们随机选取一个值 v 作为分界点, 分别排序小于 v，等于 v 和大于 v 的。该题中 v 为 1。"),(0,c.kt)("p",null,(0,c.kt)("img",i({parentName:"p"},{src:"http://with.muyunyun.cn/9617f034f2e7d0535ac73d51612d2f07.jpg",alt:null}))),(0,c.kt)("pre",null,(0,c.kt)("code",i({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar sortColors = function (nums) {\n  /**\n   * nums[0, zero] = 0\n   * nums[two, nums.length - 1] = 2\n   */\n  let [zero, two] = [0, nums.length - 1]\n  for (let i = 0; i <= two; i++) {\n    if (nums[i] === 0) {\n      [nums[i], nums[zero]] = [nums[zero], nums[i]]\n      zero++\n    }\n\n    if (nums[i] === 2) {\n      [nums[i], nums[two]] = [nums[two], nums[i]]\n      i--\n      two--\n    }\n  }\n}\n")),(0,c.kt)("p",null,"该算法的时间复杂度为 O(n), 空间复杂度为 O(1)。"),(0,c.kt)("h3",null,"镜像题目"),(0,c.kt)("p",null,"88、215"))}a.isMDXComponent=!0}}]);