(self.webpackChunkblog=self.webpackChunkblog||[]).push([[602],{60602:(t,r,e)=>{"use strict";e.r(r),e.d(r,{default:()=>i});var n=e(59713),a=e.n(n),p=e(6479),s=e.n(p),l=(e(67294),e(3905));function o(t,r){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(t,r).enumerable}))),e.push.apply(e,n)}return e}function c(t){for(var r=1;r<arguments.length;r++){var e=null!=arguments[r]?arguments[r]:{};r%2?o(Object(e),!0).forEach((function(r){a()(t,r,e[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):o(Object(e)).forEach((function(r){Object.defineProperty(t,r,Object.getOwnPropertyDescriptor(e,r))}))}return t}var u={};function i(t){var r=t.components,e=s()(t,["components"]);return(0,l.kt)("wrapper",c(c(c({},u),e),{},{components:r,mdxType:"MDXLayout"}),(0,l.kt)("h3",null,"title"),(0,l.kt)("p",null,"给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。"),(0,l.kt)("p",null,"这里的「遵循」指完全匹配，例如 pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。"),(0,l.kt)("p",null,"示例 1:"),(0,l.kt)("pre",null,(0,l.kt)("code",c({parentName:"pre"},{className:"language-js"}),'输入: pattern = "abba", str = "dog cat cat dog"\n输出: true\n')),(0,l.kt)("p",null,"示例 2:"),(0,l.kt)("pre",null,(0,l.kt)("code",c({parentName:"pre"},{className:"language-js"}),'输入:pattern = "abba", str = "dog cat cat fish"\n输出: false\n')),(0,l.kt)("p",null,"示例 3:"),(0,l.kt)("pre",null,(0,l.kt)("code",c({parentName:"pre"},{className:"language-js"}),'输入: pattern = "aaaa", str = "dog cat cat dog"\n输出: false\n')),(0,l.kt)("p",null,"示例 4:"),(0,l.kt)("pre",null,(0,l.kt)("code",c({parentName:"pre"},{className:"language-js"}),'输入: pattern = "abba", str = "dog dog dog dog"\n输出: false\n')),(0,l.kt)("p",null,"说明:\n你可以假设 pattern 只包含小写字母，str 包含了由单个空格分隔的小写字母。    "),(0,l.kt)("h3",null,"解题"),(0,l.kt)("p",null,"思路:"),(0,l.kt)("p",null,"使用 patternMap 与 strArrMap 分别存储 ",(0,l.kt)("inlineCode",{parentName:"p"},"pattern => strArrMap")," 与 ",(0,l.kt)("inlineCode",{parentName:"p"},"strArrMap => pattern")," 的映射, 当存在一对多映射的情况时, 则它们非完全匹配, 否则是完全匹配的。"),(0,l.kt)("pre",null,(0,l.kt)("code",c({parentName:"pre"},{className:"language-js"}),"/**\n * @param {string} pattern\n * @param {string} str\n * @return {boolean}\n */\nvar wordPattern = function(pattern, str) {\n  const strArr = str.split(' ')\n  if (pattern.length !== strArr.length) return false\n\n  const patternMap = new Map()\n  const strArrMap = new Map()\n\n  for (let i = 0; i < pattern.length; i++) {\n    const getPatternMap = patternMap.get(pattern[i])\n    const getStrArrMap = strArrMap.get(strArr[i])\n    if (!getPatternMap) {\n      patternMap.set(pattern[i], strArr[i])\n    } else if (getPatternMap !== strArr[i]) {\n      return false\n    }\n\n    if (!getStrArrMap) {\n      strArrMap.set(strArr[i], pattern[i])\n    } else if (getStrArrMap !== pattern[i]) {\n      return false\n    }\n  }\n\n  return true\n};\n")),(0,l.kt)("h3",null,"相关题目"),(0,l.kt)("p",null,"202、205、242、349、350、451"))}i.isMDXComponent=!0}}]);