(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9173],{99173:(n,t,e)=>{"use strict";e.r(t),e.d(t,{default:()=>k});var r=e(59713),l=e.n(r),a=e(6479),u=e.n(a),p=(e(67294),e(3905));function o(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,r)}return e}function i(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?o(Object(e),!0).forEach((function(t){l()(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):o(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}var s={};function k(n){var t=n.components,e=u()(n,["components"]);return(0,p.kt)("wrapper",i(i(i({},s),e),{},{components:t,mdxType:"MDXLayout"}),(0,p.kt)("h3",null,"215.Kth Largest Element in an Array"),(0,p.kt)("p",null,"在",(0,p.kt)("inlineCode",{parentName:"p"},"未排序的数组中"),"找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。"),(0,p.kt)("p",null,"示例 1:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-js"}),"输入: [3,2,1,5,6,4] 和 k = 2\n输出: 5\n")),(0,p.kt)("p",null,"示例 2:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-js"}),"输入: [3,2,3,1,2,4,5,5,6] 和 k = 4\n输出: 4\n")),(0,p.kt)("p",null,"说明:"),(0,p.kt)("p",null,"你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。"),(0,p.kt)("h3",null,"解题"),(0,p.kt)("p",null,"解法一: 排序。空间复杂度为 O(NlogN), 空间复杂度为 O(1)"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar findKthLargest = function(nums, k) {\n  nums.sort((r1, r2) => r2 - r1)\n  return nums[k - 1]\n}\n")),(0,p.kt)("blockquote",null,(0,p.kt)("p",{parentName:"blockquote"},"如果初始数据的元素个数不确定, 解法一就无法使用了, 这个时候适合使用解法二。")),(0,p.kt)("p",null,"解法二: 快速选择"),(0,p.kt)("p",null,"思路: 本方法大致上与快速排序相同。简便起见，注意到第 k 个最大元素也就是升序排序后下标为 ",(0,p.kt)("inlineCode",{parentName:"p"},"N - k")," 的元素。递归使用",(0,p.kt)("a",i({parentName:"p"},{href:"https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/%E5%88%92%E5%88%86%E7%AE%97%E6%B3%95.md"}),"划分算法"),"。"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"使用划分算法, 定义一个枢纽值, 并将其放到指定位置(小于该枢纽值的都在其左边, 大于该枢纽值的都在其右边);"),(0,p.kt)("li",{parentName:"ul"},"比较枢纽值的下标 position 与 N - k 的大小关系")),(0,p.kt)("p",null,(0,p.kt)("img",i({parentName:"p"},{src:"http://with.muyunyun.cn/503d3b6311c2f401a50bcdb5c57f0f52.jpg",alt:null}))),(0,p.kt)("blockquote",null,(0,p.kt)("p",{parentName:"blockquote"},"算法复杂度为 O(n)。计算: ",(0,p.kt)("inlineCode",{parentName:"p"},"n + (1/2) * n + (1/4) * n + ... + (1/2)^n * n"),", 经等比数列求和为 ",(0,p.kt)("inlineCode",{parentName:"p"},"2n - 2n / 2^n"),", 当 n 趋于无穷大时, 结果趋近为 2n。")),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar findKthLargest = function(nums, k) {\n  const length = nums.length\n  return quickSelect(0, length - 1, length - k, nums)\n}\n\nvar quickSelect = function(left, right, kthSmall, arr) {\n  const position = partition(arr, left, right)\n  if (position === kthSmall) {\n    return arr[position]\n  } else if (position < kthSmall) {\n    return quickSelect(position + 1, right, kthSmall, arr)\n  } else if (position > kthSmall) {\n    return quickSelect(left, position - 1, kthSmall, arr)\n  }\n}\n\n/* 分区算法 */\nfunction partition(nums, left, right) {\n  const pivot = nums[left] // 枢纽值\n  let pos = left           // 用来记住最后枢纽值 pivot 应该置于的位置\n  for (let i = left + 1; i <= right; i++) {\n    if (nums[i] < pivot) {\n      pos++\n      swap(nums, pos, i)\n    }\n  }\n  swap(nums, pos, left)\n  return pos\n}\n\n/* 交换位置\n  nums 数组, a, b 为下标\n*/\nvar swap = function(nums, a, b) {\n  const tmp = nums[a]\n  nums[a] = nums[b]\n  nums[b] = tmp\n}\n")),(0,p.kt)("h3",null,"镜像题目"),(0,p.kt)("p",null,"75"))}k.isMDXComponent=!0}}]);