(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5045],{95045:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>u});var r=t(59713),o=t.n(r),a=t(6479),c=t.n(a),p=(t(67294),t(3905));function s(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function i(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?s(Object(t),!0).forEach((function(e){o()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var l={};function u(n){var e=n.components,t=c()(n,["components"]);return(0,p.kt)("wrapper",i(i(i({},l),t),{},{components:e,mdxType:"MDXLayout"}),(0,p.kt)("h3",null,"ref"),(0,p.kt)("p",null,"在 react 中并不建议使用 ref 属性, 而应该尽量使用",(0,p.kt)("a",i({parentName:"p"},{href:"https://doc.react-china.org/docs/lifting-state-up.html"}),"状态提升"),", 但是 react 还是提供了 ref 属性赋予了开发者操作 dom 的能力, react 的 ref 有 ",(0,p.kt)("inlineCode",{parentName:"p"},"string"),"、",(0,p.kt)("inlineCode",{parentName:"p"},"callback"),"、",(0,p.kt)("inlineCode",{parentName:"p"},"createRef")," 三种形式, 分别如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-js"}),'// string 这种写法未来会被抛弃\nclass MyComponent extends Component {\n  componentDidMount() {\n    this.refs.myRef.focus()\n  }\n  render() {\n    return <input ref="myRef" />\n  }\n}\n\n// callback(比较通用)\nclass MyComponent extends Component {\n  componentDidMount() {\n    this.myRef.focus()\n  }\n  render() {\n    return <input ref={(ele) => {\n      this.myRef = ele\n    }} />\n  }\n}\n\n// react 16.3 增加, 其它 react-like 框架还没有同步\nclass MyComponent extends Component {\n  constructor(props) {\n    super(props)\n    this.myRef = React.createRef()\n  }\n  componentDidMount() {\n    this.myRef.current.focus()\n  }\n  render() {\n    return <input ref={this.myRef} />\n  }\n}\n')),(0,p.kt)("p",null,(0,p.kt)("a",i({parentName:"p"},{href:"https://zhuanlan.zhihu.com/p/40462264"}),"React ref 的前世今生")," 罗列了三种写法的差异, 下面对上述例子中的第二种写法(比较通用)进行实现。"),(0,p.kt)("p",null,"首先在 setAttribute 方法内补充上对 ref 的属性进行特殊处理,"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-js"}),"function setAttribute(dom, attr, value) {\n  ...\n  else if (attr === 'ref') {          // 处理 ref 属性\n    if (_.isFunction(value)) {\n      value(dom)\n    }\n  }\n  ...\n}\n")),(0,p.kt)("p",null,"针对这个例子中 ",(0,p.kt)("inlineCode",{parentName:"p"},"this.myRef.focus()")," 的 focus 属性需要异步处理, 因为调用 componentDidMount 的时候, 界面上还未添加 dom 元素。处理 renderComponent 函数:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-js"}),"function renderComponent(component) {\n  ...\n  else if (component && component.componentDidMount) {\n    defer(component.componentDidMount.bind(component))\n  }\n  ...\n}\n")),(0,p.kt)("p",null,"刷新页面, 可以发现 input 框已为选中状态。"),(0,p.kt)("p",null,(0,p.kt)("img",i({parentName:"p"},{src:"http://with.muyunyun.cn/d35589fbbff45a2437c6c13e24ba8058.jpg-200",alt:null}))),(0,p.kt)("p",null,"处理完普通元素的 ref 后, 再来处理下自定义组件的 ref 的情况。之前默认自定义组件上是没属性的, 现在只要针对自定义组件的 ref 属性做相应处理即可。稍微修改 vdomToDom 函数如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-js"}),"function vdomToDom(vdom) {\n  if (_.isFunction(vdom.nodeName)) { // 此时是自定义组件\n    ...\n    for (const attr in vdom.attributes) { // 处理自定义组件的 ref 属性\n      if (attr === 'ref' && _.isFunction(vdom.attributes[attr])) {\n        vdom.attributes[attr](component)\n      }\n    }\n    ...\n  }\n  ...\n}\n")),(0,p.kt)("p",null,"跑如下测试用例:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-js"}),"class A extends Component {\n  constructor() {\n    super()\n    this.state = {\n      count: 0\n    }\n    this.click = this.click.bind(this)\n  }\n\n  click() {\n    this.setState({\n      count: ++this.state.count\n    })\n  }\n\n  render() {\n    return <div>{this.state.count}</div>\n  }\n}\n\nclass B extends Component {\n  constructor() {\n    super()\n    this.click = this.click.bind(this)\n  }\n\n  click() {\n    this.A.click()\n  }\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.click}>加1</button>\n        <A ref={(e) => { this.A = e }} />\n      </div>\n    )\n  }\n}\n")),(0,p.kt)("p",null,"效果如下:"),(0,p.kt)("p",null,(0,p.kt)("img",i({parentName:"p"},{src:"http://with.muyunyun.cn/reactref%E6%B5%8B%E8%AF%951",alt:null}))),(0,p.kt)("h3",null,"React.forwardRef 使用场景"),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"React.forwardRef")," 后面跟一个 ",(0,p.kt)("inlineCode",{parentName:"p"},"render")," 函数。用法如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-js"}),"function HOCComponent(WrapComponent) {\n  return class extends React.Component {\n    render() {\n      const { ref, ...rest } = this.props\n      return <WrapComponent ref={ref} { ...rest } />\n    }\n  }\n}\n\n// 此时的 ref 指向的是, 高阶组件里包裹的 WrapComponent 组件。\nconst Demo = React.forwardRef((props, ref) => {\n  return <HOCComponent { ...props } ref={ref} />\n})\n")),(0,p.kt)("p",null,"使用场景: 需要引用高阶组件里的子组件节点的时候可以使用 ",(0,p.kt)("inlineCode",{parentName:"p"},"React.forwordRef")))}u.isMDXComponent=!0}}]);