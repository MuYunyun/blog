(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1429],{31429:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>d});var o=t(59713),r=t.n(o),a=t(6479),p=t.n(a),s=(t(67294),t(3905));function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var m={};function d(e){var n=e.components,t=p()(e,["components"]);return(0,s.kt)("wrapper",c(c(c({},m),t),{},{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h3",null,"组件即函数"),(0,s.kt)("p",null,"在上一篇 ",(0,s.kt)("a",c({parentName:"p"},{href:"https://github.com/MuYunyun/blog/issues/24"}),"JSX 和 Virtual DOM")," 中, 解释了 JSX 渲染到界面的过程并实现了相应代码, 代码调用如下所示:"),(0,s.kt)("pre",null,(0,s.kt)("code",c({parentName:"pre"},{className:"language-js"}),"import React from 'react'\nimport ReactDOM from 'react-dom'\n\nconst element = (\n  <div className=\"title\">\n    hello<span className=\"content\">world!</span>\n  </div>\n)\n\nReactDOM.render(\n  element,\n  document.getElementById('root')\n)\n")),(0,s.kt)("p",null,"本小节, 我们接着探究组件渲染到界面的过程。在此我们引入组件的概念, ",(0,s.kt)("inlineCode",{parentName:"p"},"组件本质上就是一个函数"),", 如下就是一段标准组件代码:"),(0,s.kt)("pre",null,(0,s.kt)("code",c({parentName:"pre"},{className:"language-jsx"}),"import React from 'react'\n\n// 写法 1:\nclass A {\n  render() {\n    return <div>I'm componentA</div>\n  }\n}\n\n// 写法 2: 无状态组件\nconst A = () => <div>I'm componentA</div>\n\nReactDOM.render(<A />, document.body)\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},'<A name="componentA" />')," 是 JSX 的写法, 和",(0,s.kt)("a",c({parentName:"p"},{href:"https://github.com/MuYunyun/blog/issues/24"}),"上一篇"),"同理, babel 将其转化为 React.createElement() 的形式, ",(0,s.kt)("a",c({parentName:"p"},{href:"https://babeljs.io/en/repl#?babili=false&browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=MYGwhgzhAECC0FMAeAXBA7AJjAwgewFsAHPdDFaAbwCgBIAJw0wXoAoBKKuhhFAV3rpoAHkwBLAG4A-AJIByAlRQALMRAB0ReniIb0YAggC-wgPTjpAbjpHqt6sPj7DAXgBEwQiTLoUsN9CmUtRAA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&sourceType=module&lineWrap=true&presets=react&prettier=false&targets=&version=6.26.0&envVersion="}),"转化结果"),"如下所示:"),(0,s.kt)("pre",null,(0,s.kt)("code",c({parentName:"pre"},{className:"language-js"}),"React.createElement(A, null)\n")),(0,s.kt)("p",null,"可以看到当 JSX 中是自定义组件的时候, createElement 后接的第一个参数变为了函数, 在 ",(0,s.kt)("a",c({parentName:"p"},{href:"https://preactjs.com/repl"}),"repl")," 打印 ",(0,s.kt)("inlineCode",{parentName:"p"},'<A name="componentA" />'),", 结果如下:"),(0,s.kt)("pre",null,(0,s.kt)("code",c({parentName:"pre"},{}),"{\n  attributes: undefined,\n  children: [],\n  key: undefined,\n  nodeName: ƒ A()\n}\n")),(0,s.kt)("p",null,"注意这时返回的 Virtual DOM 中的 nodeName 也变为了函数。根据这些线索, 我们对之前的 ",(0,s.kt)("inlineCode",{parentName:"p"},"render")," 函数进行改造。"),(0,s.kt)("pre",null,(0,s.kt)("code",c({parentName:"pre"},{className:"language-js"}),"function render(vdom, container) {\n  if (_.isFunction(vdom.nodeName)) { // 如果 JSX 中是自定义组件\n    let component, returnVdom\n    if (vdom.nodeName.prototype.render) {\n      component = new vdom.nodeName()\n      returnVdom = component.render()\n    } else {\n      returnVdom = vdom.nodeName() // 针对无状态组件: const A = () => <div>I'm componentsA</div>\n    }\n    render(returnVdom, container)\n    return\n  }\n}\n")),(0,s.kt)("p",null,"至此, 我们完成了对组件的处理逻辑。"),(0,s.kt)("h3",null,"props 和 state 的实现"),(0,s.kt)("p",null,"在上个小节组件 A 中, 是没有引入任何属性和状态的, 我们希望组件间能进行属性的传递(props)以及组件内能进行状态的记录(state)。"),(0,s.kt)("pre",null,(0,s.kt)("code",c({parentName:"pre"},{className:"language-jsx"}),"import React, { Component } from 'react'\n\nclass A extends Component {\n  render() {\n    return <div>I'm {this.props.name}</div>\n  }\n}\n\nReactDOM.render(<A name=\"componentA\" />, document.body)\n")),(0,s.kt)("p",null,"在上面这段代码中, 看到 A 函数继承自 Component。我们来构造这个父类 Component, 并在其添加 state、props、setState 等属性方法, 从而让子类继承到它们。"),(0,s.kt)("pre",null,(0,s.kt)("code",c({parentName:"pre"},{className:"language-js"}),"function Component(props) {\n  this.props = props\n  this.state = this.state || {}\n}\n")),(0,s.kt)("p",null,"首先, 我们将组件外的 props 传进组件内, 修改 render 函数中以下代码:"),(0,s.kt)("pre",null,(0,s.kt)("code",c({parentName:"pre"},{className:"language-js"}),"function render(vdom, container) {\n  if (_.isFunction(vdom.nodeName)) {\n    let component, returnVdom\n    if (vdom.nodeName.prototype.render) {\n      component = new vdom.nodeName(vdom.attributes) // 将组件外的 props 传进组件内\n      returnVdom = component.render()\n    } else {\n      returnVdom = vdom.nodeName(vdom.attributes)   // 处理无状态组件: const A = (props) => <div>I'm {props.name}</div>\n    }\n    ...\n  }\n  ...\n}\n")),(0,s.kt)("p",null,"实现完组件间 props 的传递后, 再来聊聊 state, 在 react 中是通过 setState 来完成组件状态的改变的, 在后面的 ",(0,s.kt)("a",c({parentName:"p"},{href:"https://github.com/MuYunyun/blog/blob/master/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0React/5.setState.md"}),"setState 优化")," 中会实现 setState 的异步逻辑, 此处简单实现如下:"),(0,s.kt)("pre",null,(0,s.kt)("code",c({parentName:"pre"},{className:"language-js"}),"function Component(props) {\n  this.props = props\n  this.state = this.state || {}\n}\n\nComponent.prototype.setState = function() {\n  this.state = Object.assign({}, this.state, updateObj) // 这里简单实现, 后续篇章会深入探究\n  const returnVdom = this.render() // 重新渲染\n  document.getElementById('root').innerHTML = null\n  render(returnVdom, document.getElementById('root'))\n}\n")),(0,s.kt)("p",null,"此时虽然已经实现了 setState 的功能, 但是 ",(0,s.kt)("inlineCode",{parentName:"p"},"document.getElementById('root')")," 节点写死在 setState 中显然不是我们希望的, 我们将 dom 节点相关转移到 _render 函数中:"),(0,s.kt)("pre",null,(0,s.kt)("code",c({parentName:"pre"},{className:"language-js"}),"Component.prototype.setState = function(updateObj) {\n  this.state = Object.assign({}, this.state, updateObj)\n  _render(this) // 重新渲染\n}\n")),(0,s.kt)("p",null,"自然地, 重构与之相关的 render 函数:"),(0,s.kt)("pre",null,(0,s.kt)("code",c({parentName:"pre"},{className:"language-js"}),"function render(vdom, container) {\n  let component\n  if (_.isFunction(vdom.nodeName)) {\n    if (vdom.nodeName.prototype.render) {\n      component = new vdom.nodeName(vdom.attributes)\n    } else {\n      component = vdom.nodeName(vdom.attributes) // 处理无状态组件: const A = (props) => <div>I'm {props.name}</div>\n    }\n  }\n  component ? _render(component, container) : _render(vdom, container)\n}\n")),(0,s.kt)("p",null,"在 render 函数中分离出 _render 函数的目的是为了让 setState 函数中也能调用 _render 逻辑。完整 _render 函数如下:"),(0,s.kt)("pre",null,(0,s.kt)("code",c({parentName:"pre"},{className:"language-js"}),"function _render(component, container) {\n  const vdom = component.render ? component.render() : component\n  if (_.isString(vdom) || _.isNumber(vdom)) {\n    container.innerText = container.innerText + vdom\n    return\n  }\n  const dom = document.createElement(vdom.nodeName)\n  for (let attr in vdom.attributes) {\n    setAttribute(dom, attr, vdom.attributes[attr])\n  }\n  vdom.children.forEach(vdomChild => render(vdomChild, dom))\n  if (component.container) {  // 注意: 调用 setState 方法时是进入这段逻辑, 从而实现我们将 dom 的逻辑与 setState 函数分离的目标；知识点: new 出来的同一个实例\n    component.container.innerHTML = null\n    component.container.appendChild(dom)\n    return\n  }\n  component.container = container\n  container.appendChild(dom)\n}\n")),(0,s.kt)("p",null,"让我们用下面这个用例跑下写好的 react 吧！"),(0,s.kt)("pre",null,(0,s.kt)("code",c({parentName:"pre"},{className:"language-js"}),"class A extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      count: 1\n    }\n  }\n\n  click() {\n    this.setState({\n      count: ++this.state.count\n    })\n  }\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.click.bind(this)}>Click Me!</button>\n        <div>{this.props.name}:{this.state.count}</div>\n      </div>\n    )\n  }\n}\n\nReactDOM.render(\n  <A name=\"count\" />,\n  document.getElementById('root')\n)\n")),(0,s.kt)("p",null,"效果图如下:"),(0,s.kt)("p",null,(0,s.kt)("img",c({parentName:"p"},{src:"http://with.muyunyun.cn/reactsetstate.gif",alt:null}))),(0,s.kt)("p",null,"至此, 我们实现了 props 和 state 部分的逻辑。"),(0,s.kt)("h3",null,"forceUpdate 的实现"),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"声明: 这部分为补充章节, 可以选择性阅读。涉及到后文",(0,s.kt)("a",c({parentName:"p"},{href:"https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0React/3.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.md"}),"生命周期"),"、",(0,s.kt)("a",c({parentName:"p"},{href:"https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0React/5.setState.md"}),"setState")," 章节的知识点。")),(0,s.kt)("p",null,"当没有使用 setState 更新 state 状态时, 通常要结合 forceUpdate 一起使用, 例子如下:"),(0,s.kt)("pre",null,(0,s.kt)("code",c({parentName:"pre"},{className:"language-js"}),"class B extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      count: {\n        value: 1\n      }\n    }\n  }\n\n  shouldComponentUpdate() { // 当使用 forceUpdate() 时, shouldComponentUpdate() 会失效\n    return false\n  }\n\n  click() {\n    this.state.count.value = ++this.state.count.value // 没有使用 setState 更新 state 状态时, 通常要结合 forceUpdate 一起使用\n    this.forceUpdate()\n  }\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.click.bind(this)}>Click Me!</button>\n        <div>{this.state.count.value}</div>\n      </div>\n    )\n  }\n}\n")),(0,s.kt)("p",null,"这里要注意一个点",(0,s.kt)("inlineCode",{parentName:"p"},"当使用 forceUpdate() 时, shouldComponentUpdate() 会失效"),", 下面我们来补充 forceUpdate() 的代码逻辑:"),(0,s.kt)("pre",null,(0,s.kt)("code",c({parentName:"pre"},{className:"language-js"}),"// force to update\nComponent.prototype.forceUpdate = function(cb) {\n  this.allowShouldComponentUpdate = false // 不允许 allowShouldComponentUpdate 执行\n  asyncRender({}, this, cb)\n}\n")),(0,s.kt)("p",null,"相应的在 render.js 中加上 allowShouldComponentUpdate 的判断条件:"),(0,s.kt)("pre",null,(0,s.kt)("code",c({parentName:"pre"},{className:"language-js"}),"function renderComponent(component) {\n  if (component.base && component.shouldComponentUpdate && component.allowShouldComponentUpdate !== false) { // 加上 allowShouldComponentUpdate 的判断条件\n    const bool = component.shouldComponentUpdate(component.props, component.state)\n    if (!bool && bool !== undefined) {\n      return false // shouldComponentUpdate() 返回 false, 则生命周期终止\n    }\n  }\n  ...\n}\n")),(0,s.kt)("h3",null,"小结"),(0,s.kt)("p",null,"组件即函数；当 JSX 中是自定义组件时, 经过 babel 转化后的 React.createElement(fn, ..) 后中的第一个参数变为了函数, 除此之外其它逻辑与 JSX 中为 html 元素的时候相同；"),(0,s.kt)("p",null,"此外我们将 state/props/setState 等 api 封装进了父类 React.Component 中, 从而在子类中能调用这些属性和方法。"),(0,s.kt)("p",null,"在下篇, 我们会继续实现生命周期机制, 如有疏漏, 欢迎斧正。"),(0,s.kt)("p",null,(0,s.kt)("a",c({parentName:"p"},{href:"https://github.com/MuYunyun/cpreact"}),"项目地址")))}d.isMDXComponent=!0}}]);