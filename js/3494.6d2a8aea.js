(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3494],{13494:(n,r,t)=>{"use strict";t.r(r),t.d(r,{default:()=>p});var e=t(59713),o=t.n(e),a=t(6479),c=t.n(a),l=(t(67294),t(3905));function u(n,r){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var e=Object.getOwnPropertySymbols(n);r&&(e=e.filter((function(r){return Object.getOwnPropertyDescriptor(n,r).enumerable}))),t.push.apply(t,e)}return t}function i(n){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?u(Object(t),!0).forEach((function(r){o()(n,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):u(Object(t)).forEach((function(r){Object.defineProperty(n,r,Object.getOwnPropertyDescriptor(t,r))}))}return n}var s={};function p(n){var r=n.components,t=c()(n,["components"]);return(0,l.kt)("wrapper",i(i(i({},s),t),{},{components:r,mdxType:"MDXLayout"}),(0,l.kt)("h3",null,"迭代器模式"),(0,l.kt)("p",null,"定义: 能访问到聚合对象的顺序与元素"),(0,l.kt)("h3",null,"实现一个内部迭代器"),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-js"}),"function each(arr, fn) {\n  for (let i = 0; i < arr.length; i++) {\n    fn(i, arr[i])\n  }\n}\n\neach([1, 2, 3], function(i, n) {\n  console.log(i) // 0 1 2\n  console.log(n) // 1 2 3\n})\n")),(0,l.kt)("p",null,"可以看出内部迭代器在调用的时候非常简单, 使用者不用关心迭代器内部实现的细节, 但这也是内部迭代器的缺点。比如要比较两数组是否相等, 只能在其回调函数中作文章了, 代码如下:"),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-js"}),"const compare = function(arr1, arr2) {\n  each(arr1, function(i, n) {\n    if (arr2[i] !== n) {\n      console.log('两数组不等')\n      return\n    }\n  })\n  console.log('两数组相等')\n}\n\nconst arr1 = [1, 2, 3]\nconst arr2 = [1, 2, 3]\ncompare(arr1, arr2) // 两数组相等\n")),(0,l.kt)("h3",null,"实现一个外部迭代器"),(0,l.kt)("p",null,"相较于内部迭代器, 外部迭代器将遍历的权利转移到外部, 因此在调用的时候拥有了更多的自由性, 不过缺点是调用方式较复杂。"),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-js"}),"const iterator = function(arr) {\n  let current = 0\n  const next = function() {\n    current = current + 1\n  }\n  const done = function() {\n    return current >= arr.length\n  }\n  const value = function() {\n    return arr[current]\n  }\n  return {\n    next,\n    done,\n    value,\n  }\n}\n\nconst arr1 = [1, 2 ,3]\nconst arr2 = [1, 2, 3]\nconst iterator1 = iterator(arr1)\nconst iterator2 = iterator(arr2)\n\nconst compare = function(iterator1, iterator2) {\n  while (!iterator1.done() && !iterator2.done()) {\n    if (iterator1.value() !== iterator2.value()) {\n      console.log('两数组不等')\n      return\n    }\n    iterator1.next() // 外部迭代器将遍历的权利转移到外部\n    iterator2.next()\n  }\n  console.log('两数组相等')\n}\n\ncompare(iterator1, iterator2)\n")))}p.isMDXComponent=!0}}]);