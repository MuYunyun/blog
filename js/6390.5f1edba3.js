(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6390],{86390:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>c});var r=t(59713),a=t.n(r),o=t(6479),l=t.n(o),s=(t(67294),t(3905));function u(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function d(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?u(Object(t),!0).forEach((function(n){a()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):u(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var p={};function c(e){var n=e.components,t=l()(e,["components"]);return(0,s.kt)("wrapper",d(d(d({},p),t),{},{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h3",null,"79.Word Search"),(0,s.kt)("p",null,"Given an ",(0,s.kt)("inlineCode",{parentName:"p"},"m x n")," board and a word, find if the word exists in the grid."),(0,s.kt)("p",null,'The word can be constructed from letters of sequentially adjacent cells, where "adjacent" cells are horizontally or vertically neighboring. The ',(0,s.kt)("inlineCode",{parentName:"p"},"same letter cell may not be used more than once"),"."),(0,s.kt)("p",null,"Example 1:"),(0,s.kt)("p",null,(0,s.kt)("img",d({parentName:"p"},{src:"https://assets.leetcode.com/uploads/2020/11/04/word2.jpg",alt:null}))),(0,s.kt)("pre",null,(0,s.kt)("code",d({parentName:"pre"},{className:"language-js"}),'Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"\nOutput: true\n')),(0,s.kt)("p",null,"Example 2:"),(0,s.kt)("p",null,(0,s.kt)("img",d({parentName:"p"},{src:"https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg",alt:null}))),(0,s.kt)("pre",null,(0,s.kt)("code",d({parentName:"pre"},{className:"language-js"}),'Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"\nOutput: true\n')),(0,s.kt)("p",null,"Example 3:"),(0,s.kt)("p",null,(0,s.kt)("img",d({parentName:"p"},{src:"https://assets.leetcode.com/uploads/2020/10/15/word3.jpg",alt:null}))),(0,s.kt)("pre",null,(0,s.kt)("code",d({parentName:"pre"},{className:"language-js"}),'Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"\nOutput: false\n')),(0,s.kt)("p",null,"Constraints:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"m === board.length"),(0,s.kt)("li",{parentName:"ul"},"n === board","[i]",".length"),(0,s.kt)("li",{parentName:"ul"},"1 <= m, n <= 200"),(0,s.kt)("li",{parentName:"ul"},"1 <= word.length <= 103"),(0,s.kt)("li",{parentName:"ul"},"board and word consists only of lowercase and uppercase English letters.")),(0,s.kt)("pre",null,(0,s.kt)("code",d({parentName:"pre"},{className:"language-js"}),"     y列\nx行   C  A  A\n      A  A  A\n      B  C  D\n")),(0,s.kt)("p",null,"AAB -> true"),(0,s.kt)("pre",null,(0,s.kt)("code",d({parentName:"pre"},{className:"language-js"}),"     y列\nx行   a  a  a  a\n      a  a  a  a\n      a  a  a  a\n")),(0,s.kt)("h3",null,"Analyze"),(0,s.kt)("pre",null,(0,s.kt)("code",d({parentName:"pre"},{className:"language-js"}),"     y列\nx行   A  B  C  E   word: ABCB\n      S  F  C  S\n      A  D  E  E\n")),(0,s.kt)("p",null,"二维数组找路径适合用回溯法。每个节点根据",(0,s.kt)("inlineCode",{parentName:"p"},"下、右、上、左"),"四个方向回溯查找元素。"),(0,s.kt)("p",null,"拿 ",(0,s.kt)("inlineCode",{parentName:"p"},"ABCCED")," 作为例子, 括号中为淘汰的值。"),(0,s.kt)("p",null,"A(S) -> B(F) -> C -> C -> E(空、E、C) -> D"),(0,s.kt)("pre",null,(0,s.kt)("code",d({parentName:"pre"},{className:"language-js"}),"/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nvar exist = function(board, word) {\n  for (let x = 0; x < board.length; x++) {\n    for (let y = 0; y < board[x].length; y++) {\n      if (word.length === 1 && word[0] === board[x][y]) {\n        return true\n      }\n      if (word[0] === board[x][y]) {\n        const ifValid = backTrace(board, word, 1, x, y, [])\n        if (ifValid) return ifValid\n      }\n    }\n  }\n  return false\n};\n\n/**\n * start: means start of word\n * x: row\n * y: column\n* */\nvar backTrace = (board, word, start, x, y, used) => {\n  used.push(`${x},${y}`)\n  const useBottom = used.indexOf(`${x + 1},${y}`) === -1 && word[start] === (board[x + 1] && board[x + 1][y])\n  const useRight = used.indexOf(`${x},${y + 1}`) === -1 && word[start] === (board[x] && board[x][y + 1])\n  const useTop = used.indexOf(`${x - 1},${y}`) === -1 && word[start] === (board[x - 1] && board[x - 1][y])\n  const useLeft = used.indexOf(`${x},${y - 1}`) === -1 && word[start] === (board[x] && board[x][y - 1])\n  if (start === word.length - 1 && (useRight || useBottom || useLeft || useTop)) {\n    return true\n  }\n\n  if (useBottom) {\n    const tag = backTrace(board, word, start + 1, x + 1, y, used)\n    used.pop()\n    if (tag) return tag\n  }\n  if (useRight) {\n    const tag = backTrace(board, word, start + 1, x, y + 1, used)\n    used.pop()\n    if (tag) return tag\n  }\n  if (useTop) {\n    const tag = backTrace(board, word, start + 1, x - 1, y, used)\n    used.pop()\n    if (tag) return tag\n  }\n  if (useLeft) {\n    const tag = backTrace(board, word, start + 1, x, y - 1, used)\n    used.pop()\n    if (tag) return tag\n  }\n  return false\n}\n")),(0,s.kt)("p",null,"思考: 这道题的解法可以用来解决生活中部分「迷宫类」的问题。"),(0,s.kt)("h3",null,"优化"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"几个关键点",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"终止条件优化"),(0,s.kt)("li",{parentName:"ul"},"使用 for 循环优化 4 个方向")))),(0,s.kt)("pre",null,(0,s.kt)("code",d({parentName:"pre"},{className:"language-js"}),"/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nvar exist = function(board, word) {\n  for (let x = 0; x < board.length; x++) {\n    for (let y = 0; y < board[x].length; y++) {\n      const ifValid = backTrace(board, word, 0, x, y, [])\n      if (ifValid) return true\n    }\n  }\n  return false\n};\n\nvar directions = [[1, 0], [0, 1], [-1, 0], [0, -1]] // 下、右、上、左\n\n/**\n * start: means start of word\n * x: row\n * y: column\n* */\nvar backTrace = (board, word, start, x, y, used) => {\n  const key = `${x},${y}`\n  if (start === word.length - 1 && used.indexOf(key) === -1 && word[start] === (board[x] && board[x][y])) {\n    return true\n  }\n\n  for (let i = 0; i < directions.length; i++) {\n    if (word[start] === (board[x] && board[x][y]) && used.indexOf(key) === -1) {\n      used.push(key)\n      const tag = backTrace(board, word, start + 1, x + directions[i][0], y + directions[i][1], used)\n      used.pop()\n      if (tag) return true\n    }\n  }\n\n  return false\n}\n")),(0,s.kt)("p",null,"优化后代码量减少 32%。"),(0,s.kt)("h3",null,"sister title"),(0,s.kt)("p",null,"130、200"))}c.isMDXComponent=!0}}]);