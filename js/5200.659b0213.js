(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5200],{5200:n=>{n.exports='### 257. Binary Tree Paths\n\nGiven a binary tree, return all root-to-leaf paths.\n\nNote: A leaf is a node with no children.\n\nExample:\n\n```js\nInput:\n\n   1\n /   \\\n2     3\n \\\n  5\n\nOutput: ["1->2->5", "1->3"]\n```\n\nExplanation: All root-to-leaf paths are: 1->2->5, 1->3\n\n### Analyze\n\n* DFS 深度优先遍历的运用, 关键需要想清楚采用先序、中序、后序遍历中的哪一种。\n  * 先序遍历: 1 -> 2 -> 5, 1 -> 3\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {string[]}\n */\nvar binaryTreePaths = function(root) {\n  const result = []\n  if (!root) return result\n\n  printTreePaths(root, result, \'\')\n  return result\n}\n\nvar printTreePaths = function(node, result, str) {\n  if (!node.left && !node.right) {\n    str += `${node.val}`\n    result.push(str)\n    return\n  }\n\n  str += `${node.val}->`\n\n  if (node.left) {\n    printTreePaths(node.left, result, str)\n  }\n\n  if (node.right) {\n    printTreePaths(node.right, result, str)\n  }\n}\n```'}}]);