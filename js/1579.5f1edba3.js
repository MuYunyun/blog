(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1579],{21579:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>u});var r=t(59713),o=t.n(r),a=t(6479),l=t.n(a),p=(t(67294),t(3905));function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var c={};function u(e){var n=e.components,t=l()(e,["components"]);return(0,p.kt)("wrapper",s(s(s({},c),t),{},{components:n,mdxType:"MDXLayout"}),(0,p.kt)("h3",null,"236.Lowest Common Ancestor of a Binary Search Tree"),(0,p.kt)("p",null,"Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree."),(0,p.kt)("p",null,"According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”"),(0,p.kt)("p",null,"Example 1:"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-js"}),"       3\n     /   \\\n    5      1\n   / \\    / \\\n  6   2  0   8\n     / \\\n    7   4\n")),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-js"}),"Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\nOutput: 3\n")),(0,p.kt)("p",null,"Explanation: The LCA of nodes 5 and 1 is 3."),(0,p.kt)("p",null,"Example 2:"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-js"}),"Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\nOutput: 5\n")),(0,p.kt)("p",null,"Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition."),(0,p.kt)("p",null,"Example 3:"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-js"}),"    1\n  /\n 2\n")),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-js"}),"Input: root = [1,2], p = 1, q = 2\nOutput: 1\n")),(0,p.kt)("p",null,"Constraints:"),(0,p.kt)("p",null,"The number of nodes in the tree is in the range ","[2, 105]",".\n-109 <= Node.val <= 109\n",(0,p.kt)("inlineCode",{parentName:"p"},"All Node.val are unique"),".\n",(0,p.kt)("inlineCode",{parentName:"p"},"p != q"),"\n",(0,p.kt)("inlineCode",{parentName:"p"},"p and q will exist in the tree"),"."),(0,p.kt)("h3",null,"Analyze"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"Using ",(0,p.kt)("inlineCode",{parentName:"li"},"post-order traversal")," of birnary tree in recursive.")),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nvar lowestCommonAncestor = function(root, p, q) {\n  return lca(root, p, q)\n};\n\nvar lca = function(node, p, q) {\n  if (!node) return null\n  // node is the lowest common ancestor of p and q.\n  if (node.val === p.val || node.val === q.val) return node\n\n  const leftLca = lca(node.left, p, q)\n  const rightLca = lca(node.right, p, q)\n\n  // get value of post-order traversal\n  if (!leftLca) {\n    return rightLca\n  }\n  if (!rightLca) {\n    return leftLca\n  }\n  return node\n}\n")))}u.isMDXComponent=!0}}]);