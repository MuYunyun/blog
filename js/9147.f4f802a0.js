(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9147],{39147:n=>{n.exports="### CommonJS 模块与 ES6 模块间的差异\n\n#### 写法上的差异\n\nCommonJS 中常见导出和引人写法如下:\n\n```js\n// 导出\nmodule.exports = a\n\n// 引人\nconst a = require('./xxx')\n```\n\nES6 中常见导出和引人写法如下:\n\n```js\n// 导出\nexport default a          // 编译成 CommonJS: exports.default = a (ES 编译成的 CommonJS 形式)\n\n// 引人\nimport a from './xxx'     // 编译成 CommonJS: require('./xxx').default\n\n// 导出\nexport { a }              // 编译成 CommonJS: exports.a = a\n\n// 引人\nimport { a } from './xxx' // 编译成 CommonJS: require('./xxx').a\n```\n\n#### 加载机制的差异\n\n在 CommonJS 的模块中, require 是动态(运行时)加载的；在 ES6 的模块中, import 是静态(编译时)加载的。\n\n> ES6 [import() 动态加载的提案](https://github.com/tc39/proposal-dynamic-import) 目前已到第 3 阶段。\n\n> 另外如果是使用 TypeScript 的话, 编译成 JavaScript 的代码后再用上述结论。\n\n#### 获取模块的差异\n\n在 CommonJS 中, 获取的是一个`值/模块的拷贝`, 见如下例子:\n\n```js\n// test.js\nlet a = 1\n\nfunction add() {\n  a = 2\n}\n\nmodule.exports = { a, add }\n\n// test2.js\nconst { a, add } = require('./test')\n\nconsole.log(a)\nadd()\nconsole.log(a)\n\n// 执行 node test2.js, 输出结果为 1 1\n```\n\n在 ES6 中, 获取的是一个`值/模块的引用`, 见如下例子:\n\n```js\n// test.js\nlet a = 1\n\nfunction add() {\n  a = 2\n}\n\nexport { a, add }\n\n// index.html\nimport { a, add } from './index.js'\n\nconsole.log(a)\n\nadd()\n\nconsole.log(a)\n\n// 在浏览器中输出结果为 1 2\n```\n\n### 同时支持 CJS 与 ESM 包的最佳实践\n\n1. 提供一个 CJS 版本\n\n这样可以确保你的库在旧版本 Node 下跑的更好。(如果你写的是 TypeScript 或者其他需要编译到 JavaScript 的语言，那么编译到 CJS。)\n\n2. 基于 CJS 封装到 ESM 版本 (将 CJS 封装到 ESM 很容易，但是 ESM 库是没法封装到 CJS 库的)。\n\n```js\nimport cjsModule from '../index.js';\nexport const foo = cjsModule.foo;\n```\n\nTodo: 调研为什么 CJS 封装为 ESM 容易, 但是反过来不行。"}}]);