(self.webpackChunkblog=self.webpackChunkblog||[]).push([[716],{90716:(e,n,o)=>{"use strict";o.r(n),o.d(n,{default:()=>u});var t=o(59713),r=o.n(t),l=o(6479),a=o.n(l),d=(o(67294),o(3905));function i(e,n){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),o.push.apply(o,t)}return o}function c(e){for(var n=1;n<arguments.length;n++){var o=null!=arguments[n]?arguments[n]:{};n%2?i(Object(o),!0).forEach((function(n){r()(e,n,o[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):i(Object(o)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(o,n))}))}return e}var p={};function u(e){var n=e.components,o=a()(e,["components"]);return(0,d.kt)("wrapper",c(c(c({},p),o),{},{components:n,mdxType:"MDXLayout"}),(0,d.kt)("h3",null,"享元模式"),(0,d.kt)("p",null,"享元模式是一种优化程序性能的模式, 本质为",(0,d.kt)("inlineCode",{parentName:"p"},"减少对象创建的个数"),"。"),(0,d.kt)("p",null,"以下情况可以使用享元模式:"),(0,d.kt)("ol",null,(0,d.kt)("li",{parentName:"ol"},"有大量相似的对象, 占用了大量内存"),(0,d.kt)("li",{parentName:"ol"},"对象中大部分状态可以抽离为外部状态")),(0,d.kt)("h3",null,"demo"),(0,d.kt)("p",null,"某商家有 50 种男款内衣和 50 种款女款内衣, 要展示它们"),(0,d.kt)("p",null,"方案一: 造 50 个塑料男模和 50 个塑料女模, 让他们穿上展示, 代码如下:"),(0,d.kt)("pre",null,(0,d.kt)("code",c({parentName:"pre"},{className:"language-js"}),"const Model = function(gender, underwear) {\n  this.gender = gender\n  this.underwear = underwear\n}\n\nModel.prototype.takephoto = function() {\n  console.log(`${this.gender}穿着${this.underwear}`)\n}\n\nfor (let i = 1; i < 51; i++) {\n  const maleModel = new Model('male', `第${i}款衣服`)\n  maleModel.takephoto()\n}\n\nfor (let i = 1; i < 51; i++) {\n  const female = new Model('female', `第${i}款衣服`)\n  female.takephoto()\n}\n")),(0,d.kt)("p",null,"方案二: 造 1 个塑料男模特 1 个塑料女模特, 分别试穿 50 款内衣"),(0,d.kt)("pre",null,(0,d.kt)("code",c({parentName:"pre"},{className:"language-js"}),"const Model = function(gender) {\n  this.gender = gender\n}\n\nModel.prototype.takephoto = function() {\n  console.log(`${this.sex}穿着${this.underwear}`)\n}\n\nconst maleModel = new Model('male')\nconst femaleModel = new Model('female')\n\nfor (let i = 1; i < 51; i++) {\n  maleModel.underwear = `第${i}款衣服`\n  maleModel.takephoto()\n}\n\nfor (let i = 1; i < 51; i++) {\n  femaleModel.underwear = `第${i}款衣服`\n  femaleModel.takephoto()\n}\n")),(0,d.kt)("p",null,"对比发现: 方案一创建了 100 个对象, 方案二只创建了 2 个对象, 在该 demo 中, gender(性别) 是内部对象, underwear(穿着) 是外部对象。"),(0,d.kt)("p",null,"当然在方案二的 demo 中, 还可以进一步改善:"),(0,d.kt)("ol",null,(0,d.kt)("li",{parentName:"ol"},"一开始就通过构造函数显示地创建实例, 可用工场模式将其升级成可控生成"),(0,d.kt)("li",{parentName:"ol"},"在实例上手动添加 underwear 不是很优雅, 可以在外部单独在写个 manager 函数")),(0,d.kt)("pre",null,(0,d.kt)("code",c({parentName:"pre"},{className:"language-js"}),"const Model = function(gender) {\n  this.gender = gender\n}\n\nModel.prototype.takephoto = function() {\n  console.log(`${this.gender}穿着${this.underwear}`)\n}\n\nconst modelFactory = (function() { // 优化第一点\n  const modelGender = {}\n  return {\n    createModel: function(gender) {\n      if (modelGender[gender]) {\n        return modelGender[gender]\n      }\n      return modelGender[gender] = new Model(gender)\n    }\n  }\n}())\n\nconst modelManager = (function() {\n  const modelObj = {}\n  return {\n    add: function(gender, i) {\n      modelObj[i] = {\n        underwear: `第${i}款衣服`\n      }\n      return modelFactory.createModel(gender)\n    },\n    copy: function(model, i) { // 优化第二点\n      model.underwear = modelObj[i].underwear\n    }\n  }\n}())\n\nfor (let i = 1; i < 51; i++) {\n  const maleModel = modelManager.add('male', i)\n  modelManager.copy(maleModel, i)\n  maleModel.takephoto()\n}\n\nfor (let i = 1; i < 51; i++) {\n  const femaleModel = modelManager.add('female', i)\n  modelManager.copy(femaleModel, i)\n  femaleModel.takephoto()\n}\n")))}u.isMDXComponent=!0}}]);