(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6737],{86737:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>c});var r=t(59713),a=t.n(r),l=t(6479),u=t.n(l),p=(t(67294),t(3905));function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function k(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){a()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var m={};function c(n){var e=n.components,t=u()(n,["components"]);return(0,p.kt)("wrapper",k(k(k({},m),t),{},{components:e,mdxType:"MDXLayout"}),(0,p.kt)("h3",null,"77.Combinations"),(0,p.kt)("p",null,"Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.\nYou may return the answer in any order."),(0,p.kt)("p",null,"Example 1:"),(0,p.kt)("pre",null,(0,p.kt)("code",k({parentName:"pre"},{className:"language-js"}),"Input: n = 4, k = 2\nOutput:\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n")),(0,p.kt)("p",null,"Example 2:"),(0,p.kt)("pre",null,(0,p.kt)("code",k({parentName:"pre"},{className:"language-js"}),"Input: n = 1, k = 1\nOutput: [[1]]\n")),(0,p.kt)("p",null,"Constraints:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"1 <= n <= 20"),(0,p.kt)("li",{parentName:"ul"},"1 <= k <= n")),(0,p.kt)("h3",null,"analyze"),(0,p.kt)("p",null,"n: 1, 2, 3, 4\nk: 2"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"1",(0,p.kt)("ul",{parentName:"li"},(0,p.kt)("li",{parentName:"ul"},"2"),(0,p.kt)("li",{parentName:"ul"},"3"),(0,p.kt)("li",{parentName:"ul"},"4"))),(0,p.kt)("li",{parentName:"ul"},"2",(0,p.kt)("ul",{parentName:"li"},(0,p.kt)("li",{parentName:"ul"},"3"),(0,p.kt)("li",{parentName:"ul"},"4"))),(0,p.kt)("li",{parentName:"ul"},"3",(0,p.kt)("ul",{parentName:"li"},(0,p.kt)("li",{parentName:"ul"},"4")))),(0,p.kt)("p",null,"组合问题中, 不同顺序的解为同一个。比如 ",(0,p.kt)("inlineCode",{parentName:"p"},"[1, 2], [2, 1]")," 为相同解。"),(0,p.kt)("p",null,"此外可以发现规律, 保留所有",(0,p.kt)("inlineCode",{parentName:"p"},"增序排列的解"),"即为组合的解。"),(0,p.kt)("pre",null,(0,p.kt)("code",k({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number} n\n * @param {number} k\n * @return {number[][]}\n */\nvar combine = function(n, k) {\n  const result = []\n  backTrace(n, k, 1, [], result)\n  return result\n};\n\nvar backTrace = function(n, k, index, temp, result) {\n  if (temp.length === k) {\n    if (ifIncrease(temp)) {\n      result.push([...temp])\n    }\n    return\n  }\n\n  for (let i = index; i <= n; i++) {\n    temp.push(i)\n    backTrace(n, k, index + 1, temp, result)\n    temp.pop()\n  }\n}\n\nvar ifIncrease = function(arr) {\n  for (let i = 0; i < arr.length - 1; i++) {\n    if (arr[i] >= arr[i + 1]) return false\n  }\n  return true\n}\n")),(0,p.kt)("p",null,"提交, 此时报超时的错误。经排查发现, 截支的地方存在问题, 当前在 temp 中的值被重复使用了。修改如下"),(0,p.kt)("pre",null,(0,p.kt)("code",k({parentName:"pre"},{className:"language-diff"}),"- backTrace(n, k, index + 1, temp, result)\n+ backTrace(n, k, i + 1, temp, result)\n")),(0,p.kt)("pre",null,(0,p.kt)("code",k({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number} n\n * @param {number} k\n * @return {number[][]}\n */\nvar combine = function(n, k) {\n  const result = []\n  backTrace(n, k, 1, [], result)\n  return result\n};\n\nvar backTrace = function(n, k, index, temp, result) {\n  if (temp.length === k) {\n    result.push([...temp])\n    return\n  }\n\n  for (let i = index; i <= n; i++) {\n    temp.push(i)\n    backTrace(n, k, i + 1, temp, result)\n    temp.pop()\n  }\n}\n")),(0,p.kt)("h3",null,"回溯法剪支"),(0,p.kt)("p",null,"还是以 ",(0,p.kt)("inlineCode",{parentName:"p"},"n = 5, k = 3")," 为例, 上述代码中, 实际遍历的顺序如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",k({parentName:"pre"},{className:"language-js"}),"* 1\n  * 2\n    * 3\n    * 4\n    * 5\n  * 3\n    * 4\n    * 5\n  * 4\n    * 5\n  * 5 // 减支\n* 2\n  * 3\n    * 4\n    * 5\n  * 4\n    * 5\n  * 5 // 减支\n* 3\n  * 4\n    * 5\n  * 5 // 减支\n* 4 // 减支\n")),(0,p.kt)("p",null,"此时, 当第一列的值到达 3 时, 达到",(0,p.kt)("inlineCode",{parentName:"p"},"搜索上界"),", ","[3, 4, 5]"," 是其中一个解。如果再往后遍历, 4 作为解的开头, 则位数达不到 3 位, 不满足要求了。同理第二列的搜索上界为 4。第三列的搜索上界为 5。接着结合代码进行优化:"),(0,p.kt)("pre",null,(0,p.kt)("code",k({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number} n\n * @param {number} k\n * @return {number[][]}\n */\nvar combine = function(n, k) {\n  const result = []\n  backTrace(n, k, 1, [], result)\n  return result\n};\n\nvar backTrace = function(n, k, index, temp, result) {\n  if (temp.length === k) {\n    result.push([...temp])\n    return\n  }\n\n  // 题目可以转化为从搜索上界到 n 中要取的数字长度为 (k - temp.length)。\n  // 可以得出搜索上界为: n - (k - temp.length) + 1\n  for (let i = index; i <= n - (k - temp.length) + 1; i++) {\n    temp.push(i)\n    backTrace(n, k, i + 1, temp, result)\n    temp.pop()\n  }\n}\n")))}c.isMDXComponent=!0}}]);