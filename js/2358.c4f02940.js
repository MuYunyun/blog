(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2358],{42358:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>k});var a=t(59713),r=t.n(a),p=t(6479),s=t.n(p),l=(t(67294),t(3905));function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var u={};function k(e){var n=e.components,t=s()(e,["components"]);return(0,l.kt)("wrapper",o(o(o({},u),t),{},{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h3",null,"字典"),(0,l.kt)("p",null,"类似于集合, 字典也是一种",(0,l.kt)("inlineCode",{parentName:"p"},"无重复元素"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"无顺序"),"的数据结构。"),(0,l.kt)("p",null,"区别在于在集合中, 我们以 ",(0,l.kt)("inlineCode",{parentName:"p"},"[值,  值]")," 的形式存储; 在字典中, 我们以 ",(0,l.kt)("inlineCode",{parentName:"p"},"[键, 值]")," 的形式存储; 集合的知识点可以阅读 ",(0,l.kt)("a",o({parentName:"p"},{href:"https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/%E9%9B%86%E5%90%88.md"}),"集合")),(0,l.kt)("p",null,"ES6 引入的 Map 就是字典的数据类型。"),(0,l.kt)("h4",null,"简易版 Map 实现"),(0,l.kt)("p",null,"我们来动手实现一个简易版的 Map, 它拥有的 api 如下:"),(0,l.kt)("pre",null,(0,l.kt)("code",o({parentName:"pre"},{className:"language-js"}),"function Map() {\n  this.items = {}\n  this.size = 0\n}\n\nMap.prototype.has = function(key) {\n  for (let i in this.items) {\n    if (this.items.hasOwnProperty(i)) {\n      return true\n    }\n  }\n  return false\n}\n\nMap.prototype.delete = function(key) {\n  if (this.has(key)) {\n    delete(this.items[key])\n    this.size--\n    return true\n  }\n  return false\n}\n\nMap.prototype.set = function(key, value) {\n  this.items[key] = value // 这里是不严谨的实现\n  this.size++\n}\n\nMap.prototype.get = function(key) {\n  return this.items[key]\n}\n\nMap.prototype.clear = function() {\n  this.items = {}\n  this.size = 0\n}\n\nMap.prototype.values = function() {\n  const arr = []\n  Object.keys(this.items).forEach(r => {\n    arr.push(this.items[r])\n  })\n  return arr\n}\n")),(0,l.kt)("h3",null,"创建一个 Map 对象"),(0,l.kt)("pre",null,(0,l.kt)("code",o({parentName:"pre"},{className:"language-js"}),"// 方式一\nconst map1 = new Map()\nmap.set('a', 1)\n\n// 方式二\nconst map2 = new Map([['a', 1]])\n")),(0,l.kt)("h3",null,"Map 和 WeakMap 的区别"),(0,l.kt)("p",null,"Map 和 WeakMap 相差 Weak 这个单词, 本质知识点是对对象的直接引用(WeakMap)。它这个点造成的差异整理如下:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Map 的 key 范围更广, WeakMap 的 key 只能为对象;"),(0,l.kt)("li",{parentName:"ul"},"Map 的 key 可以枚举, WeakMap 的 key 不能枚举;"),(0,l.kt)("li",{parentName:"ul"},"垃圾回收相关, 见如下例子;")),(0,l.kt)("pre",null,(0,l.kt)("code",o({parentName:"pre"},{className:"language-js"}),"var map = new Map();\nvar weakmap = new WeakMap();\n\n(function(){\n  var a = {x: 12}\n  var b = {y: 12}\n\n  map.set(a, 1)\n  weakmap.set(b, 2)\n})()\n")),(0,l.kt)("p",null,"解析: 在这个例子中, IIFE 执行完后, 垃圾回收机制会回收常量 a, b。WeakMap 可以类比成直接对 b 的引用, Map 里可以类比成在其内部对 a 作了层拷贝。所以 map 依然保持着相应的 key 值的对象, 而 weakmap 的 key 值的对象以被回收(这步认为是垃圾回收机制做的)。它们的差异如下图所示:"),(0,l.kt)("pre",null,(0,l.kt)("code",o({parentName:"pre"},{className:"language-js"}),"// map\nMap(1) {{…} => 1}\n  size: (...)\n  __proto__: Map\n  [[Entries]]: Array(1)\n    0: {Object => 1}\n      key: {x: 12}\n      value: 1\n\n// weakmap\nWeakMap {}\n  __proto__: WeakMap\n  [[Entries]]: Array(0)\n    length: 0\n")))}k.isMDXComponent=!0}}]);