(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5378],{5378:n=>{n.exports="### express\n\nexpress 是一个基于 node.js 封装的框架。\n\n该 [express demo](https://github.com/MuYunyun/blog/blob/master/Basic%20Skill/node.js/express/index.js) 主要实现的功能点:\n\n* 路由模块\n* 中间件模块\n* 正则匹配路由\n* 静态文件处理\n\n### 路由和中间件\n\n#### 版本一\n\n```js\n// 测试用例\nconst app = express()\n\n// 测试路由\napp.get('/', function (req, res) {\n  res.end('hello express')\n})\n\n// 测试中间件\napp.use((req, res, next) => {\n  console.log('this is middleware1')\n  next()\n})\n\napp.use((req, res, next) => {\n  console.log('this is middleware2')\n  next()\n})\n\napp.listen(3000, function (req, res) {\n  console.log('server is listening port 3000')\n})\n\n// this is middleware1\n// this is middleware2\n// hello express\n```\n\n```js\nconst http = require('http')\nconst url = require('url')\n\nconst core = function(req, res) {\n  const method = req.method.toLocaleLowerCase()\n  const obj = url.parse(req.url, true)\n  const pathname = obj.pathname\n  const cb = hitRouting(method, pathname)\n  // 这里插入中间件\n  next(req, res)\n  cb(req, res)\n}\n\ncore.listen = function(port, fn) {                      // 挂载到 core 函数上\n  http.createServer(core).listen(port, '127.0.0.1', fn) // 核心还是这条语句, 即对 node 的封装\n}\n\nconst methods = ['post', 'get', 'delete', 'options', 'head']\nmethods.map(method => {\n  core[method] = (path, cb) => core.routes.push({ method, path, cb })\n})\n\ncore.routes = []      // 路由队列\ncore.middlewares = [] // 中间件队列\n\n// 命中路由, 获取回调\nconst hitRouting = function(method, pathname) {\n  let cb = (req, res) => res.end('no hit routing')\n  core.routes.map((r, index) => {\n    if (r.method === method && r.path === pathname) {\n      cb = r.cb\n      return\n    }\n  })\n  return cb\n}\n\ncore.use = function(middlewareFn) {\n  core.middlewares.push(middlewareFn)\n}\n\nlet i = 0\nconst next = function(req, res) {   // express 中间件的核心实现\n  const handler = core.middlewares[i++]\n  if (!handler) {\n    return\n  }\n  handler(req, res, next)\n}\n\nconst express = function() {\n  return core\n}\n```\n\n版本一的路由和中间件是分为两个数组分别进行管理的；但是当看到 next() 函数又联想到可以借助 generator 函数来实现路由和中间件的集中管理(把中间件也当成是一个路由), 所以有了版本二的实现。\n\n#### 版本二\n\n版本二相较于版本一最主要是遍历方式的改变, 改为迭代器方式。\n\n```js\n// 测试路由\napp.get('/test/abc', function(req, res) {\n  res.end('hello express')\n})\n\n// 测试中间件\napp.use('/test', function(req, res, next) {\n  console.log('this is middleware')\n  next()\n})\n\napp.listen(3000, function(req, res) {\n  console.log('server is listening port 3000')\n})\n```\n\n测试用例进行了改动, 比如当访问 `/test/abc` 路由的时候, 其实也命中了 `/test` 中间件, 所以此时中间件内的代码也会执行。\n\n```js\nconst http = require('http')\nconst url = require('url')\n\nconst core = function(req, res) {\n  const method = req.method.toLocaleLowerCase()\n  const obj = url.parse(req.url, true)\n  const pathname = obj.pathname\n  hitRouting(core.routes, method, pathname)(req, res)\n}\n\ncore.listen = function(port, fn) {                      // 挂载到 core 函数上\n  http.createServer(core).listen(port, '127.0.0.1', fn) // 核心还是这条语句, 即对 node 的封装\n}\n\ncore.routes = []      // 路由队列\nconst methods = ['post', 'get', 'delete', 'options', 'head', 'use']\nmethods.map(method => {\n  core[method] = (path, cb) => core.routes.push({ method, path, cb })\n})\n\nfunction* generator(arr) {  // 引人 Generator 函数\n  yield* arr\n}\n\nconst hitRouting = function(routes, method, pathname) { // 将中间件也当作是路由\n  const lazy = generator(routes)\n  return function(req, res) {\n    (function next() {\n      const tmp = lazy.next().value\n      if (!tmp) {\n        return\n      }\n      if (tmp.method === method && tmp.path === pathname) {                                     // 命中路由\n        tmp.cb(req, res)\n        next()\n      } else if (tmp.method === 'use' && (tmp.path === '/' || pathname.startsWith(tmp.path))) { // 命中中间件\n        tmp.cb(req, res, next)\n      } else {\n        next() // 跳过\n      }\n    }())\n  }\n}\n\nconst express = function() {\n  return core\n}\n```\n\n### 路由正则匹配\n\n```js\n// 测试用例\napp.get('/blog/:id', function (req, res) { // 扩展功能①: 希望能匹配 /blog/123\n  console.log(req.param.id)                // 扩展功能②: 希望能通过 req.param.id 获取到相应参数\n  res.end('test /blog/:id')\n})\n```\n\n上述功能简要实现如下:\n\n```js\nconst hitRouting = function(routes, method, pathname) { // 将中间件也当作是路由\n  const lazy = generator(routes)\n  return function(req, res) {\n    (function next() {\n      const tmp = lazy.next().value\n      const reg = new RegExp(tmp.path.replace(/:id/g, '\\\\d+'))\n      if (tmp.method === method && reg.test(pathname)) {        // 匹配 /blog/:id, 这里仅仅举个例子\n        const arr = tmp.path.split(':')\n        const pathNameArr = pathname.split('/')\n        const obj = {}\n        obj[arr[1]] = pathNameArr[pathNameArr.length - 1]\n        req.param = obj   // 实现 req.param.id 获取 id\n        tmp.cb(req, res)\n        next()\n      }\n      ...\n    }())\n  }\n}\n```\n\n### 静态资源的访问\n\n如果在浏览器中输入 `http://127.0.0.1:3000/index.html`, 此时并不能处理这种情况, 接着加上访问静态资源的逻辑, 代码如下:\n\n```js\nconst core = function(req, res) {\n  const method = req.method.toLocaleLowerCase()\n  const obj = url.parse(req.url, true)\n  const pathname = obj.pathname\n  const ext = path.extname(pathname).slice(1)\n  if (ext) { // 处理静态文件请求\n    handleStaticFile(res, staticPath, ext)\n  }\n  ...\n}\n\n// 处理静态文件类型\nconst handleStaticFile = function (res, staticPath, ext) {\n  const mime = {\n    \"html\": \"text/html\",\n    \"css\": \"text/css\",\n    \"js\": \"text/javascript\",\n    \"json\": \"application/json\",\n    \"gif\": \"image/gif\",\n    \"ico\": \"image/x-icon\",\n    \"jpeg\": \"image/jpeg\",\n    \"jpg\": \"image/jpeg\",\n    \"png\": \"image/png\"\n  }\n  fs.exists(staticPath, (exist) => {\n    if (!exist) {\n      res.writeHead(404, {'Content-Type': 'text/plain'})\n      res.write('The request failed')\n      res.end()\n    } else {\n      fs.readFile(staticPath, (err, data) => {\n        if (err) throw err\n        res.writeHead(200, {'Content-Type': mime[ext] || 'text/plain'})\n        res.write('The request success')\n        res.end()\n      })\n    }\n  })\n}\n```\n\n"}}]);