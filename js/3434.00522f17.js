(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3434],{23434:n=>{n.exports="### 哈希表\n\n哈希表算是一种特殊的字典。它在实际的键值和存入的哈希值之间存在一层映射。如下例子:\n\n![](http://with.muyunyun.cn/963b04e081590a419bfc97c30d915a01.jpg-300)\n\n上图中通过哈希函数将键值转换成哈希值, 然后再将哈希值指向具体的值。接着我们来构造 HashTable 类, 代码如下:\n\n```js\nfunction HashTable() {\n  this.items = {}\n}\n\n// 哈希算法\nfunction keyToHash(key) {\n  let hash = 0\n  for (let i = 0; i < key.length; i++) {\n    hash += key.charCodeAt(i)\n  }\n  hash = hash % 37 // 为了避免 hash 的值过大\n  return hash\n}\n\nHashTable.prototype.put = function(key, value) {\n  const hash = keyToHash(key)\n  this.items[hash] = value\n}\n\nHashTable.prototype.get = function(key) {\n  return this.items[keyToHash(key)]\n}\n\nHashTable.prototype.remove = function(key) {\n  delete(this.items[keyToHash(key)])\n}\n```\n\n跑如下测试用例:\n\n```js\nvar test = new HashTable()\ntest.put('ab', 'ab@gmail.com')\ntest.put('cd', 'cd@gmail.com')\ntest.put('ef', 'ef@gmail.com')\n\ntest.get('cd') // \"cd@gmail.com\"\ntest.remove('cd')\ntest.get('cd') // undefined\n```\n\n但是这样子实现的哈希表有一个问题, 比如进行如下调用就会产生冲突:\n\n```js\ntest.put('ab', 'ab@gmail.com')\ntest.put('ba', 'ba@gmail.com') // ab 和 ba 的哈希值相同, 后者会把前者覆盖\n```\n\n接着我们来尝试解决该问题\n\n#### 链表法\n\n顾名思义, 这个方法就是在每个哈希值上引人链表。如下图所示:\n\n![](http://with.muyunyun.cn/bd07ad706f4d494a9df8fb63621a6036.jpg-200)\n\n对之前 put、get、remove 方法做如下修改, 其中使用到的链表的代码参考之前的 [链表](https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/链表.md#链表的实现)\n\n```js\nfunction HashTable() {\n  this.items = {}\n}\n\nfunction keyToHash(key) {\n  let hash = 0\n  for (let i = 0; i < key.length; i++) {\n    hash += key.charCodeAt(i)\n  }\n  hash = hash % 37\n  return hash\n}\n\n// 存入链表的值\nfunction Node(key, value) {\n  this.key = key\n  this.value = value\n}\n\n// 添加接口\nHashTable.prototype.put = function(key, value) {\n  const hash = keyToHash(key)\n  if (!this.items[hash]) {\n    this.items[hash] = new LinkedList() // 这里将之前实现的链表拿来使用\n  }\n  let linkList = this.items[hash].getHead()\n  let ifAppend = true\n  while (linkList) {                        // 以下为 append 逻辑\n    if (linkList.element.key === key) {     // key 值重复逻辑\n      linkList.element = new Node(key, value)\n      ifAppend = false\n      break\n    }\n    linkList = linkList.next\n  }\n  if (ifAppend) {\n    this.items[hash].append(new Node(key, value))\n  }\n}\n\nHashTable.prototype.has = function (hash) {\n  if (this.items.hasOwnProperty(hash)) {\n    return true\n  }\n  return false\n}\n\n// 获取接口\nHashTable.prototype.get = function(key) {\n  const hash = keyToHash(key)\n  if (this.has(hash)) {\n    let current = this.items[hash].getHead()\n    while (current) {\n      if (current.element.key === key) {\n        return current.element.value\n      }\n      current = current.next\n    }\n  }\n  return undefined\n}\n\n// 移除接口\nHashTable.prototype.remove = function(key) {\n  const hash = keyToHash(key)\n  if (this.has(hash)) {\n    let current = this.items[hash].getHead()\n    while (current) {\n      if (current.element.key === key) {\n        this.items[hash].remove(current.element)\n        return true\n      }\n      current = current.next\n    }\n    return false\n  }\n  return false\n}\n```\n\n接着来测试下完成的哈希表, 测试用例如下:\n\n```js\nvar test = new HashTable()\ntest.put('ab', 'ab@gmail.com')\ntest.put('ba', 'ba~@gmail.com')\ntest.put('ba', 'ba@gmail.com') // 验证重复字段\ntest.put('cd', 'cd@gmail.com')\n\ntest.get('ab') // ab@gmail.com\ntest.get('ba') // ba@gmail.com\ntest.get('cd') // cd@gmail.com\n\ntest.remove('ba')\ntest.get('ba') // undefined\n```\n\n#### 线性探查法\n\n思想: 如果当前所要存储的 hash 值已存在于存储空间, 则判断存储空间里是否已存储 hash + 1, 若无则存储 hash + 1, 若有则判断存储空间里是否已存储 hash + 2, 依次类推。参考图如下:\n\n![](http://with.muyunyun.cn/9212ee6899520f888f774ca7a2dc0519.jpg-200)\n\n接着进入代码实现环节, 同样是修改 put、get、remove 方法:\n\n```js\nfunction HashTable() {\n  this.items = {}\n}\n\n// 哈希算法\nfunction keyToHash(key) {\n  let hash = 0\n  for (let i = 0; i < key.length; i++) {\n    hash += key.charCodeAt(i)\n  }\n  hash = hash % 37 // 为了避免 hash 的值过大\n  return hash\n}\n\n// 后面会用之锁定\nfunction Node(key, value) {\n  this.key = key\n  this.value = value\n}\n\nHashTable.prototype.put = function(key, value) {\n  let hash = keyToHash(key)\n  while (this.items[hash]) {             // 当 this.items[index] 不存在时终止\n    if (this.items[hash].key === key) {  // 对已存在的 key 值进行覆盖\n      break\n    }\n    hash++\n  }\n  this.items[hash] = new Node(key, value)\n}\n\nHashTable.prototype.has = function(hash) {\n  if (this.items.hasOwnProperty(hash)) {\n    return true\n  }\n  return false\n}\n\nHashTable.prototype.get = function(key) {\n  let hash = keyToHash(key)\n  if (this.items[hash]) {\n    while (this.items[hash].key !== key) { // 找到存储的 index\n      hash++\n    }\n    return this.items[hash].value\n  }\n  return undefined\n}\n\nHashTable.prototype.remove = function(key) {\n  let hash = keyToHash(key)\n  if (this.has(hash)) {\n    while (this.items[hash].key !== key) { // 找到存储的 index\n      hash++\n    }\n    this.items[hash] = undefined\n    return true\n  }\n  return false\n}\n```\n\n接着跑如下测试用例:\n\n```js\nvar test = new HashTable()\ntest.put('ab', 'ab@gmail.com')\ntest.put('ba', 'ba@gmail.com')\ntest.put('ab', 'ab@gmail.com')\n\ntest.get('ab') // 'ab@gmail.com'\n\ntest.remove('ab')\ntest.get('ab') // undefined\n```\n\n#### 更好的哈希函数\n\n另外在本文实现的哈希函数中, 性能不是特别好（因为容易产生相同的哈希值）, 给出一段更好的散列函数的实现, 数学知识的原理暂时不深究了\n\n```js\n// 哈希算法\nfunction keyToHash(key) {\n  let hash = 5381    // 取一个素数\n  for (let i = 0; i < key.length; i++) {\n    hash = hash * 33 + key.charCodeAt(i)\n  }\n  hash = hash % 1013 // 除以另外一个素数\n  return hash\n}\n```\n\n#### 哈希表的应用\n\n笔者认为业务中, 哈希表的数据结构能应用需要加密处理的数据存储中。"}}]);