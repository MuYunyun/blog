(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1882],{91882:n=>{n.exports='### display(布局)\n\n* `block`: 有宽高, 不在同一行;\n* `inline-block`: 有宽高，在同一行;(父节点上使用 inline-block 会`自动获取子节点的宽度`)\n* `inline`: 无宽高, 在同一行;\n\n### position(位置)\n\n* relative: 元素根据正常的文档流相进行定位;\n* absolute: 脱离当前文档流, 相对其最近的 `position` 属性值为非 `static` 祖先元素进行定位, 直到 body;\n* fixed: 脱离当前文档流, 相对视窗定位。注意: 当父元素上有这几个属性时, `transform`, `perspective`, `filter` 时, fixed 定位会失效;\n* sticky: relative 与 fixed 的结合;\n\n使用 sticky 布局有一些限制:\n\n```html\n<div>\n  <div style="position: sticky; top: 20px; background: pink; margin-top: 50px;">Header</div>\n  <div style="height: 1000px">Content</div> // 比如这一行不可或缺\n</div>\n```\n\n### margin\n\n`margin` 的百分比值是以父元素的宽度作为解析基准的。\n\n### 自适应内部元素宽度\n\n* [自适应内部元素宽度](https://codepen.io/MuYunyun/pen/eXgqpa)\n\n### 精确控制表格列宽\n\n```css\n.demo {\n  table-layout: fixed; /* 固定表格布局算法 */\n  width: 100%;\n}\n```\n\n### 背景占屏幕全宽，内容的长度定宽\n\n```css\n.footer {\n  padding: 1em calc(100% - 450px); /* 暗藏内容宽度为 900 px */\n  background: #ccc;\n}\n```'}}]);