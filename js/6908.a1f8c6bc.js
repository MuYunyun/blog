(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6908],{16908:(n,t,e)=>{"use strict";e.r(t),e.d(t,{default:()=>s});var i=e(59713),r=e.n(i),a=e(6479),l=e.n(a),o=(e(67294),e(3905));function c(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,i)}return e}function u(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?c(Object(e),!0).forEach((function(t){r()(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):c(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}var m={};function s(n){var t=n.components,e=l()(n,["components"]);return(0,o.kt)("wrapper",u(u(u({},m),e),{},{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h3",null,"417. Pacific Atlantic Water Flow"),(0,o.kt)("p",null,"Given an ",(0,o.kt)("inlineCode",{parentName:"p"},"m x n")," matrix of non-negative integers representing the height of each unit cell in a continent, ",(0,o.kt)("inlineCode",{parentName:"p"},'the "Pacific ocean" touches the left and top edges of the matrix')," and ",(0,o.kt)("inlineCode",{parentName:"p"},'the "Atlantic ocean" touches the right and bottom edges'),"."),(0,o.kt)("p",null,"Water can only flow in four directions (up, down, left, or right) ",(0,o.kt)("inlineCode",{parentName:"p"},"from a cell to another one with height equal or lower"),"."),(0,o.kt)("p",null,"Find the list of grid coordinates ",(0,o.kt)("inlineCode",{parentName:"p"},"where water can flow to both the Pacific and Atlantic ocean"),"."),(0,o.kt)("p",null,"Note:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The order of returned grid coordinates does not matter."),(0,o.kt)("li",{parentName:"ul"},"Both m and n are less than 150.")),(0,o.kt)("p",null,"Example 1:"),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"Given the following 5 x 5 matrix:\n\nvar test = [[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]\n\n  Pacific ~   ~   ~   ~   ~\n       ~  1   2   2   3  (5) *\n       ~  3   2   3  (4) (4) *\n       ~  2   4  (5)  3   1  *\n       ~ (6) (7)  1   4   5  *\n       ~ (5)  1   1   2   4  *\n          *   *   *   *   * Atlantic\n\nReturn:\n\n[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).\n")),(0,o.kt)("p",null,"Example 2:"),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var test = [[3, 3, 3], [3, 1, 3], [0, 2, 4]]\n\n  Pacific ~   ~   ~\n       ~  3   3   3  *\n       ~  3   1   3  *\n       ~  0   2   4  *\n          *   *   *  Atlantic\n")),(0,o.kt)("h3",null,"Analyze"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"有效出发点:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"存在到 Pacific 的路径;"),(0,o.kt)("li",{parentName:"ul"},"存在到 Atlantic 的路径;"))),(0,o.kt)("li",{parentName:"ul"},"使用「染色算法」在比当前值小的方向递归找寻")),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[][]} matrix\n * @return {number[][]}\n */\nvar pacificAtlantic = function(matrix) {\n  const result = []\n  for (let m = 0; m < matrix.length; m++) {\n    for (let n = 0; n < matrix[m].length; n++) {\n      const usedPacific = []\n      const usedAtlantic = []\n      if (iterator(matrix, m, n, usedPacific, 'pacific')\n        && iterator(matrix, m, n, usedAtlantic, 'atlantic')) {\n        result.push([m, n])\n      }\n    }\n  }\n  return result\n};\n\nvar directions = [[1, 0], [0, 1], [-1, 0], [0, -1]] // bottom、right、top、left\n\nvar iterator = function(matrix, m, n, used, tag) {\n  used.push(`${m},${n}`)\n\n  // achieve the board of matrix\n  if (tag === 'pacific' ? ifReachPacific(m, n) : ifReachAtlantic(matrix, m, n)) {\n    return true\n  }\n\n  for (let i = 0; i < directions.length; i++) {\n    if (!isValid(matrix, m + directions[i][0], n + directions[i][1], used)) continue\n    const newPoint = matrix[m + directions[i][0]][n + directions[i][1]]\n    if (newPoint > matrix[m][n]) {\n      continue\n    }\n    const nextIsValid = iterator(matrix, m + directions[i][0], n + directions[i][1], used, tag)\n    if (nextIsValid) {\n      return true\n    }\n  }\n  return false\n}\n\n// judge if is valid\nvar isValid = (matrix, m, n, used) => {\n  if (used.indexOf(`${m},${n}`) > -1 || !(matrix[m] && typeof matrix[m][n] === 'number')) return false\n  return true\n}\n\nvar ifReachPacific = function(m, n) {\n  return m === 0 || n === 0\n}\n\nvar ifReachAtlantic = function(matrix, m, n) {\n  return m === matrix.length - 1 || n === matrix[0].length - 1\n}\n")),(0,o.kt)("h3",null,"Similar Title"),(0,o.kt)("p",null,"130"))}s.isMDXComponent=!0}}]);