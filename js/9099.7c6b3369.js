(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9099],{59099:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>i});var r=n(59713),a=n.n(r),o=n(6479),p=n.n(o),l=(n(67294),n(3905));function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){a()(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var u={};function i(e){var t=e.components,n=p()(e,["components"]);return(0,l.kt)("wrapper",s(s(s({},u),n),{},{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"随着 ES6 和 TypeScript 中类的引入, 在某些场景需要在不改变原有类和类属性的基础上扩展些功能, 这也是装饰器出现的原因。"),(0,l.kt)("h3",null,"装饰器简介"),(0,l.kt)("p",null,"作为一种可以动态增删功能模块的模式(比如 ",(0,l.kt)("a",s({parentName:"p"},{href:"https://github.com/MuYunyun/blog/issues/15"}),"redux 的中间件机制"),"), 装饰器同样具有很强的动态灵活性, 只需在类或类属性之前加上 ",(0,l.kt)("inlineCode",{parentName:"p"},"@方法名")," 就完成了相应的类或类方法功能的变化。"),(0,l.kt)("p",null,"不过装饰器模式仍处于",(0,l.kt)("a",s({parentName:"p"},{href:"https://github.com/tc39/proposal-decorators"}),"第 2 阶段提案中"),", 使用它之前需要使用 babel 模块 ",(0,l.kt)("inlineCode",{parentName:"p"},"transform-decorators-legacy")," 编译成 ES5 或 ES6。"),(0,l.kt)("p",null,"在 TypeScript 的 ",(0,l.kt)("a",s({parentName:"p"},{href:"https://github.com/Microsoft/TypeScript/blob/c48662c891ce810f5627a0f6a8594049cccceeb5/lib/lib.es5.d.ts#L1291"}),"lib.es5.d.ts")," 中, 定义了 4 种不同装饰器的接口:"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-ts"}),"declare type ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction | void;\ndeclare type PropertyDecorator = (target: Object, propertyKey: string | symbol) => void;\ndeclare type MethodDecorator = <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T> | void;\ndeclare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) => void;\n")),(0,l.kt)("p",null,"下面对装饰类以及装饰类方法进行解析。"),(0,l.kt)("h3",null,"作用于类的装饰器"),(0,l.kt)("p",null,"当装饰的对象是类时, 我们操作的就是这个",(0,l.kt)("inlineCode",{parentName:"p"},"类本身"),"。"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-js"}),"@log\nclass MyClass { }\n\nfunction log(target) { // 这个 target 在这里就是 MyClass 这个类\n   target.prototype.logger = () => `${target.name} 被调用`\n}\n\nconst test = new MyClass()\ntest.logger() // MyClass 被调用\n")),(0,l.kt)("p",null,"由于装饰器是表达式, 我们也可以在装饰器后面再添加提个参数:"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-js"}),"@log('hello')\nclass MyClass { }\n\nfunction log(text) {\n  return function(target) {\n    target.prototype.logger = () => `${text}, ${target.name} 被调用`\n  }\n}\n\nconst test = new MyClass()\ntest.logger() // hello, MyClass 被调用\n")),(0,l.kt)("p",null,"在使用 redux 中, 我们最常使用 react-redux 的写法如下:"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-js"}),"@connect(mapStateToProps, mapDispatchToProps)\nexport default class MyComponent extends React.Component {}\n")),(0,l.kt)("p",null,"经过上述分析, 我们知道了上述写法等价于下面这种写法:"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-js"}),"class MyComponent extends React.Component {}\nexport default connect(mapStateToProps, mapDispatchToProps)(MyComponent)\n")),(0,l.kt)("h3",null,"作用于类方法的装饰器"),(0,l.kt)("p",null,"与装饰类不同, 对类方法的装饰本质是操作其描述符。可以把此时的装饰器理解成是 ",(0,l.kt)("inlineCode",{parentName:"p"},"Object.defineProperty(obj, prop, descriptor)")," 的语法糖, 看如下代码:"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-js"}),"class C {\n  @readonly(false)\n  method() { console.log('cat') }\n}\n\nfunction readonly(value) {\n  return function (target, key, descriptor) { // 此处 target 为 C.prototype; key 为 method;\n    // 原 descriptor 为: { value: f, enumarable: false, writable: true, configurable: true }\n    descriptor.writable = value\n    return descriptor\n  }\n}\n\nconst c = new C()\nc.method = () => console.log('dog')\n\nc.method() // cat\n")),(0,l.kt)("p",null,"可以看到装饰器函数接收的三个参数与 Object.defineProperty 是完全一样的, 具体实现可以看 babel 转化后的代码, 主要实现如下所示:"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-js"}),"var C = (function() {\n  class C {\n    method() { console.log('cat') }\n  }\n\n  var temp\n  temp = readonly(false)(C.prototype, 'method',\n    temp = Object.getOwnPropertyDescriptor(C.prototype, 'method')) || temp // 通过 Object.getOwnPropertyDescriptor 获取到描述符传入到装饰器函数中\n\n  if (temp) Object.defineProperty(C.prototype, 'method', temp)\n  return C\n})()\n")),(0,l.kt)("p",null,"再将再来看看如果有多个装饰器作用于同一个方法上呢？"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-js"}),"class C {\n  @readonly(false)\n  @log\n  method() { }\n}\n")),(0,l.kt)("p",null,"经 babel 转化后的代码如下:"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-js"}),"desc = [readonly(false), log]\n    .slice()\n    .reverse()\n    .reduce(function(desc, decorator) {\n      return decorator(target, property, desc) || desc;\n    }, desc);\n")),(0,l.kt)("p",null,"可以清晰地看出, 经过 reverse 倒序后, 装饰器方法会至里向外执行。"),(0,l.kt)("h3",null,"相关链接"),(0,l.kt)("p",null,(0,l.kt)("a",s({parentName:"p"},{href:"https://github.com/wycats/javascript-decorators"}),"javascript-decorators"),"\n",(0,l.kt)("a",s({parentName:"p"},{href:"https://aotu.io/notes/2016/10/24/decorator/index.html"}),"Javascript 中的装饰器"),"\n",(0,l.kt)("a",s({parentName:"p"},{href:"https://juejin.im/post/59f1c484f265da431c6f8940"}),"JS 装饰器（Decorator）场景实战"),"\n",(0,l.kt)("a",s({parentName:"p"},{href:"http://es6.ruanyifeng.com/#docs/decorator#%E6%96%B9%E6%B3%95%E7%9A%84%E4%BF%AE%E9%A5%B0"}),"修饰器"),"\n",(0,l.kt)("a",s({parentName:"p"},{href:"http://babeljs.io"}),"Babel")))}i.isMDXComponent=!0}}]);