(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9379],{39379:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>s});var r=t(59713),l=t.n(r),a=t(6479),u=t.n(a),o=(t(67294),t(3905));function p(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?p(Object(t),!0).forEach((function(n){l()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):p(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var i={};function s(e){var n=e.components,t=u()(e,["components"]);return(0,o.kt)("wrapper",c(c(c({},i),t),{},{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h3",null,"Remove Linked List Elements"),(0,o.kt)("p",null,"Remove all elements from a linked list of integers that have value val."),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",c({parentName:"pre"},{className:"language-js"}),"Input:  1->2->6->3->4->5->6, val = 6\nOutput: 1->2->3->4->5\n")),(0,o.kt)("h3",null,"Analyze"),(0,o.kt)("pre",null,(0,o.kt)("code",c({parentName:"pre"},{className:"language-js"}),"prev  cur  next\n  1 -> 2 -> 6 -> 3 -> 4 -> 5 -> 6\n")),(0,o.kt)("p",null,"思路:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"借助指针 prev, cur, next",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"若 cur.val 与传入 val 相等, 则让 prev.next 指向 next")))),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"如果只用 cur、next 两个指针, 若 next.val 与 传入 val 相等, 则让 cur = next.next 后的 cur.val 与传入的 val 仍然相等, 此时就无法改变移除当前的 cur 了, 因此需要引入第三个指针 prev。")),(0,o.kt)("pre",null,(0,o.kt)("code",c({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} val\n * @return {ListNode}\n */\nvar removeElements = function(head, val) {\n  const dummyHead = new ListNode(head)\n  dummyHead.next = head\n  let prev = dummyHead\n  let cur = dummyHead.next\n\n  while (cur) {\n    let next = cur.next\n    if (cur.val === val) {\n      prev.next = next\n    } else {\n      prev = cur\n    }\n    cur = next\n  }\n\n  return dummyHead.next\n}\n")),(0,o.kt)("h3",null,"Similar Title"),(0,o.kt)("p",null,"21, 82(Sister Title)"))}s.isMDXComponent=!0}}]);