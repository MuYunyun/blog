(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8141],{58141:n=>{n.exports="### 栈\n\n栈的核心是 FILO, 首先编写一个栈类:\n\n```js\nfunction Stack() {\n  this.items = []\n}\n\nStack.prototype.push = function(item) {\n  this.items.push(item)\n}\n\nStack.prototype.pop = function() {\n  return this.items.pop()\n}\n\nStack.prototype.size = function() {\n  return this.items.length\n}\n\nStack.prototype.isEmpty = function() {\n  return this.items.length === 0\n}\n\nStack.prototype.clear = function() {\n  this.items = []\n}\n```\n\n题目: 实现一个十进制转化为二进制的函数:\n\n```\n6 除以 2 = 3 ... 0     3 除以 2 = 1 ... 1   1 除以 2 = 0 ... 1    110\n测试用例: 6 => 110\n```\n\n```js\nfunction conversion(num) {\n  const stack = new Stack()\n  let remainder\n  while (num > 0) {\n    remainder = num % 2\n    stack.push(remainder)\n    num = Math.floor(num / 2)\n  }\n  let str = ''\n  while (!stack.isEmpty()) {\n    str = str + stack.pop()\n  }\n  return str\n}\n```\n\n题目: 平衡圆括号\n\n```\n测试用例:\n{{([][])}()} => true\n[{()] => false\n```\n\n```js\nfunction isBalance(symbol) {\n  const stack = new Stack()\n  const left = '{[('\n  const right = '}])'\n  let popValue\n  let tag = true\n\n  const match = function(popValue, current) {\n    if (left.indexOf(popValue) !== right.indexOf(current)) {\n      tag = false\n    }\n  }\n\n  for (let i = 0; i < symbol.length; i++) {\n    if (left.includes(symbol[i])) {\n      stack.push(symbol[i])\n    } else if (right.includes(symbol[i])) {\n      popValue = stack.pop()\n      match(popValue, symbol[i])\n    }\n  }\n  return tag\n}\n```\n\n### 扩展: 栈和递归的紧密关系\n\n递归的写法本质上都是运用栈的思想。这里列几道 leetcode 上的题目作为参考\n\n* [Binary Tree Preorder Traversal]([Analyze](https://github.com/MuYunyun/blog/blob/master/LeetCode/144.Binary_Tree_Preorder_Traversal/README.md))\n* [Flatten Nested List Iterator](https://github.com/MuYunyun/blog/blob/master/LeetCode/341.Flatten_Nested_List_Iterator/README.md)"}}]);