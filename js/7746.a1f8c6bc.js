(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7746],{47746:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>m});var l=n(59713),a=n.n(l),i=n(6479),r=n.n(i),p=(n(67294),n(3905));function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,l)}return n}function u(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a()(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var k={};function m(e){var t=e.components,n=r()(e,["components"]);return(0,p.kt)("wrapper",u(u(u({},k),n),{},{components:t,mdxType:"MDXLayout"}),(0,p.kt)("h3",null,"Carousel(走马灯) 组件"),(0,p.kt)("p",null,"事件是交给原生事件还是交由 React 的合成事件呢? 在最初的实现中参考 ",(0,p.kt)("a",u({parentName:"p"},{href:"https://github.com/voronianski/react-swipe/blob/gh-pages/src/index.js"}),"react-swipe")," 相当于是自己封装原生事件。"),(0,p.kt)("p",null,"但是在 React 的生态下，还是尽量用 ",(0,p.kt)("inlineCode",{parentName:"p"},"React")," 封装的合成事件更为妥当。举几个原因:"),(0,p.kt)("ol",null,(0,p.kt)("li",{parentName:"ol"},"兼容性方面的东西不用自己维护了;"),(0,p.kt)("li",{parentName:"ol"},"测试用例用 ",(0,p.kt)("inlineCode",{parentName:"li"},".simulate")," 的时候能统一;")),(0,p.kt)("blockquote",null,(0,p.kt)("p",{parentName:"blockquote"},"原生事件和 React 合成事件类似鱼和熊掌不可兼得。")),(0,p.kt)("h3",null,"前置知识"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"touchStart"),(0,p.kt)("li",{parentName:"ul"},"touchMove"),(0,p.kt)("li",{parentName:"ul"},"touchEnd"),(0,p.kt)("li",{parentName:"ul"},"transitionend")),(0,p.kt)("blockquote",null,(0,p.kt)("p",{parentName:"blockquote"},"e.touches","[0]",".pageX, cdn 讲了其包含水平滚动的位置")),(0,p.kt)("h3",null,"核心思路"),(0,p.kt)("p",null,(0,p.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/8151b27a39eb385305185d0a67736011.jpg-400",alt:null}))),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"比如当前位于第 3 张图片位于中央的时候, 第 1、2 张图片位于左侧的 ",(0,p.kt)("inlineCode",{parentName:"li"},"rest"),", 第 4、5 张图片位于右侧的 ",(0,p.kt)("inlineCode",{parentName:"li"},"rest"),";")),(0,p.kt)("p",null,"初始化阶段对任何窗口执行以下算法:"),(0,p.kt)("ol",null,(0,p.kt)("li",{parentName:"ol"},(0,p.kt)("inlineCode",{parentName:"li"},"向左平移当前窗口数 * width")),(0,p.kt)("li",{parentName:"ol"},"给除了当前展示页加上/减去 ",(0,p.kt)("inlineCode",{parentName:"li"},"width"))),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"每次只操作当前的 ",(0,p.kt)("inlineCode",{parentName:"li"},"index"),", 和其左右的元素 ",(0,p.kt)("inlineCode",{parentName:"li"},"index - 1"),"、",(0,p.kt)("inlineCode",{parentName:"li"},"index + 1"),";"),(0,p.kt)("li",{parentName:"ul"},"自动滑动用的是 css 中的 ",(0,p.kt)("inlineCode",{parentName:"li"},"transitionDuration")," 属性以及 ",(0,p.kt)("inlineCode",{parentName:"li"},"transform")," 属性来完成")),(0,p.kt)("h3",null,"理解易错点"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),"delta = {\n  x: touches.pageX - start.x,\n  y: touches.pageY - start.y\n};\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"手势从左往右滑动是向左滑动 ",(0,p.kt)("inlineCode",{parentName:"li"},"delta.x > 0"),", 手势从右往左滑动是向右滑动 ",(0,p.kt)("inlineCode",{parentName:"li"},"delta.x < 0"))),(0,p.kt)("h3",null,"坑点"),(0,p.kt)("h4",null,"不必要的 id 传入"),(0,p.kt)("p",null,"为了解决在一个页面中使用多处 ",(0,p.kt)("inlineCode",{parentName:"p"},"Swipe")," 组件，首先提供了一个 id 参数来进行区分多个 Swipe 组件, 思路是在封装的组件内部通过 ",(0,p.kt)("inlineCode",{parentName:"p"},"document.getElementById(id)")," 获取到这个 dom 节点，然后进行位置的初始化。"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),'<Swipe\n  id="demo"\n>\n</Swipe>\n')),(0,p.kt)("p",null,"传入额外的 id 这对使用者是一个不必要的负担, 可以在组件内使用 ",(0,p.kt)("inlineCode",{parentName:"p"},"ref")," 获取到对应的 ",(0,p.kt)("inlineCode",{parentName:"p"},"dom"),"。"),(0,p.kt)("h4",null,"如何改造成受控组件"),(0,p.kt)("p",null,"目前的实现为非受控组件, 若要将其改为受控组件, 改的地方比较多, 必须使用 ",(0,p.kt)("inlineCode",{parentName:"p"},"state")," 来替换全局参数。另外位置的信息在 ",(0,p.kt)("inlineCode",{parentName:"p"},"React.cloneElement()")," 中进行处理。"),(0,p.kt)("h4",null,"测试用例之坑"),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"jest")," 跑如下测试用例, 当跑到 ",(0,p.kt)("inlineCode",{parentName:"p"},"componentDidMount")," 里的 ",(0,p.kt)("inlineCode",{parentName:"p"},"document.getElementById('demo')")," 并不拿到相应元素。"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),'mount(<Swipe>\n  <div key="1">PANE 1</div>\n  <div key="2">PANE 2</div>\n  <div key="3">PANE 3</div>\n  <div key="4">PANE 4</div>\n</Swipe>)\n')),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-jsx"}),"componentDidMount() {\n  document.getElementById('demo')\n}\n\nrender() {\n  return (\n    <div id=\"demo\">...</div>\n  )\n}\n")),(0,p.kt)("p",null,"原因是因为 ",(0,p.kt)("inlineCode",{parentName:"p"},"mount")," 渲染组件是挂载到 ",(0,p.kt)("a",u({parentName:"p"},{href:"https://github.com/jsdom/jsdom"}),"jsdom")," 上而非真实 ",(0,p.kt)("inlineCode",{parentName:"p"},"dom")," 上, 当时的解决思路如下:"),(0,p.kt)("pre",null,(0,p.kt)("code",u({parentName:"pre"},{className:"language-js"}),'mount(<Swipe>\n  <div key="1">PANE 1</div>\n  <div key="2">PANE 2</div>\n  <div key="3">PANE 3</div>\n  <div key="4">PANE 4</div>\n</Swipe>, { attatch: document.body })\n')),(0,p.kt)("p",null,"经过上述去除步骤去掉 ",(0,p.kt)("inlineCode",{parentName:"p"},"document.getElementById")," 使用 ref 后, ",(0,p.kt)("inlineCode",{parentName:"p"},"{ attatch: document.body }")," 也便去掉了。"),(0,p.kt)("h3",null,"CSS 方案?"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"scroll-snap-type",(0,p.kt)("ul",{parentName:"li"},(0,p.kt)("li",{parentName:"ul"},"mandatory: the visual viewport of this scroll container will ",(0,p.kt)("inlineCode",{parentName:"li"},"rest on a snap point")," if it isn't currently scrolled."),(0,p.kt)("li",{parentName:"ul"},"proximity: The visual viewport of this scroll container may come to ",(0,p.kt)("inlineCode",{parentName:"li"},"rest on a snap point")," if it isn't currently scrolled considering the user agent's scroll parameters.")))),(0,p.kt)("p",null,(0,p.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/56583153afaa5ae1edad7bea4b728234.jpg-400",alt:null}))),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"scroll-snap-align: start;"),(0,p.kt)("li",{parentName:"ul"},"scroll-snap-stop(experiment)",(0,p.kt)("ul",{parentName:"li"},(0,p.kt)("li",{parentName:"ul"},'always: defining whether the scroll container is allowed to "pass over" possible snap positions(Used with scroll-snap-align can).')))),(0,p.kt)("p",null,"阅读文档后, 该 api 浏览器兼容情况不是特别好(ios 要 11 以上), 此外, 比如循环轮播是无法实现的。"))}m.isMDXComponent=!0}}]);