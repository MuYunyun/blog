(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2707],{82707:(n,t,e)=>{"use strict";e.r(t),e.d(t,{default:()=>p});var l=e(59713),r=e.n(l),i=e(6479),o=e.n(i),s=(e(67294),e(3905));function u(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(n);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,l)}return e}function a(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?u(Object(e),!0).forEach((function(t){r()(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):u(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}var c={};function p(n){var t=n.components,e=o()(n,["components"]);return(0,s.kt)("wrapper",a(a(a({},c),e),{},{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h3",null,"Merge Two Sorted Lists"),(0,s.kt)("p",null,"Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists."),(0,s.kt)("p",null,"Example:"),(0,s.kt)("pre",null,(0,s.kt)("code",a({parentName:"pre"},{className:"language-js"}),"Input: 1->2->4, 1->3->4\nOutput: 1->1->2->3->4->4\n")),(0,s.kt)("h3",null,"analyze"),(0,s.kt)("p",null,"解法一: 链表, 类似归并排序的合并过程, 见",(0,s.kt)("a",a({parentName:"p"},{href:"https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/sort/merge_sort.md"}),"归并排序")),(0,s.kt)("pre",null,(0,s.kt)("code",a({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar mergeTwoLists = function (l1, l2) {\n  const dummyLink = new ListNode(0)\n  let cur = dummyLink\n  let l1Point = l1\n  let l2Point = l2\n\n  while (l1Point && l2Point) {\n    if (l1Point.val < l2Point.val) {\n      cur.next = l1Point\n      l1Point = l1Point.next\n    } else {\n      cur.next = l2Point\n      l2Point = l2Point.next\n    }\n    cur = cur.next\n  }\n\n  while (l1Point) {\n    cur.next = l1Point\n    cur = cur.next\n    l1Point = l1Point.next\n  }\n\n  while (l2Point) {\n    cur.next = l2Point\n    cur = cur.next\n    l2Point = l2Point.next\n  }\n\n  return dummyLink.next\n}\n")),(0,s.kt)("p",null,"解法二: 递归"),(0,s.kt)("pre",null,(0,s.kt)("code",a({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar mergeTwoLists = function (l1, l2) {\n  if (l1 === null) {\n    return l2\n  }\n  if (l2 === null) {\n    return l1\n  }\n  if (l1.val < l2.val) {\n    l1.next = mergeTwoLists(l1.next, l2)\n    return l1\n  } else {\n    l2.next = mergeTwoLists(l1, l2.next)\n    return l2\n  }\n}\n")))}p.isMDXComponent=!0}}]);