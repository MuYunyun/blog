(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4478],{4478:n=>{n.exports="### title\n\nGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n\nNote:\n\nThe solution set must not contain duplicate triplets.\n\nExample:\n\n```js\nGiven array nums = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n```\n\n### 解题\n\n相关思路:\n\n1. 排序;\n2. 查找表;\n3. 双指针;\n\n```js\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar threeSum = function (nums) {\n  const sortNums = nums.sort((r1, r2) => r1 - r2)\n  let targetValue\n  const cacheMap = new Map()\n  const result = []\n\n  for (let i = 0; i < sortNums.length - 2; i++) {\n    targetValue = -sortNums[i]\n    let l = i + 1\n    let r = sortNums.length - 1\n\n    while (l < r) {\n      let tmpArr = []\n      const mapValue = cacheMap.get(`${-targetValue}${sortNums[l]}${sortNums[r]}`)\n      if (sortNums[l] + sortNums[r] === targetValue && !mapValue) {\n        tmpArr.push(-targetValue)\n        tmpArr.push(sortNums[l])\n        tmpArr.push(sortNums[r])\n        result.push(tmpArr)\n        cacheMap.set(`${-targetValue}${sortNums[l]}${sortNums[r]}`, true)\n        l++\n        r--\n      } else if (sortNums[l] + sortNums[r] === targetValue && mapValue) {\n        l++\n      }else if (sortNums[l] + sortNums[r] > targetValue) {\n        r--\n      }else if (sortNums[l] + sortNums[r] < targetValue) {\n        l++\n      }\n    }\n  }\n\n  return result\n}\n```\n\n此时通过测试用例的情况为 312/313, 差一个包含 3000 个 0 数组的测试用例没通过; 根据评论区的提示, 缺少了`对解进行去重`这个步骤(卡主大部分人的原因), 优化如下:\n\n```js\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar threeSum = function (nums) {\n  const sortNums = nums.sort((r1, r2) => r1 - r2)\n  let targetValue\n  const result = []\n\n  for (let i = 0; i < sortNums.length - 2; i++) {\n    // 针对下标 i 对应的值进行去重\n    if (i === 0 || nums[i] > nums[i - 1]) {\n      targetValue = -sortNums[i]\n      let l = i + 1\n      let r = sortNums.length - 1\n\n      while (l < r) {\n        let tmpArr = []\n        if (sortNums[l] + sortNums[r] === targetValue) {\n          tmpArr.push(-targetValue)\n          tmpArr.push(sortNums[l])\n          tmpArr.push(sortNums[r])\n          result.push(tmpArr)\n          l++\n          r--\n          // 针对下标 l 对应的值进行去重, r 同理\n          while (l < r && sortNums[l] === sortNums[l - 1]) {\n            l++\n          }\n          while (l < r && sortNums[r] === sortNums[r + 1]) {\n            r--\n          }\n        } else if (sortNums[l] + sortNums[r] > targetValue) {\n          r--\n        } else if (sortNums[l] + sortNums[r] < targetValue) {\n          l++\n        }\n      }\n    }\n  }\n\n  return result\n}\n```\n\n![](http://with.muyunyun.cn/10dda8915d98182962f44344244e8b5a.jpg-400)\n\n### Sister Title\n\n1、16、18"}}]);