(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3125],{53125:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>m});var a=n(59713),p=n.n(a),l=n(6479),i=n.n(l),r=(n(67294),n(3905));function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function k(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){p()(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var u={};function m(e){var t=e.components,n=i()(e,["components"]);return(0,r.kt)("wrapper",k(k(k({},u),n),{},{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",null,"探寻 JavaScript 精度问题"),(0,r.kt)("p",null,"阅读完本文可以了解到 ",(0,r.kt)("inlineCode",{parentName:"p"},"0.1 + 0.2")," 为什么等于 ",(0,r.kt)("inlineCode",{parentName:"p"},"0.30000000000000004")," 以及 JavaScript 中最大安全数是如何来的。"),(0,r.kt)("h3",null,"十进制小数转为二进制小数方法"),(0,r.kt)("p",null,"拿 173.8125 举例如何将之转化为二进制小数。"),(0,r.kt)("p",null,"①. 针对整数部分 173, 采取",(0,r.kt)("inlineCode",{parentName:"p"},"除 2 取余, 逆序排列"),";"),(0,r.kt)("pre",null,(0,r.kt)("code",k({parentName:"pre"},{className:"language-js"}),"173 / 2 = 86 ... 1\n86 / 2 = 43 ... 0\n43 / 2 = 21 ... 1   ↑\n21 / 2 = 10 ... 1   | 逆序排列\n10 / 2 = 5 ... 0    |\n5 / 2 = 2 ... 1     |\n2 / 2 = 1 ... 0\n1 / 2 = 0 ... 1\n")),(0,r.kt)("p",null,"得整数部分的二进制为 ",(0,r.kt)("inlineCode",{parentName:"p"},"10101101"),"。"),(0,r.kt)("p",null,"②. 针对小数部分 0.8125, 采用",(0,r.kt)("inlineCode",{parentName:"p"},"乘 2 取整, 顺序排列"),";"),(0,r.kt)("pre",null,(0,r.kt)("code",k({parentName:"pre"},{className:"language-js"}),"0.8125 * 2 = 1.625  |\n0.625 * 2 = 1.25    | 顺序排列\n0.25 * 2 = 0.5      |\n0.5 * 2 = 1         ↓\n")),(0,r.kt)("p",null,"得小数部分的二进制为 ",(0,r.kt)("inlineCode",{parentName:"p"},"1101"),"。"),(0,r.kt)("p",null,"③. 将前面两部的结果相加, 结果为 ",(0,r.kt)("inlineCode",{parentName:"p"},"10101101.1101"),";"),(0,r.kt)("h3",null,"小心, 二进制小数丢失了精度！"),(0,r.kt)("p",null,"根据上面的知识, 将十进制小数 ",(0,r.kt)("inlineCode",{parentName:"p"},"0.1")," 转为二进制:"),(0,r.kt)("pre",null,(0,r.kt)("code",k({parentName:"pre"},{className:"language-js"}),"0.1 * 2 = 0.2\n0.2 * 2 = 0.4 // 注意这里\n0.4 * 2 = 0.8\n0.8 * 2 = 1.6\n0.6 * 2 = 1.2\n0.2 * 2 = 0.4 // 注意这里, 循环开始\n0.4 * 2 = 0.8\n0.8 * 2 = 1.6\n0.6 * 2 = 1.2\n...\n")),(0,r.kt)("p",null,"可以发现有限十进制小数 ",(0,r.kt)("inlineCode",{parentName:"p"},"0.1")," 却转化成了无限二进制小数 ",(0,r.kt)("inlineCode",{parentName:"p"},"0.00011001100..."),", 可以看到精度在转化过程中丢失了！"),(0,r.kt)("p",null,"能被转化为有限二进制小数的十进制小数的最后一位必然以 5 结尾(因为只有 0.5 * 2 才能变为整数)。所以十进制中一位小数 ",(0,r.kt)("inlineCode",{parentName:"p"},"0.1 ~ 0.9")," 当中除了 ",(0,r.kt)("inlineCode",{parentName:"p"},"0.5")," 之外的值在转化成二进制的过程中都丢失了精度。"),(0,r.kt)("h3",null,"推导 0.1 + 0.2 为何等于 0.30000000000000004"),(0,r.kt)("p",null,"在 JavaScript 中所有数值都以 IEEE-754 标准的 ",(0,r.kt)("inlineCode",{parentName:"p"},"64 bit")," 双精度浮点数进行存储的。先来了解下 IEEE-754 标准下的",(0,r.kt)("a",k({parentName:"p"},{href:"https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8"}),"双精度浮点数"),"。"),(0,r.kt)("p",null,(0,r.kt)("img",k({parentName:"p"},{src:"http://with.muyunyun.cn/dda7d5b38676abfa13afb344f8a792ed.jpg-300",alt:null}))),(0,r.kt)("p",null,"这幅图很关键, 可以从图中看到 IEEE-754 标准下双精度浮点数由三部分组成, 分别如下:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"sign(符号): 占 1 bit, 0 表示正, 1 表示负;"),(0,r.kt)("li",{parentName:"ul"},"exponent(指数): 占 11 bit, 表示范围;"),(0,r.kt)("li",{parentName:"ul"},"mantissa(尾数): 占 52 bit, 表示精度, 多出的末尾如果是 1 需要进位;")),(0,r.kt)("p",null,"推荐阅读 ",(0,r.kt)("a",k({parentName:"p"},{href:"https://github.com/camsong/blog/issues/9"}),"JavaScript 浮点数陷阱及解法"),", 阅读完该文后可以了解到以下公式的由来。"),(0,r.kt)("p",null,(0,r.kt)("img",k({parentName:"p"},{src:"http://with.muyunyun.cn/5c268e4bd6e0bf2466598d9d5cb58a16.jpg-200",alt:null}))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"精度位总共是 53 bit, 因为用科学计数法表示, 所以首位固定的 1 就没有占用空间。即公式中 (M + 1) 里的 1。另外公式里的 1023 是 2^11 的一半。小于 1023 的用来表示小数, 大于 1023 的用来表示整数。")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"指数可以控制到 2^1024 - 1, 而精度最大只达到 2^53 - 1, 两者相比可以得出 JavaScript 实际可以精确表示的数字其实很少。")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"0.1")," 转化为二进制为 ",(0,r.kt)("inlineCode",{parentName:"p"},"0.0001100110011..."),", 用科学计数法表示为 ",(0,r.kt)("inlineCode",{parentName:"p"},"1.100110011... x 2^(-4)"),", 根据上述公式, ",(0,r.kt)("inlineCode",{parentName:"p"},"S")," 为 ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),"(1 bit), ",(0,r.kt)("inlineCode",{parentName:"p"},"E")," 为 ",(0,r.kt)("inlineCode",{parentName:"p"},"-4 + 1023"),", 对应的二进制为 ",(0,r.kt)("inlineCode",{parentName:"p"},"01111111011"),"(11 bit), ",(0,r.kt)("inlineCode",{parentName:"p"},"M")," 为 ",(0,r.kt)("inlineCode",{parentName:"p"},"1001100110011001100110011001100110011001100110011010"),"(52 bit, 另外注意末尾的进位), ",(0,r.kt)("inlineCode",{parentName:"p"},"0.1")," 的存储示意图如下:"),(0,r.kt)("p",null,(0,r.kt)("img",k({parentName:"p"},{src:"http://with.muyunyun.cn/5b7c0dcc0b1770b6eed238e288eb4c0e.jpg-300",alt:null}))),(0,r.kt)("p",null,"同理, ",(0,r.kt)("inlineCode",{parentName:"p"},"0.2")," 转化为二进制为 ",(0,r.kt)("inlineCode",{parentName:"p"},"0.001100110011..."),", 用科学计数法表示为 ",(0,r.kt)("inlineCode",{parentName:"p"},"1.100110011... x 2^(-3)"),", 根据上述公式, ",(0,r.kt)("inlineCode",{parentName:"p"},"E")," 为 ",(0,r.kt)("inlineCode",{parentName:"p"},"-3 + 1023"),", 对应的二进制为 ",(0,r.kt)("inlineCode",{parentName:"p"},"01111111100"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"M")," 为 ",(0,r.kt)("inlineCode",{parentName:"p"},"1001100110011001100110011001100110011001100110011010"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"0.2")," 的存储示意图如下:"),(0,r.kt)("p",null,(0,r.kt)("img",k({parentName:"p"},{src:"http://with.muyunyun.cn/cb0ef89aa0ed6e8d32b90d1a29cfc9e1.jpg-300",alt:null}))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"0.1 + 0.2")," 即 2^(-4) x 1.1001100110011001100110011001100110011001100110011010 与 2^(-3) x 1.1001100110011001100110011001100110011001100110011010 之和"),(0,r.kt)("pre",null,(0,r.kt)("code",k({parentName:"pre"},{className:"language-js"}),"// 计算过程\n0.00011001100110011001100110011001100110011001100110011010\n0.0011001100110011001100110011001100110011001100110011010\n\n// 相加得\n0.01001100110011001100110011001100110011001100110011001110\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"0.01001100110011001100110011001100110011001100110011001110")," 转化为十进制就是 ",(0,r.kt)("inlineCode",{parentName:"p"},"0.30000000000000004"),"。验证完成!"),(0,r.kt)("h3",null,"JavaScript 的最大安全数是如何来的"),(0,r.kt)("p",null,"根据双精度浮点数的构成, 精度位数是 ",(0,r.kt)("inlineCode",{parentName:"p"},"53 bit"),"。安全数的意思是在 ",(0,r.kt)("inlineCode",{parentName:"p"},"-2^53 ~ 2^53")," 内的整数(不包括边界)与唯一的双精度浮点数互相对应。举个例子比较好理解:"),(0,r.kt)("pre",null,(0,r.kt)("code",k({parentName:"pre"},{className:"language-js"}),"Math.pow(2, 53) === Math.pow(2, 53) + 1 // true\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Math.pow(2, 53)")," 竟然与 ",(0,r.kt)("inlineCode",{parentName:"p"},"Math.pow(2, 53) + 1")," 相等！这是因为 Math.pow(2, 53) + 1 已经超过了尾数的精度限制(53 bit), 在这个例子中 ",(0,r.kt)("inlineCode",{parentName:"p"},"Math.pow(2, 53)")," 和 ",(0,r.kt)("inlineCode",{parentName:"p"},"Math.pow(2, 53) + 1")," 对应了同一个双精度浮点数。所以 ",(0,r.kt)("inlineCode",{parentName:"p"},"Math.pow(2, 53)")," 就不是安全数了。"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"最大的安全数为 ",(0,r.kt)("inlineCode",{parentName:"p"},"Math.pow(2, 53) - 1"),", 即 ",(0,r.kt)("inlineCode",{parentName:"p"},"9007199254740991"),"。")),(0,r.kt)("h3",null,"业务中碰到的精度问题以及解决方案"),(0,r.kt)("p",null,"了解 JavaScript 精度问题对我们业务有什么帮助呢？举个业务场景: 比如有个订单号后端 Java 同学定义的是 long 类型, 但是当这个订单号转换成 JavaScript 的 Number 类型时候精度会丢失了, 那没有以上知识铺垫那就理解不了精度为什么会丢失。"),(0,r.kt)("p",null,"解决方案大致有以下几种:"),(0,r.kt)("p",null,"1.针对大数的整数可以考虑使用 BigInt 类型(目前在 ",(0,r.kt)("del",{parentName:"p"},"stage 3")," stage4 阶段)；"),(0,r.kt)("p",null,"2.使用 ",(0,r.kt)("a",k({parentName:"p"},{href:"https://github.com/MikeMcl/bignumber.js"}),"bigNumber"),", 它的思想是转化成 string 进行处理, 这种方式对性能有一定影响;"),(0,r.kt)("p",null,"3.可以考虑使用 ",(0,r.kt)("a",k({parentName:"p"},{href:"https://github.com/dcodeIO/long.js"}),"long.js"),", 它的思想是将长度为 64 位的 long 类型值转化成两个精度为 32 位的双精度类型的值。"),(0,r.kt)("p",null,"4.针对小数的话可以使用 ",(0,r.kt)("a",k({parentName:"p"},{href:"https://github.com/nefe/number-precision"}),"number-precision"),", 该库将小数转为整数后再作处理;"),(0,r.kt)("h3",null,"相关链接"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",k({parentName:"li"},{href:"http://justjavac.com/codepuzzle/2012/11/11/codepuzzle-float-who-stole-your-accuracy.html"}),"代码之谜系列")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",k({parentName:"li"},{href:"https://github.com/camsong/blog/issues/9"}),"JavaScript 浮点数陷阱及解法"),": 推荐阅读"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",k({parentName:"li"},{href:"https://www.zhihu.com/question/29010688"}),"javascript 里最大的安全的整数为什么是 2 的 53 次方减一")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",k({parentName:"li"},{href:"http://www.binaryconvert.com/convert_double.html"}),"IEEE-754 进制转换图生成"),": 工具"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",k({parentName:"li"},{href:"https://www.sojson.com/hexconvert.html"}),"在线进制转换工具"),": 工具")))}m.isMDXComponent=!0}}]);