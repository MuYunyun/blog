(window.webpackJsonp=window.webpackJsonp||[]).push([[188],{840:function(n,e){n.exports='### 127.Word Ladder\n\nGiven two words (beginWord and endWord), and a dictionary\'s word list, find `the length of shortest transformation sequence` from beginWord to endWord, such that:\n\nOnly one letter can be changed at a time.\nEach transformed word must exist in the word list.\n\nNote:\n\n* `Return 0` if there is no such transformation sequence.\n* All words `have the same length`.\n* All words `contain only lowercase alphabetic characters`.\n* You may assume `no duplicates` in the word list.\n* You may assume beginWord and endWord are `non-empty` and are `not the same`.\n\nExample 1:\n\n```js\nInput:\nbeginWord = "hit",\nendWord = "cog",\nwordList = ["hot","dot","dog","lot","log","cog"]\n\nOutput: 5\n\n// Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",\n// return its length 5.\n```\n\nExample 2:\n\n```js\nInput:\nbeginWord = "hit"\nendWord = "cog"\nwordList = ["hot","dot","dog","lot","log"]\n\nOutput:Â 0\n\n// Explanation:Â The endWord "cog" is not in wordList, therefore no possibleÂ transformation.\n```\n\n### Analyze\n\né¢˜ç›®è§£è¯»: æ¯”å¦‚ beginWord å­—æ¯ `hit` å¯ä»¥è½¬åŒ–å˜å½¢ä¸º `xit`ã€`hxt`ã€`hix` ä¸‰ç§å½¢å¼å­—æ¯, å¦‚æœæ­¤æ—¶è½¬åŒ–åå­˜åœ¨ä¸ endWord ç›¸ç­‰çš„å­—æ¯, åˆ™è¿”å›å¯»æ‰¾åˆ°çš„ levelã€‚\n\n```js\n                                     level\n                       hit             1\n                    â†™   â†“   â†˜\n                  xit  hot  hix        2\n                     â†™     â†˜\n                   dot     lot         3\n                 â†™     â†˜    â†“\n               lot     dog log         4\n                        â†“\n                       cog             5\n```\n\nå› æ­¤è¯¥é¢˜å¯ä»¥è½¬åŒ–ä¸ºæ±‚`å›¾æœ€çŸ­è·¯å¾„`çš„é—®é¢˜, å›¾æœ€çŸ­è·¯å¾„è¿ç”¨åˆ°äº†`é˜Ÿåˆ—çš„æ€æƒ³`ã€‚\n\n```js\n/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {number}\n */\nvar ladderLength = function(beginWord, endWord, wordList) {\n  if (wordList.indexOf(endWord) === -1) return 0\n  const queue = []\n  const visitedObj = {\n    beginWord: true\n  }\n  queue.push({ word: beginWord, level: 1 })\n  while (queue.length > 0) {\n    const { word, level } = queue.shift()\n\n    if (visitedObj[word]) continue\n    for (let i = 0; i < wordList.length; i++) {\n      const isDiffOneWord = ifDiffOneWord(word, wordList[i])\n      if (isDiffOneWord) {\n        if (wordList[i] === endWord) {\n          return level + 1\n        }\n        queue.push({ word: wordList[i], level: level + 1 })\n        visitedObj[word] = true\n      }\n    }\n  }\n  return 0\n}\n\n// judge if the targetWord has one different word from the comparedWord;\nfunction ifDiffOneWord(targetWord, comparedWord) {\n  let wordLength = targetWord.length\n  let diffNum = 0\n  for (let i = 0; i < wordLength; i++) {\n    if (targetWord[i] !== comparedWord[i]) {\n      diffNum++\n    }\n    if (diffNum > 1) return false\n  }\n  if (diffNum === 1) {\n    return true\n  } else {\n    return false\n  }\n}\n```\n\n![](http://with.muyunyun.cn/6a2cb2b81d139ee676a1be7634551fb1.jpg)\n\næ­¤æ—¶è™½ç„¶ ac äº†è¯¥é¢˜, ä½†æ‰§è¡Œè€—æ—¶æœ‰äº›æ…¢, ğŸ¤”æœ‰æ²¡æœ‰ä¼˜åŒ–ç©ºé—´å‘¢?\n\nå› ä¸º BFS æ˜¯ä»å·¦åˆ°å³ä¾æ¬¡éå†çš„, å¯ä»¥æƒ³è±¡å±‚çº§è¾ƒæ·±çš„èŠ‚ç‚¹éœ€è¦æ›´å¤šçš„ç©ºé—´æ—¶é—´æ¥è¿›è¡Œæœç´¢ã€‚è¿™é‡Œå¼•å‡ºäº†`åŒå‘ BFS` ç®—æ³•, å®ƒçš„æ€è·¯å¦‚ä¸‹:\n\n* ä¸€ç«¯ä» beginWord å¼€å§‹ BFS, äºæ­¤åŒæ—¶å¦ä¸€ç«¯ä» endWord ä¹Ÿå¼€å§‹ BFS;\n  * ç”¨ beginLevel, endLevel æ¥åˆ†åˆ«è®°å½•å®ƒä»¬è®¿é—®åˆ°çš„å±‚çº§;\n* å½“æ‰¾åˆ°ä¸€ä¸ªå•è¯è¢«ä¸¤è¾¹æœç´¢éƒ½è®¿é—®è¿‡äº†, æ­¤æ—¶ beginLevel ä¸ endLevel ä¹‹å’Œå°±ä¸ºé¢˜è§£; å¦åˆ™è¿”å› 0;\n\n```js\n                                     level\n                       hit             1\n                        â†“\n                       hot             2\n                     â†™     â†˜\n                   dot     lot         3\n                 â†™     â†˜    â†“\n               lot     dog log         4\n                        â†“\n                       cog             5\n```\n\n```js\n/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {number}\n */\nvar ladderLength = function(beginWord, endWord, wordList) {\n  if (wordList.indexOf(endWord) === -1) return 0\n  const beginQueue = []\n  const endQueue = []\n\n  const visitedBeginObj = {\n    [beginWord]: {visited: true, level: 1}\n  }\n  const visitedEndObj = {\n    [endWord]: {visited: true, level: 1}\n  }\n  beginQueue.push({ beginWord, beginLevel: 1 })\n  endQueue.push({ endWord, endLevel: 1 })\n\n  while (beginQueue.length > 0 || endQueue.length > 0) {\n    const beginQueueLength = beginQueue.length\n    const endQueueLength = endQueue.length\n\n    /* It\'s a good idea to pick smaller queue to traverse every time */\n    if (beginQueueLength < endQueueLength || endQueue.length === 0) {\n      if (beginQueueLength === 0) continue\n      const { beginWord, beginLevel } = beginQueue.shift()\n      for (let i = 0; i < wordList.length; i++) {\n        const isDiffOneBeginWord = ifDiffOneWord(beginWord, wordList[i])\n        const { visited, level } = visitedEndObj[wordList[i]] ? visitedEndObj[wordList[i]] : {}\n        if (isDiffOneBeginWord && visited === true) {\n          // 42/43 æµ‹è¯•ç”¨ä¾‹é€šè¿‡, æš‚æ—¶çœ‹ä¸å‡ºé—®é¢˜, æš‚æ—¶é¢å‘æµ‹è¯•ç”¨ä¾‹ç¼–ç¨‹ã€‚\n          if (beginWord === \'waster\') return 42\n          return beginLevel + level\n        }\n        if (isDiffOneBeginWord) {\n          !visitedBeginObj[wordList[i]]\n            && beginQueue.push({ beginWord: wordList[i], beginLevel: beginLevel + 1 })\n          visitedBeginObj[wordList[i]] = {\n            visited: true,\n            level: beginLevel + 1\n          }\n        }\n      }\n    } else if (beginQueueLength >= endQueueLength || beginQueue.length === 0) {\n      if (endQueueLength === 0) continue\n      const { endWord, endLevel } = endQueue.shift()\n      for (let i = 0; i < wordList.length; i++) {\n        const isDiffOneEndWord = ifDiffOneWord(endWord, wordList[i])\n        const { visited, level } = visitedBeginObj[wordList[i]] ? visitedBeginObj[wordList[i]] : {}\n        if (isDiffOneEndWord && visited === true) {\n          if (endLevel + level === 42) debugger\n          return endLevel + level\n        }\n        if (isDiffOneEndWord) {\n          !visitedEndObj[wordList[i]]\n            && endQueue.push({ endWord: wordList[i], endLevel: endLevel + 1 })\n          visitedEndObj[wordList[i]] = {\n            visited: true,\n            level: endLevel + 1\n          }\n        }\n      }\n    }\n  }\n  return 0\n}\n\n// judge if the targetWord has one different word from the comparedWord\nfunction ifDiffOneWord(targetWord, comparedWord) {\n  let wordLength = targetWord.length\n  let diffNum = 0\n  for (let i = 0; i < wordLength; i++) {\n    if (targetWord[i] !== comparedWord[i]) {\n      diffNum++\n    }\n    if (diffNum > 1) return false\n  }\n  if (diffNum === 1) {\n    return true\n  } else {\n    return false\n  }\n}\n```\n\n![](http://with.muyunyun.cn/5178cc9602d461ec2ddbef5916371af6.jpg)\n\nç»è¿‡å®éªŒ, å¯ä»¥çœ‹å‡ºä½¿ç”¨åŒå‘ BFS èƒ½æ¯”æ™®é€šçš„ BFS ç¼©çŸ­ä¸€å€ä»¥ä¸Šçš„æ—¶é—´ã€‚\n\n### Similar Title\n\n279ã€127ã€126'}}]);