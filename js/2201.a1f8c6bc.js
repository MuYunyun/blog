(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2201],{12201:(n,t,e)=>{"use strict";e.r(t),e.d(t,{default:()=>p});var l=e(59713),r=e.n(l),i=e(6479),s=e.n(i),o=(e(67294),e(3905));function u(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(n);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,l)}return e}function a(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?u(Object(e),!0).forEach((function(t){r()(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):u(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}var c={};function p(n){var t=n.components,e=s()(n,["components"]);return(0,o.kt)("wrapper",a(a(a({},c),e),{},{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h3",null,"Add Two Numbers II"),(0,o.kt)("p",null,"You are given two non-empty linked lists representing two non-negative integers. ",(0,o.kt)("inlineCode",{parentName:"p"},"The most significant digit comes first")," and each of their nodes contain a single digit. Add the two numbers and return it as a linked list."),(0,o.kt)("p",null,"You may assume the two numbers do not contain any leading zero, except the number 0 itself."),(0,o.kt)("p",null,"Follow up:"),(0,o.kt)("p",null,"What if you cannot modify the input lists? In other words, reversing the lists is not allowed."),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",a({parentName:"pre"},{className:"language-js"}),"Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 8 -> 0 -> 7\n")),(0,o.kt)("h3",null,"Analyze"),(0,o.kt)("p",null,"思考: 相对题 2 的逆序相加, 该题顺序相加作如下思考:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"第一步: 首先补齐位数, 让其一一对应;")),(0,o.kt)("pre",null,(0,o.kt)("code",a({parentName:"pre"},{className:"language-js"}),"7  ->  2  ->  4  ->  3\n0  ->  5  ->  6  ->  4\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"第二步: 递归计算两个链表同位之和, 同时使用 digitCarry 表示进位的情况;")),(0,o.kt)("pre",null,(0,o.kt)("code",a({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function(l1, l2) {\n  let countl1 = 0, countl2 = 0\n  let l1List = l1\n  let l2List = l2\n  while(l1List) {\n    countl1++\n    l1List = l1List.next\n  }\n\n  while(l2List) {\n    countl2++\n    l2List = l2List.next\n  }\n\n  // creat the frontest List\n  let tmpList = new ListNode(0)\n  let cur = tmpList\n  let diff = Math.abs(countl2 - countl1)\n  while (diff--) {\n    cur.next = new ListNode(0)\n    cur = cur.next\n  }\n\n  if (countl1 < countl2) {\n    cur.next = l1\n    l1 = tmpList.next\n  } else if (countl2 < countl1) {\n    cur.next = l2\n    l2 = tmpList.next\n  }\n\n\n  // flag: 1 shows digit carry, 0 not;\n  let digitCarry = 0\n\n  /**\n   * calculate the sum of l1 and l2\n   */\n  function listNodeAdd(l1, l2) {\n    if (l1 === null) return\n\n    listNodeAdd(l1.next, l2.next)\n\n    let sum = l1.val + l2.val + digitCarry\n    if (sum >= 10) {\n      l1.val = sum % 10\n      digitCarry = 1\n    } else {\n      l1.val = sum\n      digitCarry = 0\n    }\n  }\n\n  listNodeAdd(l1, l2)\n\n  let result = l1\n  if (digitCarry === 1) {\n    result = new ListNode(1)\n    result.next = l1\n  }\n\n  return result\n}\n")),(0,o.kt)("p",null,(0,o.kt)("img",a({parentName:"p"},{src:"http://with.muyunyun.cn/c2559f9251487e23530e6932cc46516b.jpg-400",alt:null}))),(0,o.kt)("h3",null,"Sister Title"),(0,o.kt)("p",null,"2"))}p.isMDXComponent=!0}}]);