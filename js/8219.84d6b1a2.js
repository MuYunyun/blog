(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8219],{18219:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>p});var r=t(59713),l=t.n(r),a=t(6479),o=t.n(a),i=(t(67294),t(3905));function s(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function u(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?s(Object(t),!0).forEach((function(e){l()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var d={};function p(n){var e=n.components,t=o()(n,["components"]);return(0,i.kt)("wrapper",u(u(u({},d),t),{},{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h3",null,"98.Validate Binary Search Tree"),(0,i.kt)("p",null,"Given a binary tree, determine if it is a valid binary search tree (BST)."),(0,i.kt)("p",null,"Assume a BST is defined as follows:"),(0,i.kt)("p",null,"The left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees."),(0,i.kt)("p",null," \nExample 1:"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-js"}),"    2\n   / \\\n  1   3\n\nInput: [2,1,3]\nOutput: true\n")),(0,i.kt)("p",null,"Example 2:"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-js"}),"    5\n   / \\\n  1   4\n     / \\\n    3   6\n\nInput: [5,1,4,null,null,3,6]\nOutput: false\n")),(0,i.kt)("p",null,"Explanation: The root node's value is 5 but its right child's value is 4."),(0,i.kt)("h3",null,"Analyze"),(0,i.kt)("p",null,"一开始的想法是用后续遍历判断子节点是否为二分搜索树, 实现如下:"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n  return isValidBSTChild(root)\n};\n\nvar isValidBSTChild = function(node) {\n  if (!node || (!node.left && !node.right)) return true\n\n  const isLeftChildValidBST = isValidBSTChild(node.left)\n  const isRightChildValidBST = isValidBSTChild(node.right)\n  if (!isLeftChildValidBST || !isRightChildValidBST) return false\n\n  // defination for BST tree\n  if (node.right && node.left && node.right.val > node.val && node.val > node.left.val) return true\n  if (node.right && !node.left && node.right.val > node.val) return true\n  if (node.left && !node.right && node.left.val < node.val) return true\n  return false\n};\n")),(0,i.kt)("p",null,"结果卡在了如下测试用例中:"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-js"}),"    10\n   /  \\\n  5   15\n     /  \\\n    6   20\n\nInput: [10,5,15,null,null,6,20]\nExpect Output: false\n")),(0,i.kt)("p",null,"参考评论区的点拨, 题目等价为经过",(0,i.kt)("inlineCode",{parentName:"p"},"中序遍历"),"输出后的节点是否为升序排列。再次实现:"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n  const analyze = []\n  inOrderTraverse(root, analyze)\n  for (let i = 0; i < analyze.length; i++) {\n    if (analyze[i] >= analyze[i + 1]) return false\n  }\n  return true\n};\n\nvar inOrderTraverse = function(node, analyzeArr) {\n  if (!node) return\n  inOrderTraverse(node.left, analyzeArr)\n  analyzeArr.push(node.val)\n  inOrderTraverse(node.right, analyzeArr)\n}\n")))}p.isMDXComponent=!0}}]);