(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7562],{67562:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>m});var l=t(59713),i=t.n(l),r=t(6479),a=t.n(r),u=(t(67294),t(3905));function p(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(n);e&&(l=l.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,l)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?p(Object(t),!0).forEach((function(e){i()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):p(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var s={};function m(n){var e=n.components,t=a()(n,["components"]);return(0,u.kt)("wrapper",o(o(o({},s),t),{},{components:e,mdxType:"MDXLayout"}),(0,u.kt)("h3",null,"51. N-Queens"),(0,u.kt)("p",null,"The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other."),(0,u.kt)("p",null,"Given an integer n, return the number of distinct solutions to the n-queens puzzle."),(0,u.kt)("p",null,"Example 1:"),(0,u.kt)("pre",null,(0,u.kt)("code",o({parentName:"pre"},{className:"language-js"}),"Input: n = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown.\n\n. Q . .            . . Q .\n. . . Q     or     Q . . .\nQ . . .            . . . Q\n. . Q .            . Q . .\n")),(0,u.kt)("p",null,"Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above."),(0,u.kt)("p",null,"Example 2:"),(0,u.kt)("pre",null,(0,u.kt)("code",o({parentName:"pre"},{className:"language-js"}),"Input: n = 1\nOutput: 1\n")),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},"Constraints:",(0,u.kt)("ul",{parentName:"li"},(0,u.kt)("li",{parentName:"ul"},"1 <= n <= 9")))),(0,u.kt)("h3",null,"Analyze"),(0,u.kt)("pre",null,(0,u.kt)("code",o({parentName:"pre"},{className:"language-js"}),"    0   1   2   3\n0   .   Q   .   .\n\n1   .   .   .   Q\n\n2   Q   .   .   .\n\n3   .   .   Q   .\n")),(0,u.kt)("p",null,"关于斜对角线上的限制可以得出以下两条规律。"),(0,u.kt)("ol",null,(0,u.kt)("li",{parentName:"ol"},"罗列从",(0,u.kt)("inlineCode",{parentName:"li"},"右上到左下"),"斜线点发现规律: ",(0,u.kt)("inlineCode",{parentName:"li"},"横坐标与纵坐标之和为定值"),"。")),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"(0, 0)")),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"(0, 1)、(1, 0)")),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"(0, 2)、(1, 1)、(2, 0)")),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"(0, 3)、(1, 2)、(2, 1)、(3, 0)")),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"(1, 3)、(2, 2)、(3, 1)")),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"(2, 3)、(3, 2)")),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"(3, 3)"))),(0,u.kt)("ol",o({},{start:2}),(0,u.kt)("li",{parentName:"ol"},"罗列从",(0,u.kt)("inlineCode",{parentName:"li"},"左上到右下"),"斜线点发现规律: ",(0,u.kt)("inlineCode",{parentName:"li"},"横坐标与纵坐标之差为定值"),"。")),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"(3, 0)")),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"(2, 0)、(3, 1)")),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"(1, 0)、(2, 1)、(3, 2)")),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"(0, 0)、(1, 1)、(2, 2)、(3, 3)")),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"(0, 1)、(1, 2)、(2, 3)")),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"(0, 2)、(1, 3)")),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"(0, 3)"))),(0,u.kt)("pre",null,(0,u.kt)("code",o({parentName:"pre"},{className:"language-js"}),'/**\n * @param {number} n\n * @return {number}\n */\nvar totalNQueens = function(n) {\n  const result = []\n  const limit = {\n    used: [],\n    x: [],\n    y: [],\n    sum: [],\n    diff: []\n  }\n  handleNQueens(n, 0, limit, result)\n  return result.length\n};\n\n// eg: when n is 4, arr is [["0,1", "1,3", "2,0", "3,2"], ["0,2", "1,0", "2,3", "3,1"]]\nvar generate = (arr) => {\n  const xArr = []\n  for (let x = 0; x < arr.length; x++) {\n    const [queueX, queueY] = arr[x].split(\',\')\n    let yStr = \'\'\n    for (let y = 0; y < arr.length; y++) {\n      if (x === Number(queueX) && y === Number(queueY)) {\n        yStr = yStr + \'Q\'\n      } else {\n        yStr = yStr + \'.\'\n      }\n    }\n    xArr.push(yStr)\n  }\n  return xArr\n}\n\n// handle the position with the index row from n Queue.\nvar handleNQueens = (n, index, limit, result) => {\n  if (limit.x.length === n) {\n    result.push(generate([...limit.used]))\n    return\n  }\n\n  // 第 index 行安置在第几列中\n  for (let y = 0; y < n; y++) {\n    const sum = index + y\n    const diff = index - y\n    if (\n      limit.used.indexOf(`${index},${y}`) > -1\n      || limit.x.indexOf(index) > -1\n      || limit.y.indexOf(y) > -1\n      || limit.sum.indexOf(sum) > -1\n      || limit.diff.indexOf(diff) > -1\n    ) {\n      continue\n    }\n    limit.used.push(`${index},${y}`)\n    limit.x.push(index)\n    limit.y.push(y)\n    limit.sum.push(sum)\n    limit.diff.push(diff)\n\n    handleNQueens(n, index + 1, limit, result)\n    limit.used.pop()\n    limit.x.pop()\n    limit.y.pop()\n    limit.sum.pop()\n    limit.diff.pop()\n  }\n}\n')))}m.isMDXComponent=!0}}]);