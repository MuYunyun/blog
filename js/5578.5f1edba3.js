(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5578],{5578:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>s});var r=t(59713),a=t.n(r),p=t(6479),o=t.n(p),l=(t(67294),t(3905));function c(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function u(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?c(Object(t),!0).forEach((function(e){a()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var i={};function s(n){var e=n.components,t=o()(n,["components"]);return(0,l.kt)("wrapper",u(u(u({},i),t),{},{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h3",null,"贪心算法"),(0,l.kt)("p",null,"贪心算法是一种求近似解的思想。当能满足大部分最优解时就认为符合逻辑要求。"),(0,l.kt)("h3",null,"例子"),(0,l.kt)("p",null,"以 ",(0,l.kt)("a",u({parentName:"p"},{href:"https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md#%E6%A1%88%E4%BE%8B--%E6%9C%80%E5%B0%8F%E6%89%BE%E9%9B%B6%E7%A1%AC%E5%B8%81%E6%95%B0"}),"最小找零硬币数")," 这个案例为例, 考虑使用贪心算法解题: 比如当找零数为 36 时, 从硬币数的最大值 20 开始填充, 填充不下后再用 10 来填充, 以此类推, 找到最优解。"),(0,l.kt)("pre",null,(0,l.kt)("code",u({parentName:"pre"},{}),"场景: 假如有 1, 5, 10, 20 美分的硬币\n\n36             // 找零数\n[20, 10, 5, 1] // 需 20、10、5、1美分的硬币各一个\n")),(0,l.kt)("p",null,"代码如下:"),(0,l.kt)("pre",null,(0,l.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var MinChange = function (changeType) {\n  this.changeType = changeType.sort((r1, r2) => r2 - r1)\n}\n\nMinChange.prototype.makeChange = function(amount) {\n  const arr = []\n  for (let i = 0; i < this.changeType.length; i++) {\n    while (amount - this.changeType[i] >= 0) {\n      arr.push(this.changeType[i])\n      amount = amount - this.changeType[i]\n    }\n  }\n  return arr\n}\n")),(0,l.kt)("p",null,"来测试下:"),(0,l.kt)("pre",null,(0,l.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var minChange = new MinChange([1, 5, 10, 20])\n\nminChange.makeChange(36) // [20, 10, 5, 1]\n")),(0,l.kt)("p",null,"相比于动态规划算法, 贪心算法实现得相对简单, 而且也确实满足了大部分情况下的最优解。但是如下情况贪心算法就不满足了:"),(0,l.kt)("pre",null,(0,l.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var minChange = new MinChange([1, 3, 3, 4])\n\nminChange.makeChange(6) // 结果输出 [4, 1, 1], 而我们期望的是 [3, 3]\n")))}s.isMDXComponent=!0}}]);