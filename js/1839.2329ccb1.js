(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1839],{31839:(e,n,r)=>{"use strict";r.r(n),r.d(n,{default:()=>m});var t=r(59713),a=r.n(t),o=r(6479),i=r.n(o),l=(r(67294),r(3905));function c(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function s(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?c(Object(r),!0).forEach((function(n){a()(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):c(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}var p={};function m(e){var n=e.components,r=i()(e,["components"]);return(0,l.kt)("wrapper",s(s(s({},p),r),{},{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h3",null,"RPC 是什么"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"RPC(Remote Procedure Call) 译为远端过程调用。即在一台机子上能调用到另外一台机子上的服务;"),(0,l.kt)("li",{parentName:"ul"},"RPC 可以基于 HTTP 调用也可以基于 TCP 调用。基于 TCP 调用性能更佳, 但是实现也更为复杂;"),(0,l.kt)("li",{parentName:"ul"},"RPC 通常要实现两部分协议, 一个是应用层协议(如 JSON), 一个是用来传输数据的通讯层协议(如 Dubbo);")),(0,l.kt)("h3",null,"RPC 调用过程"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"调用方通过本地网关调用相应服务;"),(0,l.kt)("li",{parentName:"ol"},"网关将服务名和参数封装为 RPC 对象传给客户端 RPC 框架(@dwd/noob-client);"),(0,l.kt)("li",{parentName:"ol"},"客户端 RPC 框架(@dwd/noob-client)将数据转化成二进制形式, 然后以 TCP 的形式传递给服务端 RPC 框架;"),(0,l.kt)("li",{parentName:"ol"},"服务端 RPC 框架将二进制数据反序列化为 RPC 对象, 并交由服务方处理, 服务端处理后返回结果;"),(0,l.kt)("li",{parentName:"ol"},"执行上述阶段的逆序操作;")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"关于 RPC 细节点, 可以阅读 ",(0,l.kt)("a",s({parentName:"p"},{href:"https://www.yuque.com/egg/nodejs/dklip5"}),"聊聊 Node.js RPC（一）— 协议"))),(0,l.kt)("h3",null,"结合代码分析 Java 包的调用过程"),(0,l.kt)("h4",null,"初始化阶段 —— RPC 调用之前"),(0,l.kt)("p",null,"在项目刚启动阶段, 网关项目会通过 zk(路由管理系统) 进行路由寻址(寻找相应后端组的服务), 后续网关项目就能和相应的后端组的服务直接通讯了。"),(0,l.kt)("p",null,"在初始化阶段, 网关项目会将项目信息、注册区域(异地多活)、所需服务等传递给 ",(0,l.kt)("a",s({parentName:"p"},{href:"http://192.168.1.66:9090/FE/noob-client"}),"@dwd/noob-client"),", 相关代码如下:"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-js"}),"import { Client } from '@dwd/noob-client'\n\nconst client = new Client({\n  application: {                // 项目信息\n    name: config.name,\n  },\n  registry: config.registry,    // 注册区域\n  reference: config.references, // 所需服务\n  routerServer: { address: routerAddress },\n})\n\nreturn client.init().then(() => {\n  for (const r of config.references) {\n    loadService(r.id)\n  }\n})\n")),(0,l.kt)("h4",null,"根据 xml 文件生成相关的包文件"),(0,l.kt)("p",null,"在项目伊始时, 会通过后端给出的 xml 文件, 根据脚本生成相应包的 ts 文件。比如以下代码为骑手服务组的一个包的 ts 文件。"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-ts"}),'import { Reference } from \'@dwd/noob\'\nimport { provideService, javaType} from \'../../util/dubbo\'\n\n@provideService(\'com.dianwoba.rider.elastic.provider.RiderElasticProvider\')\nexport default class RiderElasticProvider implements com.dianwoba.rider.elastic.provider.RiderElasticProvider {\n\n  constructor(private _ref: Reference<com.dianwoba.rider.elastic.provider.RiderElasticProvider> ) {}\n\n  async pageSearch(@javaType({"name":"com.dianwoba.rider.elastic.domain.dto.param.RiderEsParamDTO","isPrimitive":false,"isArray":false,"isGeneric":false}) paramDTO: com.dianwoba.rider.elastic.domain.dto.param.RiderEsParamDTO) : Promise<com.dianwoba.dubbo.base.result.Pagination<com.dianwoba.rider.elastic.domain.dto.result.RiderEsDTO>> {\n    return this._ref.invoke(\'pageSearch\', Array.from(arguments))\n  }\n\n  ...\n}\n')),(0,l.kt)("h4",null,"RiderElasticProvider 的实例化"),(0,l.kt)("p",null,"网关的核心架构使用了 IoC 框架 ",(0,l.kt)("a",s({parentName:"p"},{href:"https://github.com/inversify/InversifyJS"}),"inverify"),"。在 IoC 架构下, 实例化的过程在容器内进行。"),(0,l.kt)("p",null,"在上述代码点开 ",(0,l.kt)("inlineCode",{parentName:"p"},"provideService")," 方法, 可以看到实例化的过程 ",(0,l.kt)("inlineCode",{parentName:"p"},"new ServiceClass(reference)"),", 代码如下:"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-ts"}),"// dubbo.ts\nimport { Client } from '@dwd/noob-client'\n\nexport const provideService = <T>(interfaceName: string) => (ServiceClass: interfaces.Newable<T>) => {\n  const reference = Client.reference.get(interfaceName)                    // 获取远程引用资源\n  const service = proxyService(new ServiceClass(reference), interfaceName) // 代理实例对象, 下文解析\n  moduleBind<T>(interfaceName).toConstantValue(service)                    // 依赖注入\n}\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("inlineCode",{parentName:"p"},"reference")," 对象的 ",(0,l.kt)("inlineCode",{parentName:"p"},"__proto__")," 属性上有 invoke 方法(继承自 @dwd/noob)")),(0,l.kt)("h4",null,"proxyService 代理"),(0,l.kt)("p",null,"proxyService 方法的作用给包类的每个方法做了一层代理, 代理的具体作用是将传入参数和包名包装为 RPC 对象。"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-ts"}),"// dubbo.ts\nfunction proxyService<T>(service:T, identifier: string) {\n  let handler = {\n    apply: function(target: Function, thisArgument: any, argumentsList: any[]) {\n      let funcName = target.name\n      // 获取前面代码 @javaType({}) 中声明的对象\n      let paramTypes: JavaType[] = Reflect.getMetadata(JAVATYPE_SYMBOL, service, funcName)\n      // 工厂模式创建转化为 RPC 对象的方法\n      let transform = converter.methodParameterTransformerFactory(...paramTypes)\n      // 将传入参数和包名转化为 RPC 对象\n      let args = transform(argumentsList)\n      return target.apply(thisArgument, args)\n    }\n  }\n  Object.getOwnPropertyNames(Object.getPrototypeOf(service)).filter(name => name !== 'constructor' && !name.startsWith('_')).forEach(methodName => {\n    service[methodName] = new Proxy(service[methodName], handler) // 将原型链上 service[methodName] 赋值到 service[methodName] 上, 并用 handler 进行代理\n  })\n  return service\n}\n")),(0,l.kt)("h3",null,"番外笔记"),(0,l.kt)("h4",null,"ts 的语法"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-ts"}),"class Test {\n  constructor(private _ref) {}\n}\n")),(0,l.kt)("p",null,"ts 转换为 js 的形式如下"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-js"}),"function Test(_ref) {\n  this._ref = _ref\n}\n")))}m.isMDXComponent=!0}}]);