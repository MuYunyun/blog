(window.webpackJsonp=window.webpackJsonp||[]).push([[172],{824:function(n,e){n.exports="### 装饰者模式\n\n装饰器模式: 动态地给函数赋能。\n\n### JavaScript 的装饰者模式\n\n生活中的例子: 天气冷了, 就添加衣服来保暖；天气热了, 就将外套脱下；这个例子很形象地含盖了装饰器的神韵, 随着天气的冷暖变化, 衣服可以动态的穿上脱下。\n\n```js\nlet wear = function() {\n  console.log('穿上第一件衣服')\n}\n\nconst _wear1 = wear\n\nwear = function() {\n  _wear1()\n  console.log('穿上第二件衣服')\n}\n\nconst _wear2 = wear\n\nwear = function() {\n  _wear2()\n  console.log('穿上第三件衣服')\n}\n\nwear()\n\n// 穿上第一件衣服\n// 穿上第二件衣服\n// 穿上第三件衣服\n```\n\n这种方式有以下缺点: 1: 临时变量会变得越来越多；2: this 指向有时会出错\n\n### AOP 装饰函数\n\n```js\n// 前置代码\nFunction.prototype.before = function(fn) {\n  const self = this\n  return function() {\n    fn.apply(new(self), arguments)  // https://github.com/MuYunyun/blog/pull/30#event-1817065820\n    return self.apply(new(self), arguments)\n  }\n}\n\n// 后置代码\nFunction.prototype.after = function(fn) {\n  const self = this\n  return function() {\n    self.apply(new(self), arguments)\n    return fn.apply(new(self), arguments)\n  }\n}\n```\n\n用后置代码来实验下上面穿衣服的 demo,\n\n```js\nconst wear1 = function() {\n  console.log('穿上第一件衣服')\n}\n\nconst wear2 = function() {\n  console.log('穿上第二件衣服')\n}\n\nconst wear3 = function() {\n  console.log('穿上第三件衣服')\n}\n\nconst wear = wear1.after(wear2).after(wear3)\nwear()\n\n// 穿上第一件衣服\n// 穿上第二件衣服\n// 穿上第三件衣服\n```\n\n但这样子有时会污染原生函数, 可以做点通变\n\n```js\nconst after = function(fn, afterFn) {\n  return function() {\n    fn.apply(this, arguments)\n    afterFn.apply(this, arguments)\n  }\n}\n\nconst wear = after(after(wear1, wear2), wear3)\nwear()\n```"}}]);