(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3563],{63563:n=>{n.exports="链表对应生活中的例子: 火车(一节带动一节, 必要时可以拆卸或添加一节车厢)\n\n链表通过指针连接, 如果需要插入或删除只需改变相应指针指向的目标就行。这也是链表相比较于数组最大的优点, 不用移动元素就能很轻松地添加删除元素。如果有大量的数据要插入或删除可以考虑使用链表这种数据结构。\n\n### 链表的实现\n\n![](http://with.muyunyun.cn/7a3ef4c64503a167076422b377de3f44.jpg-300)\n\n```js\nvar LinkedList = function() {\n  const Node = function(element) {\n    this.element = element\n    this.next = null\n  }\n\n  let head = null\n  let current\n  let length = 0\n\n  // 在链表末尾加入元素\n  this.append = function(element) {\n    const node = new Node(element)\n    if (head === null) {       // 插入第一个链表\n      head = node\n    } else {\n      current = head\n      while (current.next) {     // 找到最后一个节点\n        current = current.next\n      }\n      current.next = node\n    }\n    length++\n  }\n\n  // 移除指定位置元素\n  this.removeAt = function(position) {\n    if (position > -1 && position < length) {\n      let previous\n      let index = 0\n      if (position === 0) {         // 如果是第一个链表的话, 特殊对待\n        head = head.next\n      } else {\n        current = head\n        while (index < position) {  // 循环找到当前要删除元素的位置\n          previous = current\n          current = current.next\n          index++\n        }\n        previous.next = current.next\n      }\n      length--\n    }\n  }\n\n  // 在指定位置加入元素\n  this.insert = function(position, element) {\n    const node = new Node(element)\n    let index = 0\n    let current, previous\n    if (position > -1 && position < length + 1) {\n      if (position === 0) { // 在链表最前插入元素\n        current = head\n        head = node\n        head.next = current\n      } else {\n        current = head\n        while (index < position) { // 同 removeAt 逻辑, 找到目标位置\n          previous = current\n          current = current.next\n          index++\n        }\n        previous.next = node       // 在目标位置插入相应元素\n        node.next = current\n      }\n      length++\n    }\n  }\n\n  // 链表中是否含有某个元素, 如果有的话返回相应位置, 无的话返回 -1\n  this.indexOf = function(element) {\n    let index = 0\n    current = head\n    while (index < length) {\n      if (current.element === element) {\n        return index\n      }\n      current = current.next\n      index++\n    }\n    return -1\n  }\n\n  // 移除某元素\n  this.remove = function(element) {\n    const position = this.indexOf(element)\n    this.removeAt(position)\n  }\n\n  // 获取大小\n  this.size = function() {\n    return length\n  }\n\n  // 获取最开头的链表\n  this.getHead = function() {\n    return head\n  }\n\n  // 是否为空\n  this.isEmpty = function() {\n    return length === 0\n  }\n\n  // 打印链表元素\n  this.log = function() {\n    current = head\n    let str = current.element\n    while (current.next) {\n      current = current.next\n      str = str + ' ' + current.element\n    }\n    return str\n  }\n}\n\n// 测试用例\nvar linkedList = new LinkedList()\nlinkedList.append(5)\nlinkedList.append(10)\nlinkedList.append(15)\nlinkedList.append(20)\nlinkedList.log()         // '5 10 15 20'\nlinkedList.removeAt(1)\nlinkedList.log()         // '5 15 20'\nlinkedList.insert(1, 10)\nlinkedList.log()\n```\n\n### 双向链表\n\n单向链表如果错过了某次查询就得重头开始重新查找, 双向链表进行了升级, 除了可以向后查找, 同时也支持向前查找\n\n![](http://with.muyunyun.cn/1d97c4d5d071560966357df5ab2bfd16.jpg-300)\n\n```js\nvar DbLinkedList = function() {\n  const Node = function(element) {\n    this.element = element\n    this.next = null\n    this.prev = null\n  }\n\n  let head = null\n  let tail = null\n  let current, previous\n  let length = 0\n\n  // 指定任意位置插入元素\n  this.insert = function(position, element) {\n    let index = 0\n    const node = new Node(element)\n    if (position > -1 && position < length + 1) {\n      if (position === 0) {             // ① 在开头插入元素\n        if (head === null) {  // 链表内元素为空\n          head = node\n          tail = node\n        } else {              // 链表内存在元素\n          current = head\n          head = node\n          head.next = current\n          current.prev = head\n        }\n      } else if (position === length) { // ② 在末尾插入元素\n        current = tail\n        tail = node\n        current.next = tail\n        tail.prev = current\n      } else {                          // ③ 在链表中插入元素\n        current = head\n        while (index < position) { // 找到需插入节点的位置\n          previous = current\n          current = current.next\n          index++\n        }\n        previous.next = node\n        node.next = current\n\n        current.prev = node\n        node.prev = previous\n      }\n      length++\n    }\n  }\n\n  // 删除指定位置的元素\n  this.removeAt = function(position) {\n    let index = 0\n    if (position > -1 && position < length) {\n      if (position === 0) {                  // 删除链表最开头的元素\n        if (length === 1) {\n          head = null\n          tail = null\n        } else {\n          current = head\n          head = current.next\n          head.prev = current.prev\n        }\n      } else if (position === length - 1) {  // 删除链表最末尾的元素\n        current = tail\n        tail = current.prev\n        tail.next = current.next\n      } else {                               // 删除链表中的元素\n        current = head\n        while (index < position) {\n          previous = current\n          current = current.next\n          index++\n        }\n        previous.next = current.next\n        current.next.prev = previous\n      }\n      length--\n    }\n  }\n\n  this.log = function() {\n    current = head\n    let str = current.element\n    while (current.next) {\n      current = current.next\n      str = str + ' ' + current.element\n    }\n    return str\n  }\n}\n\nvar dbLinkedList = new DbLinkedList()\ndbLinkedList.insert(0, 5)\ndbLinkedList.insert(1, 10)\ndbLinkedList.insert(2, 15)\ndbLinkedList.insert(3, 20)\ndbLinkedList.insert(4, 25)\ndbLinkedList.log()         // \"5 10 15 20 25\"\ndbLinkedList.removeAt(4)\ndbLinkedList.removeAt(0)\ndbLinkedList.removeAt(1)\ndbLinkedList.log()         // \"10 20\"\n```\n\n此外还有循环链表, 和上述代码类似, 在此省略。"}}]);