(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1044],{71044:n=>{n.exports='### JSX 和 虚拟 DOM\n\n```js\nconst element = (\n  <div className="title">\n    hello<span className="content">world!</span>\n  </div>\n)\n```\n\nJSX 是一种语法糖, 经过 [babel](https://babeljs.io/en/repl) 转换结果如下, 可以发现实际上转化成 `React.createElement()` 的形式:\n\n> 扩展: [babel 执行机制](https://github.com/MuYunyun/blog/blob/master/BasicSkill/番外篇/babel执行机制.md)\n\n```js\nvar element = React.createElement(\n  "div",\n  { className: "title" },\n  "hello",\n  React.createElement(\n    "span",\n    { className: "content" },\n    "world!"\n  )\n);\n```\n\n[打印](https://preactjs.com/repl) element, 结果如下:\n\n```js\n{\n  attributes: {className: "title"}\n  children: ["hello", t] // t 和外层对象相同\n  key: undefined\n  nodeName: "div"\n}\n```\n\n因此, 我们得出结论: JSX 语法糖经过 Babel 编译后转换成一种对象, 该对象即所谓的`虚拟 DOM`, 使用虚拟 DOM 能让页面进行更为高效的渲染。\n\n我们按照这种思路进行函数的构造:\n\n```js\nconst React = {\n  createElement\n}\n\nfunction createElement(tag, attr, ...child) {\n  return {\n    attributes: attr,\n    children: child,\n    key: undefined,\n    nodeName: tag,\n  }\n}\n\n// 测试\nconst element = (\n  <div className="title">\n    hello<span className="content">world!</span>\n  </div>\n)\n\nconsole.log(element) // 打印结果符合预期\n// {\n//   attributes: {className: "title"}\n//   children: ["hello", t] // t 和外层对象相同\n//   key: undefined\n//   nodeName: "div"\n// }\n```\n\n### 虚拟 DOM 转化为真实 DOM\n\n上个小节介绍了 JSX 转化为虚拟 DOM 的过程, 这个小节接着来实现将虚拟 DOM 转化为真实 DOM (页面上渲染的是真实 DOM)。\n\n我们知道在 React 中, 将虚拟 DOM 转化为真实 DOM 是使用 `ReactDOM.render` 实现的, 使用如下:\n\n```js\nimport ReactDOM from \'react-dom\'\n\nReactDOM.render(\n  element, // 上文的 element, 即虚拟 dom\n  document.getElementById(\'root\')\n)\n```\n\n接着来实现 `ReactDOM.render` 的逻辑:\n\n```js\nconst ReactDOM = {\n  render\n}\n\n/**\n * 将虚拟 DOM 转化为真实 DOM\n * @param {*} vdom      虚拟 DOM\n * @param {*} container 需要插入的位置\n */\nfunction render(vdom, container) {\n  if (_.isString(vdom) || _.isNumber(vdom)) {\n    container.innerText = container.innerText + vdom // fix <div>I\'m {this.props.name}</div>\n    return\n  }\n  const dom = document.createElement(vdom.nodeName)\n  for (let attr in vdom.attributes) {\n    setAttribute(dom, attr, vdom.attributes[attr])\n  }\n  vdom.children.forEach(vdomChild => render(vdomChild, dom))\n  container.appendChild(dom)\n}\n\n/**\n * 给节点设置属性\n * @param {*} dom   操作元素\n * @param {*} attr  操作元素属性\n * @param {*} value 操作元素值\n */\nfunction setAttribute(dom, attr, value) {\n  if (attr === \'className\') {\n    attr = \'class\'\n  }\n  if (attr.match(/on\\w+/)) {   // 处理事件的属性:\n    const eventName = attr.toLowerCase().substr(2)\n    dom.addEventListener(eventName, value)\n  } else if (attr === \'style\') { // 处理样式的属性:\n    let styleStr = \'\'\n    let standardCss\n    for (let klass in value) {\n      standardCss = humpToStandard(klass) // 处理驼峰样式为标准样式\n      value[klass] = _.isNumber(+value[klass]) ? value[klass] + \'px\' : value[klass] // style={{ className: \'20\' || \'20px\' }}>\n      styleStr += `${standardCss}: ${value[klass]};`\n    }\n    dom.setAttribute(attr, styleStr)\n  } else {                       // 其它属性\n    dom.setAttribute(attr, value)\n  }\n}\n```\n\n至此, 我们成功将虚拟 DOM 复原为真实 DOM, 展示如下:\n\n![](http://with.muyunyun.cn/a898514bd3d08df4366e5ceb7843cddf.jpg-400)\n\n另外配合热更新, 在热更新的时候清空之前的 dom 元素, 改动如下:\n\n```js\nconst ReactDOM = {\n  render(vdom, container) {\n    container.innerHTML = null\n    render(vdom, container)\n  }\n}\n```\n\n### 小结\n\n`JSX` 经过 babel 编译为 React.createElement() 的形式, 其返回结果就是 `Virtual DOM`, 最后通过 ReactDOM.render() 将 Virtual DOM 转化为真实的 DOM 展现在界面上。流程图如下:\n\n![](http://with.muyunyun.cn/5e451855ccc9017708b57164f9e221c6.jpg-400)\n\n### 思考题\n\n如下是一个 react/preact 的常用组件的写法, 那么为什么要 import 一个 React 或者 h 呢？\n\n```jsx\nimport React, { Component } from \'react\' // react\n// import { h, Component } from \'preact\' // preact\n\nclass A extends Component {\n  render() {\n    return <div>I\'m componentA</div>\n  }\n}\n\nrender(<A />, document.body) // 组件的挂载\n```\n'}}]);