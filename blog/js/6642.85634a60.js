(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6642],{86642:t=>{t.exports="### 341.Flatten Nested List Iterator\n\nGiven a nested list of integers, implement an `iterator` to flatten it.\n\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\n\nExample 1:\n\n```js\nInput: [[1,1],2,[1,1]]\nOutput: [1,1,2,1,1]\n```\n\nExplanation: By calling next repeatedly until hasNext returns false,\n             the order of elements returned by next should be: [1,1,2,1,1].\n\nExample 2:\n\n```js\nInput: [1,[4,[6]]]\nOutput: [1,4,6]\n```\n\nExplanation: By calling next repeatedly until hasNext returns false,\n             the order of elements returned by next should be: [1,4,6].\n\n### analyze\n\n该题需注意的点: [1, [4]] 里的子项 1, [4] 分别通过 `getInteger` 与 `getList` 获取到。\n\n### 递归法\n\n```js\n/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * function NestedInteger() {\n *\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     @return {boolean}\n *     this.isInteger = function() {\n *         ...\n *     };\n *\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\n *     Return null if this NestedInteger holds a nested list\n *     @return {integer}\n *     this.getInteger = function() {\n *         ...\n *     };\n *\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\n *     Return null if this NestedInteger holds a single integer\n *     @return {NestedInteger[]}\n *     this.getList = function() {\n *         ...\n *     };\n * };\n */\n/**\n * @constructor\n * @param {NestedInteger[]} nestedList\n */\nvar NestedIterator = function(nestedList) {\n  this.printArr = []\n  this.resetArr(nestedList)\n}\n\nNestedIterator.prototype.resetArr = function(nestedList) {\n  if (!nestedList && !nestedList.length) return\n  for (let i = 0; i < nestedList.length; i++) {\n    const curList = nestedList[i]\n    if (curList.isInteger()) {\n      this.printArr.unshift(curList.getInteger())\n    } else {\n      this.resetArr(curList.getList())\n    }\n  }\n}\n\n/**\n * @this NestedIterator\n * @returns {boolean}\n */\nNestedIterator.prototype.hasNext = function() {\n  return this.printArr.length > 0\n}\n\n/**\n * @this NestedIterator\n * @returns {integer}\n */\nNestedIterator.prototype.next = function() {\n  return this.printArr.pop()\n}\n\n/**\n * Your NestedIterator will be called like this:\n * var i = new NestedIterator(nestedList), a = [];\n * while (i.hasNext()) a.push(i.next());\n*/\n```\n\n### 迭代法\n\n相对递归法, 迭代法需要额外维护一个`系统调用栈`, 然后使用`颜色标记法`完成题解。\n\n颜色标记法思路:\n\n* 未访问过的列表标记为`白色`, 访问过的列表标记为`灰色`;\n* 从栈顶取出访问元素:\n   * 若为灰色元素, 则打印之;\n   * 若为白色元素, 则遍历子列表:\n      * 若子列表为列表, 则将其`标记为白色`并推入栈;\n      * 若子列表为数字, 则将其`标记为灰色`并推入栈;\n\n```js\n/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * function NestedInteger() {\n *\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     @return {boolean}\n *     this.isInteger = function() {\n *         ...\n *     };\n *\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\n *     Return null if this NestedInteger holds a nested list\n *     @return {integer}\n *     this.getInteger = function() {\n *         ...\n *     };\n *\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\n *     Return null if this NestedInteger holds a single integer\n *     @return {NestedInteger[]}\n *     this.getList = function() {\n *         ...\n *     };\n * };\n */\n/**\n * @constructor\n * @param {NestedInteger[]} nestedList\n */\nvar NestedIterator = function(nestedList) {\n  this.printArr = []\n  if (!nestedList) return\n  this.stackList = []\n  this.stackList.push({ color: 'white', list: nestedList })\n  while (this.stackList.length > 0) {\n    const { color, list } = this.stackList.pop()\n    if (color === 'gray') {\n      this.printArr.unshift(list)\n    } else {\n      for (let i = 0; i < list.length; i++) {\n        if (list[i].isInteger()) {\n          this.stackList.push({ color: 'gray', list: list[i].getInteger() })\n        } else {\n          this.stackList.push({ color: 'white', list: list[i].getList() })\n        }\n      }\n    }\n  }\n}\n\n/**\n * @this NestedIterator\n * @returns {boolean}\n */\nNestedIterator.prototype.hasNext = function() {\n  return this.printArr.length > 0\n}\n\n/**\n * @this NestedIterator\n * @returns {integer}\n */\nNestedIterator.prototype.next = function() {\n  return this.printArr.shift()\n}\n\n/**\n * Your NestedIterator will be called like this:\n * var i = new NestedIterator(nestedList), a = [];\n * while (i.hasNext()) a.push(i.next());\n*/\n```\n\n### Similar Title\n\n94、144、145"}}]);