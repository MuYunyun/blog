(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3136],{83136:n=>{n.exports="### 命令式编程和声明式编程\n\n拿泡茶这个事例进行区分命令式编程和声明式编程\n\n* 命令式编程\n\n1.烧开水(为第一人称)\n2.拿个茶杯\n3.放茶叶\n4.冲水\n\n* 声明式编程\n\n1.给我泡杯茶(为第二人称)\n\n举个 demo\n\n```js\n// 命令式编程\nconst convert = function(arr) {\n  const result = []\n  for (let i = 0; i < arr.length; i++) {\n    result[i] = arr[i].toLowerCase()\n  }\n  return result\n}\n\n// 声明式编程\nconst convert = function(arr) {\n  return arr.map(r => r.toLowerCase())\n}\n```\n\n### 什么是函数式编程\n\n函数式编程是声明式编程的范式。在函数式编程中数据在由纯函数组成的管道中传递。\n\n> 函数式编程可以用简单如`交换律、结合律、分配律`的数学之法来帮我们简化代码的实现。\n\n它具有如下一些特性:\n\n* 纯粹性: 纯函数不改变除当前作用域以外的值;\n\n```js\n// 反面示例\nlet a = 0\nconst add = (b) => a = a + b // 两次 add(1) 结果不一致\n\n// 正确示例\nconst add = (a, b) => a + b\n```\n\n* 数据不可变性: Immutable\n\n```js\n// 反面示例\nconst arr = [1, 2]\nconst arrAdd = (value) => {\n  arr.push(value)\n  return arr\n}\n\narrAdd(3) // [1, 2, 3]\narrAdd(3) // [1, 2, 3, 3]\n\n// 正面示例\nconst arr = [1, 2]\nconst arrAdd = (value) => {\n  return arr.concat(value)\n}\n\narrAdd(3) // [1, 2, 3]\narrAdd(3) // [1, 2, 3]\n```\n\n> 在后记 1 中对数组字符串方法是否对原值有影响作了整理\n\n* 函数柯里化: 将多个入参的函数转化为一个入参的函数;\n\n```js\nconst add = a => b => c => a + b + c\nadd(1)(2)(3)\n```\n\n* 偏函数: 将多个入参的函数转化成两部分;\n\n```js\nconst add = a => (b, c) => a + b + c\nadd(1)(2, 3)\n```\n\n* 可组合: 函数之间能组合使用\n\n```js\nconst add = (x) => x + x\nconst mult = (x) => x * x\n\nconst addAndMult = (x) => add(mult(x))\n```\n\n### 柯里化(curry)\n\n如下是一个加法函数:\n\n```js\nvar add = (a, b, c) => a + b + c\n\nadd(1, 2, 3) // 6\n```\n\n假如有这样一个 `curry` 函数, 用其包装 `add` 函数后返回一个新的函数 `curryAdd`, 我们可以将参数 `a、b` 进行分开传递进行调用。\n\n```js\nvar curryAdd = curry(add)\n\n// 以下输出结果都相同\ncurryAdd(1, 2, 3) // 6\ncurryAdd(1, 2)(3) // 6\ncurryAdd(1)(2)(3) // 6\ncurryAdd(1)(2, 3) // 6\n```\n\n#### 动手实现一个 curry 函数\n\n核心思路: 若传进去的参数个数未达到 `curryAdd` 的个数，则将参数缓存在闭包变量 lists 中:\n\n```js\nfunction curry(fn, ...args) {\n  const length = fn.length\n  let lists = args || []\n\n  let listLen\n  return function (..._args) {\n    lists = [...lists, ..._args]\n    listLen = lists.length\n\n    if (listLen < length) {\n      const that = lists\n      lists = []\n      return curry(fn, ...that)\n    } else if (listLen === length) {\n      const that = lists\n      lists = []\n      return fn.apply(this, that)\n    }\n  }\n}\n```\n\n### 代码组合(compose)\n\n现在有 `toUpperCase`、`reverse`、`head` 三个函数, 分别如下:\n\n```js\nvar toUpperCase = (str) => str.toUpperCase()\nvar reverse = (arr) => arr.reverse()\nvar head = (arr) => arr[0]\n```\n\n接着使用它们实现将数组末位元素大写化输出, 可以这样做:\n\n```js\nvar reverseHeadUpperCase = (arr) => toUpperCase(head(reverse(arr)))\n\nreverseHeadUpperCase(['apple', 'banana', 'peach']) // PEACH\n```\n\n此时在构建 `reverseHeadUpperCase` 函数的时候, 必须手动声明传入参数 arr, 是否能提供一个 `compose` 函数让使用者更加友好的使用呢? 类似如下形式:\n\n```js\nvar reverseHeadUpperCase = compose(toUpperCase, head, reverse)\n\nreverseHeadUpperCase(['apple', 'banana', 'peach']) // PEACH\n```\n\n此外 `compose` 函数符合`结合律`, 我们可以这样子使用:\n\n```js\ncompose(compose(toUpperCase, head), reverse)\ncompose(toUpperCase, compose(head, reverse))\n```\n\n以上两种写法与 `compose(toUpperCase, head, reverse)` 的效果完全相同, 都是依次从右到左执行传参中的函数。\n\n此外 `compose` 和 `map` 一起使用时也有相关的结合律, 以下两种写法效果相等\n\n```js\ncompose(map(f), map(g))\nmap(compose(f, g))\n```\n\n#### 动手实现一个 compose 函数\n\n代码精华集中在一行之内, 其为众多开源库(比如 Redux) 所采用。\n\n```js\nvar compose = (...args) => (initValue) => args.reduceRight((a, c) => c(a), initValue)\n```\n\n### 范畴论\n\n范畴论是数学中的一个分支。可以将范畴理解为一个容器, 把原来对值的操作，现转为对容器的操作。如下图:\n\n![](http://with.muyunyun.cn/c65fa1b63dbe9fa0a0771e7e561dc85b.jpg-200)\n\n> 学习函数式编程就是学习各种函子的过程。\n\n函数式编程中, `函子(Functor)` 是实现了 `map` 函数的容器, 下文中将函子视为范畴，模型可表示如下:\n\n```js\nclass Functor {\n  constructor(value) {\n    this.value = value\n  }\n\n  map(fn) {\n    return new Functor(fn(this.value))\n  }\n}\n```\n\n但是在函数式编程中, 要避免使用 `new` 这种面向对象的编程方式, 取而代之对外暴露了一个 `of` 的接口, 也称为 `pointed functor`。\n\n```js\nFunctor.of = value => new Functor(value)\n```\n\n#### Maybe 函子\n\n`Maybe 函子`是为了解决 `this.value` 为 null 的情形, 用法如下:\n\n```js\nMaybe.of(null).map(r => r.toUpperCase()) // null\nMaybe.of('m').map(r => r.toUpperCase())  // Maybe {value: \"M\"}\n```\n\n实现代码如下:\n\n```js\nclass Maybe {\n  constructor(value) {\n    this.value = value\n  }\n\n  map(fn) {\n    return this.value ? new Maybe(fn(this.value)) : null\n  }\n}\n\nMaybe.of = value => new Maybe(value)\n```\n\n#### Either 函子\n\n`Either 函子` 是为了对应 `if...else...` 的语法, 即`非左即右`。因此可以将之拆分为 `Left` 和 `Right` 两个函子, 它们的用法如下:\n\n```js\nvar left = Left.of(1).map(r => r + 1)  // Left {value: 1}\n\nvar right = Right.of(1).map(r => r + 1) // Right {value: 2}\n```\n\n`Left 函子`实现代码如下:\n\n```js\nclass Left {\n  constructor(value) {\n    this.value = value\n  }\n\n  map(fn) {\n    return this\n  }\n}\n\nLeft.of = value => new Left(value)\n```\n\n`Right 函子`实现代码如下(其实就是上面的 `Functor`):\n\n```js\nclass Right {\n  constructor(value) {\n    this.value = value\n  }\n\n  map(fn) {\n    return new Right(fn(this.value))\n  }\n}\n\nRight.of = value => new Right(value)\n```\n\n具体 `Either` 函数只是对调用 `Left 函子` 或 `Right 函子` 作一层筛选, 其接收 `f`、`g` 两个函数以及一个函子(`Left or Right`)\n\n```js\nvar Either = function(f, g, functor) {\n  switch(functor.constructor.name) {\n    case 'Left':\n      return f(functor.value)\n    case 'Right':\n      return g(functor.value)\n    default:\n      return f(functor.value)\n  }\n}\n```\n\n使用 demo:\n\n```js\nEither((v) => console.log('left', v), (v) => console.log('def', v), left)   // left 1\nEither((v) => console.log('def', v), (v) => console.log('rigth', v), rigth) // rigth 2\n```\n\n#### Monad 函子\n\n函子会发生嵌套, 比如下面这样:\n\n```js\nFunctor.of(Functor.of(1)) // Functor { value: Functor { value: 1 } }\n```\n\n`Monad 函子` 对外暴露了 `join` 和 `flatmap` 接口, 调用者从而可以扁平化嵌套的函子。\n\n```js\nclass Monad {\n  constructor(value) {\n    this.value = value\n  }\n\n  map(fn) {\n    return new Monad(fn(this.value))\n  }\n\n  join() {\n    return this.value\n  }\n\n  flatmap(fn) {\n    return this.map(fn).join()\n  }\n}\n\nMonad.of = value => new Monad(value)\n```\n\n使用方法:\n\n```js\n// join\nMonad.of(Monad.of(1).join()) // Monad { value: 1 }\nMonad.of(Monad.of(1)).join() // Monad { value: 1 }\n\n// flatmap\nMonad.of(1).flatmap(r => r + 1)  // 2\n```\n\n> Monad 函子可以运用在 I/O 这种不纯的操作上将之变为纯函数的操作，目前比较懵懂，日后补充。\n\n### 后记 1: 数组字符串方法小结(是否对原值有影响)\n\n#### 不会对原数组有影响的方法\n\n##### slice\n\n```js\nvar test = [1, 2, 3]\nvar result = test.slice(0, 1)\n\nconsole.log(test)   // [1, 2, 3]\nconsole.log(result) // [1]\n```\n\n##### concat\n\n```js\nvar test = [1, 2, 3]\nvar result = test.concat(4)\n\nconsole.log(test)   // [1, 2, 3]\nconsole.log(result) // [1, 2, 3, 4]\n```\n\n#### 对原数组有影响的方法\n\n##### splice(这个需要特别记一下)\n\n```js\nvar test = [1, 2, 3]\nvar result = test.splice(0, 1)\n\nconsole.log(test)   // [2, 3]\nconsole.log(result) // [1]\n```\n\n##### sort\n\n```js\nvar arr = [2, 1, 3, 4]\narr.sort((r1, r2) => (r1 - r2))\n\nconsole.log(arr) // [1, 2, 3, 4]\n```\n\n##### reverse\n\n```js\nvar test = [1, 2, 3]\nvar result = test.reverse()\n\nconsole.log(test)   // [3, 2, 1]\nconsole.log(result) // [3, 2, 1]\n```\n\n##### push/pop/unshift/shift\n\n```js\nvar test = [1, 2, 3]\nvar result = test.push(4)\n\nconsole.log(test)   // [1, 2, 3, 4]\nconsole.log(result) // 4\n```\n\n#### 不会对原字符串造成影响的方法\n\n##### substr/substring/slice\n\n```js\n// substr\nvar test = 'abc'\nvar result = test.substr(0, 1)\n\nconsole.log(test)   // 'abc'\nconsole.log(result) // a\n\n// substring\nvar test = 'abc'\nvar result = test.substring(0, 1)\n\nconsole.log(test)   // 'abc'\nconsole.log(result) // a\n\n// slice\nvar test = 'abc'\nvar result = test.slice(0, 1)\n\nconsole.log(test)   // 'abc'\nconsole.log(result) // a\n```\n\n##### replace\n\n```js\nvar test = 'abc'\nvar result = test.replace('c', 'd')\n\nconsole.log(test)   // 'abc'\nconsole.log(result) // 'abd'\n```\n\n### 参考\n\n* [mostly-adequate-guide](https://mostly-adequate.gitbooks.io/mostly-adequate-guide)\n* [JavaScript 函数式编程指南](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese)\n* [JavaScript 专题之函数柯里化](https://github.com/mqyqingfeng/Blog/issues/42)\n* [函数式编程入门教程](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)\n"}}]);