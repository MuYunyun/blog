(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3649],{43649:n=>{n.exports="### 题目\n\n给定 n 个非负整数 a1, a2, ..., an, 每个数代表坐标中的一个点 (i, ai)。在坐标内画 n 条垂直线, 垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线, 使得它们与 x 轴共同构成的容器可以容纳最多的水。\n\n说明: 你不能倾斜容器, 且 n 的值至少为 2。\n\n-[](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\n\n图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下, 容器能够容纳水(表示为蓝色部分)的最大值为 49。\n\n示例:\n\n```js\n输入: [1,8,6,2,5,4,8,3,7]\n输出: 49\n```\n\n### 解题\n\n暴力法: 时间复杂度 O(n^2), 空间复杂度 O(1);\n\n```js\n// 暴力法\n/**\n * @param {number[]} height\n * @return {number}\n */\nvar maxArea = function (height) {\n  let maxArea = 0\n  const length = height.length\n  for (let i = 0; i < length; i++) {\n    for (let y = i + 1; y < length; y++) {\n      result = Math.min(height[i], height[y]) * (y - i)\n      if (result > maxArea) {\n        maxArea = result\n      }\n    }\n  }\n  return maxArea\n}\n```\n\n双指针法: 一个指针指向首位, 一个指针指向末尾; 因为受限于高度低的那一方, 所以移动高度较低的那一位; 这样子只要遍历一次就能得出结果, 时间复杂度 O(n), 空间复杂度 O(1);\n\n```js\n// 双指针法\nvar maxArea = function (height) {\n  let head = 0, tail = height.length - 1, maxArea = 0\n  while (head < tail) {\n    result = Math.min(height[head], height[tail]) * (tail - head)\n    if (result > maxArea) {\n      maxArea = result\n    }\n    if (height[head] <= height[tail]) {\n      head++\n    } else {\n      tail--\n    }\n  }\n  return maxArea\n}\n```\n\n### 类似题目\n\n125、167、344、345"}}]);