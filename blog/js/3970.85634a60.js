(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3970],{93970:n=>{n.exports="### 222. Count Complete Tree Nodes\n\nGiven a `complete binary tree`, count the number of nodes.\n\nNote:\n\nDefinition of a complete binary tree from Wikipedia:\nIn a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\n\nExample:\n\n```js\nInput:\n    1\n   / \\\n  2   3\n / \\  /\n4  5 6\n\nOutput: 6\n```\n\n### Analyze\n\n方式一: 递归\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar countNodes = function(root) {\n  if (!root) return 0\n  return 1 + countNodes(root.left) + countNodes(root.right)\n};\n```\n\n方式二: 利用完全二叉树性质解题\n\n根据题目给出的当前树是完全二叉树的限制, 可得到子树存在如下两点条件:\n\n* 若左子树的深度 = 右子树的深度, 则`左子树为满二叉树`;\n* 若左子树的深度 > 右子树的深度, 则`右子树为满二叉树`;\n\n可以根据上述分析简化递归次数。\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar countNodes = function(root) {\n  if (!root) return 0\n\n  const leftDeep = deep(root.left)\n  const rightDeep = deep(root.right)\n\n  if (leftDeep === rightDeep) {\n    // the count of left node is Math.pow(2, leftDeep) - 1, so the total is\n    // Math.pow(2, leftDeep) - 1 + countNodes(root.right) + 1, 1 means parent node\n    return Math.pow(2, leftDeep) + countNodes(root.right)\n  } else {\n    return Math.pow(2, rightDeep) + countNodes(root.left)\n  }\n};\n\n// get the deep of current node cleverly with features of the complete tree.\nvar deep = function(node) {\n  if (!node) return 0\n  let nodeVal = node\n  let count = 1\n\n  while (nodeVal.left) {\n    count++\n    nodeVal = nodeVal.left\n  }\n\n  return count\n}\n```"}}]);