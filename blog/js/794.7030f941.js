(self.webpackChunkblog=self.webpackChunkblog||[]).push([[794],{60794:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>c});var a=n(59713),l=n.n(a),r=n(6479),p=n.n(r),o=(n(67294),n(3905));function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function u(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l()(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var m={};function c(e){var t=e.components,n=p()(e,["components"]);return(0,o.kt)("wrapper",u(u(u({},m),n),{},{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",null,"React 特性剪辑(版本 16.0 ~ 16.9)"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Before you're going to hate it, then you're going to love it.")),(0,o.kt)("p",null,(0,o.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/18be54d827e9dde7d9e29d029e329334.jpg-400",alt:null}))),(0,o.kt)("h3",null,"Concurrent Render(贯穿 16)"),(0,o.kt)("p",null,"在 18 年的 ",(0,o.kt)("a",u({parentName:"p"},{href:"https://www.youtube.com/watch?v=v6iR3Zk4oDY"}),"JSConf Iceland")," 上, Dan 神提到 Concurrent Render 涉及到 CPU 以及 IO 这两方面。"),(0,o.kt)("p",null,(0,o.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/1daa3d783a4a7ed7f742882a08a3aa09.jpg-400",alt:null}))),(0,o.kt)("p",null,"Time Slicing 对应解决左侧的问题, Suspense 对应解决了右侧的问题。它们共同要解决的是的提升用户体验, 在更多的场景下都可以做到",(0,o.kt)("inlineCode",{parentName:"p"},"可交互"),"。而 Fiber 架构是上述两者的基石。"),(0,o.kt)("h4",null,"Time Slicing"),(0,o.kt)("p",null,"在 16 之前的版本的渲染过程可以想象成一次性潜水 30 米, 在这期间做不了其它事情(Stack Reconciler);"),(0,o.kt)("p",null,(0,o.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/39db8e34ec1ce048695c3bde132a739e.jpg-200",alt:null}))),(0,o.kt)("p",null,"痛点概括:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"一次性渲染到底"),(0,o.kt)("li",{parentName:"ul"},"中途遇到优先级更高的事件无法调整相应的顺序")),(0,o.kt)("p",null,"接着拿上面的潜水例子为例, 现在变为可以每次潜 10 米, 分 3 个 chunk 进行; chunk 和 chunk 之间通过链表连接; chunk 间插入优先级更高的任务, 先前的任务被抛弃。"),(0,o.kt)("p",null,(0,o.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/02a6b5ac36b12b3c676157ef3985fe4a.jpg-200",alt:null}))),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"开启 Fiber 后, 获取异步数据的方法应放到 render 后面的生命周期钩子里(phase 2 阶段)进行, 因为 render 前面的生命周期钩子(phase 1 阶段)会被执行多次")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"注意: 并没有缩短原先组件的渲染时间(甚至还加长了), 但用户却能感觉操作变流畅了。")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("a",u({parentName:"p"},{href:"https://developers.google.com/web/updates/2015/08/using-requestidlecallback"}),"requestIdleCallback()"),": 借力此 api, 浏览器能在空闲的时间处理低优先级的事。")),(0,o.kt)("h4",null,"Suspense(16.6, 16.8, 16.9)"),(0,o.kt)("p",null,"Suspense 意思是能暂停当前组件的渲染, 当完成某件事以后再继续渲染。"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"code splitting"),"(16.6, 已上线): 文件懒加载。在此之前的实现方式是 ",(0,o.kt)("a",u({parentName:"li"},{href:"https://github.com/jamiebuilds/react-loadable"}),"react-loadable"),";"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Concurrent mode"),"(2019 年 Q1 季度): 并发模式;"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"data fetching"),"(2019 年中): 可以控制等所有数据都加载完再呈现出数据; ",(0,o.kt)("inlineCode",{parentName:"li"},"Suspense")," 提供一个时间参数, 若小于这个值则不进行 ",(0,o.kt)("inlineCode",{parentName:"li"},"loading")," 加载, 若超过这个值则进行 ",(0,o.kt)("inlineCode",{parentName:"li"},"loading")," 加载;")),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"import React, { lazy, Suspense } from 'react'\nconst OtherComponent = lazy(() => import('./OtherComponent'))\n\nfunction MyComponent() {\n  return (\n    <Suspense fallback={<div>loading...</div>}>\n      <OtherComponent />\n    </Suspense>\n  )\n}\n")),(0,o.kt)("p",null,"一种简单的预加载思路, 可参考 ",(0,o.kt)("a",u({parentName:"p"},{href:"https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d"}),"preload")),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"const OtherComponentPromise = import('./OtherComponent');\nconst OtherComponent = React.lazy(() => OtherComponentPromise);\n")),(0,o.kt)("h3",null,"render 新增的返回类型"),(0,o.kt)("p",null,"在 React16 版本中 render() 增加了一些返回类型, 到目前为止支持的返回类型如下:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"React elements."),(0,o.kt)("li",{parentName:"ul"},"Arrays and fragments."),(0,o.kt)("li",{parentName:"ul"},"Portals."),(0,o.kt)("li",{parentName:"ul"},"String and numbers."),(0,o.kt)("li",{parentName:"ul"},"Booleans or null.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("a",u({parentName:"p"},{href:"https://reactjs.org/docs/react-component.html#render"}),"render"))),(0,o.kt)("p",null,"其中 render() 支持返回 Arrays 能让我们少写一个父节点, 如下所示:"),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),'const renderArray = () => [\n  <div key="A">A</div>\n  <div key="B">B</div>\n]\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"render() 支持返回数组的特性类似 ",(0,o.kt)("a",u({parentName:"p"},{href:"https://reactjs.org/docs/fragments.html"}),"Fragments"),"(16.2), 使用 Fragments 可以不用写 key。")),(0,o.kt)("h3",null,"Portals(传送门)"),(0,o.kt)("p",null,"将 React 子节点渲染到指定的节点上"),(0,o.kt)("p",null,"案例: 实现一个 Modal 组件, ",(0,o.kt)("a",u({parentName:"p"},{href:"https://codepen.io/gaearon/pen/yzMaBd"}),"demo")),(0,o.kt)("p",null,"另外关于 Portals 做到冒泡到父节点的兄弟节点这个现象, ",(0,o.kt)("a",u({parentName:"p"},{href:"https://codepen.io/gaearon/pen/jGBWpE"}),"demo"),", 我想可以这样子实现: 如果组件返回是 Portal 对象, 则将该组件的父组件的上的事件 copy 到该组件上。其实并不是真的冒泡到了父节点的兄弟节点上。"),(0,o.kt)("h3",null,"Error Boundaries"),(0,o.kt)("p",null,"React 16 提供了一个新的错误捕获钩子 ",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidCatch(error, errorInfo)"),", 它能将子组件生命周期里所抛出的错误捕获, 防止页面全局崩溃。",(0,o.kt)("a",u({parentName:"p"},{href:"https://codepen.io/gaearon/pen/wqvxGa?editors=0010"}),"demo")),(0,o.kt)("p",null,"componentDidCatch 并不会捕获以下几种错误"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"事件机制抛出的错误(事件里的错误并不会影响渲染)"),(0,o.kt)("li",{parentName:"ul"},"Error Boundaries 自身抛出的错误"),(0,o.kt)("li",{parentName:"ul"},"异步产生的错误"),(0,o.kt)("li",{parentName:"ul"},"服务端渲染")),(0,o.kt)("h3",null,"服务端渲染"),(0,o.kt)("p",null,"服务端渲染一般是作为最后的优化手段, 这里浅显(缺乏经验)谈下 React 16 在其上的优化。"),(0,o.kt)("p",null,"在 React 16 版本中引入了 ",(0,o.kt)("inlineCode",{parentName:"p"},"React.hydrate()"),", 它的作用主要是将相关的事件",(0,o.kt)("inlineCode",{parentName:"p"},"注水"),"进 ",(0,o.kt)("inlineCode",{parentName:"p"},"html")," 页面中, 同时会比较前端生成的 ",(0,o.kt)("inlineCode",{parentName:"p"},"html")," 和服务端传到前端的 ",(0,o.kt)("inlineCode",{parentName:"p"},"html")," 的文本内容的差异, 如果两者不一致将前端产生的文本内容替换服务端生成的(忽略属性)。"),(0,o.kt)("h3",null,"支持自定义属性"),(0,o.kt)("p",null,"在 React 16 版本中, 支持自定义属性(推荐 ",(0,o.kt)("inlineCode",{parentName:"p"},"data-xxx"),"), 因而 React 可以少维护一份 attribute 白名单, 这也是 React 16 体积减少的一个重要因素。"),(0,o.kt)("h3",null,"Context(16.3、16.6)"),(0,o.kt)("p",null,"Context 相当于是用组件化的方式使用 global, 使用其可以共享认证的用户、首选语言(国际化)等一些全局的信息, 而不必通过组件一层层传递。"),(0,o.kt)("p",null,"以下是比较冗余的传递:"),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"<Page riderId={riderId} />\n// ... which renders ...\n<RiderDetail riderId={riderId} />\n// ... which renders ...\n<RiderLevel riderId={riderId} />\n// ... which renders ...\n<Avatar riderId={riderId} />\n")),(0,o.kt)("p",null,"在 ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," 之前可以传递 ",(0,o.kt)("inlineCode",{parentName:"p"},"<Avatar>")," 本身(Component Composition 的思想), 写法如下:"),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"function Page(props) {\n  const avatar = <Avatar riderId={props.riderId} />\n  return <RiderDetail avatar={avatar} />\n}\n\n<Page riderId={riderId} />\n// ... which renders ...\n<RiderDetail avatar={avatar} />\n// ... which renders ...\n<RiderLevel avatar={avatar} />\n// ... which renders ...\n{ props.avatar }\n")),(0,o.kt)("p",null,"接着是使用 ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," 书写的例子, 写法如下:"),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"const RiderContext = React.createContext(1) // 这里为默认值\n\nfunction Page(props) {\n  const riderId = props.riderId\n  return (\n    <RiderContext.Provider value={riderId}>\n      <RiderDetail />\n    </RiderContext.Provider>\n  )\n}\n\nfunction RiderDetail() {\n  return <RiderLevel />\n}\n\nclass RiderLevel extends React.Component {\n  static contextType = RiderContext\n  render() {\n    return <Avatar avatar={this.context} />;\n  }\n}\n")),(0,o.kt)("h3",null,"新的生命周期(16.3)"),(0,o.kt)("p",null,(0,o.kt)("img",u({parentName:"p"},{src:"https://user-images.githubusercontent.com/12389235/41266906-b6a6e75a-6e2b-11e8-8266-9597b2d57f11.png",alt:null}))),(0,o.kt)("p",null,"在未来 17 的版本中, 将移除的生命周期钩子如下:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"componentWillMount()"),": 移除这个 api 基于以下两点考虑:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"服务端渲染: 在服务端渲染的情景下, componentWillMount 执行完立马执行 render 会导致 componentWillMount 里面执行的方法(获取数据, 订阅事件) 并不一定执行完;"),(0,o.kt)("li",{parentName:"ul"},"Concurrent Render: 在 fiber 架构下, render 前的钩子会被多次调用, 在 componentWillMount 里执行订阅事件就会产生内存泄漏;")))),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"迁移思路, 将以前写在 ",(0,o.kt)("inlineCode",{parentName:"p"},"componentWillMount")," 的获取数据、时间订阅的方法写进 ",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidMount")," 中;")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"componentWillReceiveProps(nextProps)"),": 移除这个 api 基于如下考虑:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"语义不太契合逻辑"),(0,o.kt)("li",{parentName:"ul"},"phase1 阶段会多次调用")))),(0,o.kt)("p",null,"新的钩子 ",(0,o.kt)("inlineCode",{parentName:"p"},"getDerivedStateFromProps()")," 更加纯粹, 它做的事情是将新传进来的属性和当前的状态值进行对比, 若不一致则更新当前的状态。"),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"getDerivedStateFromProps(nextProps, prevState) {\n  if (nextProps.riderId !== prevState.riderId) {\n    return {\n      riderId: nextProps.riderId\n    }\n  }\n  // 返回 null 则表示 state 不用作更新\n  return null\n}\n")),(0,o.kt)("p",null,"另外关于 componentWillReceiveProps() 在 15 里大量使用的一个场景: 比如切换 tab 时都要重新获取当前页面的数据, 之前通常会这么做:"),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"componentWillReceiveProps(nextProps) {\n  if (nextProps.riderId !== this.props.riderId) {\n    fetchData(nextProps.riderId)\n  }\n}\n")),(0,o.kt)("p",null,"在 16 中可以使用 memoize 来代替, 写法如下:"),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),'import memoize from "memoize-one"\n\nclass Demo extends React.Component {\n  fetchDataDemo = memoize((riderId) => fetchData(riderId))\n\n  componentDidUpdate() {\n    fetchDataDemo(this.props.riderId)\n  }\n}\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"componentWillUpdate()"),": 目前将其理解为和 ",(0,o.kt)("inlineCode",{parentName:"li"},"componentWillMount")," 一样的情况")),(0,o.kt)("p",null,"在 React 16.3 的版本中, 新加入了两个生命周期:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"getDerivedStateFromProps(nextProps, prevState)"),": 更加语义化, 用来替代 ",(0,o.kt)("inlineCode",{parentName:"p"},"componentWillMount()")," 和 ",(0,o.kt)("inlineCode",{parentName:"p"},"componentWillReceiveProps(nextProps)"),";")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"getSnapshotBeforeUpdate(prevProps, prevState)"),": 可以将该钩子返回的结果传入 componentDidUpdate 的第三个参数中, 从而达到 dom 数据统一。用来替代 componentWillUpdate();"))),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"具体 demo 可见 ",(0,o.kt)("a",u({parentName:"p"},{href:"https://react.docschina.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state"}),"Update on Async Rendering"))),(0,o.kt)("h3",null,"React.memo(16.6)"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"React.memo")," 是一个高阶组件, 它使无状态组件拥有有状态组价中的 ",(0,o.kt)("inlineCode",{parentName:"p"},"shouldComponentUpdate()")," 以及 ",(0,o.kt)("inlineCode",{parentName:"p"},"PureComponent")," 的能力。"),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"const MyComponent = React.memo(function MyComponent(props) {\n  ...\n})\n")),(0,o.kt)("h3",null,"Hooks(16.7)"),(0,o.kt)("p",null,"在 React 16.7 之前, React 有两种形式的组件, 有状态组件(类)和无状态组件(函数)。Hooks 的意义就是赋能先前的无状态组件, 让之变为有状态。这样一来更加契合了 React 所推崇的函数式编程。"),(0,o.kt)("p",null,"接下来梳理 Hooks 中最核心的 2 个 api, ",(0,o.kt)("inlineCode",{parentName:"p"},"useState")," 和 ",(0,o.kt)("inlineCode",{parentName:"p"},"useEffect")),(0,o.kt)("h4",null,"useState"),(0,o.kt)("p",null,"useState 返回状态和一个更新状态的函数"),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"const [count, setCount] = useState(initialState)\n")),(0,o.kt)("p",null,"使用 Hooks 相比之前用 class 的写法最直观的感受是更为简洁"),(0,o.kt)("pre",null,(0,o.kt)("code",u({parentName:"pre"},{className:"language-js"}),"function App() {\n  const [count, setCount] = useState(0)\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  )\n}\n")),(0,o.kt)("h4",null,"useEffect(fn)"),(0,o.kt)("p",null,"在每次 render 后都会执行这个钩子。可以将它当成是 ",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidMount"),"、",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidUpdate"),"、",(0,o.kt)("inlineCode",{parentName:"p"},"componentWillUnmount")," 的合集。因此使用 useEffect 比之前优越的地方在于:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"可以避免在 ",(0,o.kt)("inlineCode",{parentName:"li"},"componentDidMount、componentDidUpdate")," 书写重复的代码;"),(0,o.kt)("li",{parentName:"ol"},"可以将关联逻辑写进一个 ",(0,o.kt)("inlineCode",{parentName:"li"},"useEffect"),"(在以前得写进不同生命周期里);")),(0,o.kt)("h3",null,"React 的未来"),(0,o.kt)("p",null,(0,o.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/fd1dd7ca2ba34bebef2d489c63befa25.jpg-200",alt:null}))),(0,o.kt)("p",null,"今年的 React Conf 的一张图, 可以看到 React 从出来到现在势头呈稳健上升趋势, 并在 2018 年这个节点上把 Jquery 拉下了王座。但可以看见 React 未来还有一段很长的路要走。"),(0,o.kt)("h3",null,"相关链接"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",u({parentName:"li"},{href:"https://reactjs.org/blog/all.html"}),"reactjs.org"))))}c.isMDXComponent=!0}}]);