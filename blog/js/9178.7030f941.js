(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9178],{29178:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>s});var r=t(59713),l=t.n(r),a=t(6479),i=t.n(a),u=(t(67294),t(3905));function p(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function m(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?p(Object(t),!0).forEach((function(e){l()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):p(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var o={};function s(n){var e=n.components,t=i()(n,["components"]);return(0,u.kt)("wrapper",m(m(m({},o),t),{},{components:e,mdxType:"MDXLayout"}),(0,u.kt)("p",null,"给定一个已按照升序排列的",(0,u.kt)("inlineCode",{parentName:"p"},"有序数组"),"，找到两个数使得它们相加之和等于目标数。"),(0,u.kt)("p",null,"函数应该返回这两个下标值 index1 和 index2, 其中 index1 必须小于 index2。"),(0,u.kt)("p",null,"说明:"),(0,u.kt)("p",null,"返回的下标值(index1 和 index2)不是从零开始的。\n你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。"),(0,u.kt)("p",null,"示例:"),(0,u.kt)("pre",null,(0,u.kt)("code",m({parentName:"pre"},{className:"language-js"}),"输入: numbers = [2, 7, 11, 15], target = 9\n输出: [1, 2]\n解释: 2 与 7 之和等于目标数 9。因此 index1 = 1, index2 = 2。\n")),(0,u.kt)("h3",null,"题解"),(0,u.kt)("p",null,"注意题目给出的条件 ",(0,u.kt)("inlineCode",{parentName:"p"},"有序数组")),(0,u.kt)("p",null,"解法一: 因为是有序数组, 题目可以转化为: 第一个值的下标为 ",(0,u.kt)("inlineCode",{parentName:"p"},"i")," 时, 在剩余的有序数组中寻找 ",(0,u.kt)("inlineCode",{parentName:"p"},"target - number[i]"),"。因而该算法时间复杂度为 ",(0,u.kt)("inlineCode",{parentName:"p"},"O(NlogN)"),"。"),(0,u.kt)("p",null,(0,u.kt)("img",m({parentName:"p"},{src:"http://with.muyunyun.cn/4bd2e0a2986f09b8efa56972810291d4.jpg",alt:null}))),(0,u.kt)("pre",null,(0,u.kt)("code",m({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[]} numbers\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(numbers, target) {\n  for (let i = 0; i < numbers.length; i++) {\n    const index = binarySearch(numbers, target - numbers[i])\n    if (typeof(index) === 'number') {\n      return [i + 1, index + 1]\n    }\n  }\n}\n\nvar binarySearch = function(arr, value) {\n  let left = 0\n  let right = arr.length - 1\n\n  while (left <= right) {\n    const mid = left + Math.ceil((right - left) / 2)\n    if (arr[mid] === value) {\n      return mid\n    } else if (arr[mid] < value) {\n      left = mid + 1\n    } else if (arr[mid] > value) {\n      right = mid - 1\n    }\n  }\n  return null\n}\n")),(0,u.kt)("p",null,"解法二: 用",(0,u.kt)("inlineCode",{parentName:"p"},"对撞指针(双指针)"),"实现时间复杂度为 ",(0,u.kt)("inlineCode",{parentName:"p"},"O(n)")," 的算法。"),(0,u.kt)("pre",null,(0,u.kt)("code",m({parentName:"pre"},{className:"language-js"}),"/**\n * @param {number[]} numbers\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(numbers, target) {\n  let left = 0\n  let right = numbers.length - 1\n\n  while (left <= right) {\n    const sum = numbers[left] + numbers[right]\n    if (sum === target) {\n      return [left + 1, right + 1]\n    } else if (sum > target) {\n      right--\n    } else if (sum < target) {\n      left++\n    }\n  }\n}\n")),(0,u.kt)("h3",null,"相似问题"),(0,u.kt)("p",null,"125、344、345"))}s.isMDXComponent=!0}}]);