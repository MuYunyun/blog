(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8337],{68337:e=>{e.exports="### React Hooks 深入系列\n\n在 class 已经融入 React 生态的节点下, React 推出的 Hooks 具有如下优势:\n\n* 更简洁的书写;\n* 相对类中的 `HOC` 与 `render Props`, Hooks 拥有更加自由地组合抽象的能力;\n\n### 使用 Hooks 的注意项\n\n* 在 `hooks` 中每一次 `render` 都有自己的 `state` 和 `props`, 这与 `class` 中存在差异, 见 [Hooks 每次渲染都是闭包](https://overreacted.io/a-complete-guide-to-useeffect/#each-render-has-its-own-everything)\n  * `class` 中可以用闭包模拟 `hooks` 的表现, [链接](https://codesandbox.io/s/w7vjo07055), `hooks` 中可以使用 `ref` 模拟 `class` 的表现, [链接](https://codesandbox.io/s/rm7z22qnlp);\n\n* 写出 useEffect 的所用到的依赖\n\n在以下 demo 中, `useEffect` 的第二个参数传入 `[]`, 希望的是 `useEffect` 里的函数只执行一次(类似在 `componentDidMount` 中执行一次, 但是注意这里仅仅是`类似`, 详细原因见上一条注意项), 页面上每隔 1s 递增 1。\n\n```js\nfunction Demo() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n    return () => {\n      clearInterval(id);\n    };\n  }, []);\n\n  return count;\n}\n```\n\n但这样达到我们预期的效果了么? [demo](https://codesandbox.io/s/n3o2m1wpj4), 可以看到界面上只增加到 1 就停止了。原因就是传入的第二个参数 `[]` 搞的鬼, `[]` 表示没有外界状态对 `effect` 产生干扰。流程大致如下:\n\n1. 第一次调用 `useEffect` 传入的 `count` 为 0, 于是 `setCount(0 + 1)`;\n2. 受 `useEffect` 第二个参数 `[]` 的影响，`count` 仍然为 0, 所以相当于还是 `setCount(0 + 1)`;\n\n那如何修正上述问题呢? 方法有两个(方法一为主, 方法二为辅):\n\n* 方法一: 将 `[]` 改为 `[count]`\n* 方法二: 将 `setCount(count + 1)` 改为 `setCount(count => count + 1)`。这种方法的思想是修正状态的值而不依赖外面传进的状态。\n\n不过遇到 `setCount(count => count + 1)` 的情况就可以考虑使用 `useReducer` 了。\n\n#### 何时使用 useReducer\n\n使用 `useState` 的地方都能用 `useReducer` 进行替代。相较 `useState`, `useReducer` 有如下优势:\n\n* `useReducer` 将 `how`(reducer) 和 `what`(dispatch(action)) 进行抽离; 使用 `reducer` 逻辑状态进行集中化维护;\n* 相比 useState, useReducer 没有[闭包问题](https://overreacted.io/a-complete-guide-to-useeffect/#each-render-has-its-own-everything);\n* 当状态的一个 state 依赖状态中的另一个 state 时, 这种情况最好使用 `useReducer`; 可以参考 [decoupling-updates-from-actions](https://overreacted.io/a-complete-guide-to-useeffect/#decoupling-updates-from-actions) 中 Dan 列举的 demo。\n\n#### 处理 useEffect 中的公用函数\n\n```js\nfunction Demo() {\n  const [count, setCount] = useState(0);\n\n  function getFetchUrl(query) {\n    return `http://demo${query}`\n  }\n\n  useEffect(() => {\n    const url = getFetchUrl('react')\n  }, [getFetchUrl]);\n\n  useEffect(() => {\n    const url = getFetchUrl('redux')\n  }, [getFetchUrl]);\n\n  return count;\n}\n```\n\n此时 `useEffect` 中传入的第二个参数 `getFetchUrl` 相当于每次都是新的, 所以每次都会请求数据, 那除了 `[getFetchUrl]` 将改为 `[]` 这种不推荐的写法外，有两种解决方法:\n\n*. 方法一: 提升 `getFetchUrl` 的作用域;\n*. 方法二: 使用 `useCallback` 或者 `useMemo` 来包裹 getFetchUrl;\n\n> `React.memo` 修饰一个函数组件, `useMemo` 修饰一个函数。它们本质都是运用缓存。\n\n### React Hooks 内部是怎么工作的\n\n为了理解 React Hooks 内部实现原理, 对 `useState`、`useEffect` 进行了简单的实现。\n\n#### useState 的简单实现\n\n使用闭包来实现 `useState` 的简单逻辑:\n\n```js\n// 这里使用闭包\nconst React = (function() {\n  let _val\n\n  return {\n    useState(initialValue) {\n      _val = _val || initialValue\n\n      function setVal(value) {\n        _val = value\n      }\n\n      return [_val, setVal]\n    }\n  }\n})()\n```\n\n测试如下:\n\n```js\nfunction Counter() {\n  const [count, setCount] = React.useState(0)\n\n  return {\n    render: () => console.log(count),\n    click: () => setCount(count + 1)\n  }\n}\n\nCounter().render() // 0\nCounter().click()  // 模拟点击\nCounter().render() // 1\n```\n\n#### useEffect 的简单实现\n\n```js\nvar React = (function() {\n  let _val, _deps\n\n  return {\n    useState(initialValue) {\n      _val = _val || initialValue\n\n      function setVal(value) {\n        _val = value\n      }\n\n      return [_val, setVal]\n    },\n    useEffect(callback, deps) {\n      const ifUpdate = !deps\n\n      // 判断 Deps 中的依赖是否改变\n      const ifDepsChange = _deps ? !_deps.every((r, index) => r === deps[index]) : true\n\n      if (ifUpdate || ifDepsChange) {\n        callback()\n\n        _deps = deps || []\n      }\n    }\n  }\n})()\n```\n\n测试代码如下:\n\n```js\nvar {useState, useEffect} = React\n\nfunction Counter() {\n  const [count, setCount] = useState(0)\n\n  useEffect(() => {\n    console.log('useEffect', count)\n  }, [count])\n\n  return {\n    render: () => console.log('render', count),\n    click: () => setCount(count + 1),\n    noop: () => setCount(count), // 保持不变, 观察 useEffect 是否被调用\n  }\n}\n\nCounter().render() // 'useEffect' 0, 'render', 0\nCounter().noop()\nCounter().render() // 'render', 0\nCounter().click()\nCounter().render() // 'useEffect' 1, 'render', 1\n```\n\n#### 处理多次调用的情形\n\n为了在 `hooks` 中能使用多次 `useState`, `useEffect`, 将各个 `useState`, `useEffect` 的调用存进一个数组中, 在上面基础上进行如下改造:\n\n```js\nconst React = (function() {\n  const hooks = []\n  let currentHook = 0\n\n  return {\n    render(Component) {\n      const component = Component()\n      component.render()\n      currentHook = 0 // 重置, 这里很关键, 将 hooks 的执行放到 hooks 队列中, 确保每次执行的顺序保持一致。\n      return component\n    },\n    useState(initialValue) {\n      hooks[currentHook] = hooks[currentHook] || initialValue\n\n      function setVal(value) {\n        hooks[currentHook] = value\n      }\n\n      return [hooks[currentHook++], setVal]\n    },\n    useEffect(callback, deps) {\n      const ifUpdate = !deps\n\n      // 判断 Deps 中的依赖是否改变\n      const ifDepsChange = hooks[currentHook] ? !hooks[currentHook].every((r, index) => r === deps[index]) : true\n\n      if (ifUpdate || ifDepsChange) {\n        callback()\n\n        hooks[currentHook++] = deps || []\n      }\n    }\n  }\n})()\n```\n\n测试代码如下:\n\n```js\nvar {useState, useEffect} = React\n\nfunction Counter() {\n  const [count, setCount] = useState(0)\n  const [type, setType] = useState('hi')\n\n  useEffect(() => {\n    console.log('useEffect', count)\n    console.log('type', type)\n  }, [count, type])\n\n  return {\n    render: () => console.log('render', count),\n    click: () => setCount(count + 1),\n    noop: () => setCount(count), // 保持不变, 观察 useEffect 是否被调用\n  }\n}\n\n/* 如下 mock 执行了 useEffect、render; 这里使用 React.render 的原因是为了重置 currentHook 的值 */\nlet comp = React.render(Counter) // useEffect 0 type hi render 0\n\n/* 如下 mock 只执行了 render */\ncomp.noop()\ncomp = React.render(Counter) // render 0\n\n/* 如下 mock 重新执行了 useEffect、render */\ncomp.click()\nReact.render(Counter) // useEffect 1, render 1\n```\n\n### 相关资源\n\n* [awesome-react-hooks](https://github.com/rehooks/awesome-react-hooks)\n* [usehooks](https://github.com/gragland/usehooks)\n* [deep-dive-how-do-react-hooks-really-work](https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/)\n* [a-complete-guide-to-useeffect](https://overreacted.io/a-complete-guide-to-useeffect/): 推荐 Dan 的这篇文章\n* [Hooks, State, Closures, and useReducer](https://adamrackis.dev/state-and-use-reducer/): 作为 [decoupling-updates-from-actions](https://overreacted.io/a-complete-guide-to-useeffect/#decoupling-updates-from-actions) 的补充\n* [Should I useState or useReducer](https://kentcdodds.com/blog/should-i-usestate-or-usereducer/):"}}]);