(self.webpackChunkblog=self.webpackChunkblog||[]).push([[577],{50577:n=>{n.exports="### 迭代器模式\n\n定义: 能访问到聚合对象的顺序与元素\n\n### 实现一个内部迭代器\n\n```js\nfunction each(arr, fn) {\n  for (let i = 0; i < arr.length; i++) {\n    fn(i, arr[i])\n  }\n}\n\neach([1, 2, 3], function(i, n) {\n  console.log(i) // 0 1 2\n  console.log(n) // 1 2 3\n})\n```\n\n可以看出内部迭代器在调用的时候非常简单, 使用者不用关心迭代器内部实现的细节, 但这也是内部迭代器的缺点。比如要比较两数组是否相等, 只能在其回调函数中作文章了, 代码如下:\n\n```js\nconst compare = function(arr1, arr2) {\n  each(arr1, function(i, n) {\n    if (arr2[i] !== n) {\n      console.log('两数组不等')\n      return\n    }\n  })\n  console.log('两数组相等')\n}\n\nconst arr1 = [1, 2, 3]\nconst arr2 = [1, 2, 3]\ncompare(arr1, arr2) // 两数组相等\n```\n\n### 实现一个外部迭代器\n\n相较于内部迭代器, 外部迭代器将遍历的权利转移到外部, 因此在调用的时候拥有了更多的自由性, 不过缺点是调用方式较复杂。\n\n```js\nconst iterator = function(arr) {\n  let current = 0\n  const next = function() {\n    current = current + 1\n  }\n  const done = function() {\n    return current >= arr.length\n  }\n  const value = function() {\n    return arr[current]\n  }\n  return {\n    next,\n    done,\n    value,\n  }\n}\n\nconst arr1 = [1, 2 ,3]\nconst arr2 = [1, 2, 3]\nconst iterator1 = iterator(arr1)\nconst iterator2 = iterator(arr2)\n\nconst compare = function(iterator1, iterator2) {\n  while (!iterator1.done() && !iterator2.done()) {\n    if (iterator1.value() !== iterator2.value()) {\n      console.log('两数组不等')\n      return\n    }\n    iterator1.next() // 外部迭代器将遍历的权利转移到外部\n    iterator2.next()\n  }\n  console.log('两数组相等')\n}\n\ncompare(iterator1, iterator2)\n```"}}]);