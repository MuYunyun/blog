(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8971],{58971:n=>{n.exports="### 归并排序思想\n\n1. 取一个基准点, 将数组不断拆分成左右两部分, 直到数组的长度为 1;\n2. 对拆离的数组进行`比较合并`;\n\n演示如下:\n\n```js\n3   1   5   2\n\n3   1 | 5   2\n\n3 | 1 | 5 | 2\n\n1   3 | 2   5\n\n1   2   3   5\n```\n\n### 代码实现\n\n```js\n// 可以把它当成分函数\nvar mergeSort = function(arr) {\n  // 将数组 arr 拆分成 [0, point) 和 [point, arr.length] 两部分\n  const point = arr.length / 2\n  const left = arr.slice(0, point)\n  const right = arr.slice(point, arr.length)\n\n  if (arr.length === 1) {\n    return arr\n  }\n\n  return merge(mergeSort(left), mergeSort(right))\n}\n\n// 可以当作是合函数\nfunction merge(left, right) {\n  let l = 0 // 第一个数组的下标\n  let r = 0 // 第二个数组的下标\n  const result = []\n\n  while (l < left.length && r < right.length) {\n    if (left[l] < right[r]) {\n      result.push(left[l])\n      l++\n    } else {\n      result.push(right[r])\n      r++\n    }\n  }\n\n  while (l < left.length) {\n    result.push(left[l])\n    l++\n  }\n\n  while (r < right.length) {\n    result.push(right[r])\n    r++\n  }\n\n  return result\n}\n```\n\n### 归并排序与快速排序的异同\n\n归并排序与快速排序都是用递归来实现的算法, 都是分分合合的过程。区别在于归并排序在合的过程中进行排序, 快速排序则在分的过程中进行排序。另外它们的时间复杂度都为 O(nlogn)。"}}]);