(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3503],{73503:(t,n,e)=>{"use strict";e.r(n),e.d(n,{default:()=>c});var r=e(59713),p=e.n(r),l=e(6479),o=e.n(l),i=(e(67294),e(3905));function a(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,r)}return e}function u(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?a(Object(e),!0).forEach((function(n){p()(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):a(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}var s={};function c(t){var n=t.components,e=o()(t,["components"]);return(0,i.kt)("wrapper",u(u(u({},s),e),{},{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h3",null,"partition 划分算法"),(0,i.kt)("p",null,"算法思路:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"第一步: 找一个",(0,i.kt)("inlineCode",{parentName:"li"},"枢纽值")," pivot;"),(0,i.kt)("li",{parentName:"ul"},"第二步: 使用一个",(0,i.kt)("inlineCode",{parentName:"li"},"指针去遍历数组"),", 小于 pivot 的值都放在数组左侧(pivot 的右侧);"),(0,i.kt)("li",{parentName:"ul"},"第三步: 将 pivot 移到数组的",(0,i.kt)("inlineCode",{parentName:"li"},"中间位置"),", pivot 左侧都是比 pivot 小的值, pivot 右侧都是比 pivot 大的值; 返回 pivot 的下标;")),(0,i.kt)("p",null,"比如针对数组 ",(0,i.kt)("inlineCode",{parentName:"p"},"[5,9,2,7,3]"),", 分解算法步骤图:"),(0,i.kt)("p",null,(0,i.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/f86a764f83302f8d5bba02024e0dcb04.jpg",alt:null}))),(0,i.kt)("h3",null,"算法实现"),(0,i.kt)("p",null,"用了双指针。"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-js"}),"/* 分区算法 */\nfunction partition(nums, left, right) {\n  const pivot = nums[left] // 枢纽值\n  let pos = left           // 用来记住最后枢纽值 pivot 应该置于的位置\n  for (let i = left + 1; i <= right; i++) {\n    if (nums[i] < pivot) {\n      pos++\n      swap(nums, pos, i)\n    }\n  }\n  swap(nums, pos, left)\n  return pos\n}\n\n/* 交换位置\n  nums 数组, a, b 为下标\n*/\nvar swap = function(nums, a, b) {\n  const tmp = nums[a]\n  nums[a] = nums[b]\n  nums[b] = tmp\n}\n")),(0,i.kt)("p",null,"测试"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-js"}),"var testArr = [5, 9, 2, 7, 3]\nvar result = partition(testArr, 0, 4)\n\nresult === 2\nconsole.log(testArr) // [3, 2, 5, 7, 9]\n")),(0,i.kt)("h3",null,"partition 算法的作用"),(0,i.kt)("p",null,"见 leetcode 215: 数组中的第 K 个最大元素"))}c.isMDXComponent=!0}}]);