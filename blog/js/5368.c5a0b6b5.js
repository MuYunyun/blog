(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5368],{25368:t=>{t.exports="### 解读 IoC 框架 InversifyJS\n\nInversityJS 是一个 IoC 框架。IoC(Inversion of Control) 包括依赖注入(Dependency Injection) 和依赖查询(Dependency Lookup)。\n\n相比于类继承的方式, 控制反转解耦了父类和子类的联系。\n\n### 案例解析\n\n```ts\nimport 'reflect-metadata'\nimport { inject, injectable, Container } from 'inversify'\n\nconst container = new Container()\n\n@injectable()\nclass PopMusic {\n  getName() {\n    return '流行音乐'\n  }\n}\ncontainer.bind('request1').to(PopMusic)\n\n@injectable()\nclass ClassicalMusic {\n  getName() {\n    return '古典音乐'\n  }\n}\ncontainer.bind('request2').to(ClassicalMusic)\n\n@injectable()\nclass Music {\n  pm: any\n  cm: any\n  constructor(\n    @inject('request1') popMusic: any,\n    @inject('request2') classicalMusic: any) {\n    this.pm = popMusic\n    this.cm = classicalMusic\n  }\n\n  getName() {\n    const result = this.pm.getName() + this.cm.getName()\n    return result\n  }\n}\ncontainer.bind('Plan').to(Music)\n\nconst music: any = container.get('Plan')\nconsole.log(music.getName()) // 流行音乐古典音乐\n```\n\n上述案例可以抽象为下图:\n\n![explain](http://with.muyunyun.cn/8a9ccba28d00ea0c752c3601d716ebcd.jpg-400)\n\n> 虚线表示可以注入, 但在代码中没有表现出来。\n\n代码流程可概括如下:\n\n1.将所有相关类(这里指 Music、popMusic、classicMusic) 通过 `@injectable` 声明进 `container` 容器;\n\n2.通过 `container.get()` 获取 `container.bind().to(target)` 中的目标对象(这里指 Music);\n\n3.如果目标对象中的 constructor() 里有 `@inject()`, 则将相应的实例(这里指 PopMusic 与 classicalMusic 的实例)当作构造函数的参数'注入';\n\n### inject/injectable 相关源码\n\ninject 源码简化如下:\n\n```js\n// 这是一个属性装饰器\nfunction inject(serviceIdentifier) {\n  return function (target, targetKey) {\n    const metadataValue = { [targetKey]: [Metadata { key: 'inject', value: serviceIdentifier })] }\n    Reflect.defineMetadata('inversify:tagged_props', metadataValue, target.constructor);\n  }\n}\n```\n\ninjectable 源码简化如下:\n\n```js\n// 这是一个类装饰器\nfunction injectable() {\n  return function (target) {\n    const metadataValue = []\n    Reflect.defineMetadata('inversify:paramtypes', metadataValue, target)\n    return target\n  }\n}\n```\n\n从简化版源码中可以看到 inject/injectable 最终是对 `Reflect.defineMetadata()` 的一个使用。可以将 metadata 看成是一种相对高效的数据结构。\n\n#### reflect-metadata\n\nInversityJS 深度结合了 [reflect-metadata](https://github.com/rbuckton/reflect-metadata), reflect-metadata 在 Reflect 基础上对其 api 进行了扩展。\n\n> metadata 本质上是一个 `WeakMap` 对象。扩展: [Map 和 WeakMap 的区别](https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/字典.md#map-和-weakmap-的区别)\n\n`Reflect.defineMetadata(metadataKey, metadataValue, target[, propertyKey])` 简化版实现如下:\n\n```js\nconst Metadata = new WeakMap()\n\nfunction defineMetadata(metadataKey, metadataValue, target, propertyKey) {\n  metadataMap = new Map()\n  metadataMap.set(metadataKey, metadataValue)\n  targetMetadata = new Map()\n  targetMetadata.set(propertyKey, metadataMap)\n  Metadata.set(target, targetMetadata)\n}\n```\n\n`Reflect.getOwnMetadata(metadataKey, target[, propertyKey])` 简化版实现如下:\n\n```js\nfunction getOwnMetadata(metadataKey, target, propertyKey) {\n  var targetMetadata = Metadata.get(target)\n  var metadataMap = targetMetadata.get(propertyKey)\n  return metadataMap.get(metadataKey)\n}\n```\n\n其数据结构可表示如下:\n\n```js\nWeakMap {\n  target: Map {\n    propertyKey: Map {\n      metadataKey: metadataValue\n    }\n  }\n}\n```\n\n### 相关链接\n\n* [Architecture overview](https://github.com/inversify/InversifyJS/blob/master/wiki/architecture.md)"}}]);