(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7005],{97005:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>c});var r=t(59713),a=t.n(r),i=t(6479),l=t.n(i),u=(t(67294),t(3905));function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function p(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){a()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var s={};function c(n){var e=n.components,t=l()(n,["components"]);return(0,u.kt)("wrapper",p(p(p({},s),t),{},{components:e,mdxType:"MDXLayout"}),(0,u.kt)("h3",null,"23.Merge k Sorted Lists"),(0,u.kt)("p",null,"Merge k ",(0,u.kt)("inlineCode",{parentName:"p"},"sorted linked lists")," and return it as ",(0,u.kt)("inlineCode",{parentName:"p"},"one sorted list"),". Analyze and describe its complexity."),(0,u.kt)("p",null,"Example:"),(0,u.kt)("pre",null,(0,u.kt)("code",p({parentName:"pre"},{className:"language-js"}),"Input:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nOutput: 1->1->2->3->4->4->5->6\n")),(0,u.kt)("h3",null,"Analyze"),(0,u.kt)("p",null,"思路一: 分治算法。可以将合并 k 个排序队列转换为合并 2 个排序队列。"),(0,u.kt)("p",null,"图例解释:"),(0,u.kt)("pre",null,(0,u.kt)("code",p({parentName:"pre"},{className:"language-js"}),"   cur\ndummyNode -> 1 -> 4 -> 5\n\ncomparedCur\n    2       -> 6\n")),(0,u.kt)("pre",null,(0,u.kt)("code",p({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nvar mergeKLists = function(lists) {\n  let result = lists[0] || null\n\n  for (let i = 1; i < lists.length; i++) {\n    const compareList = lists[i]\n    result = mergeTwoLists(result, compareList)\n  }\n  return result\n}\n\nvar mergeTwoLists = function(curList, compareList) {\n  const dummyNode = new ListNode(0)\n  dummyNode.next = curList\n  let cur = dummyNode\n  let comparedCur = compareList\n\n  while (cur.next && comparedCur) {\n    if (cur.next.val > comparedCur.val) {\n      let nextComparedCur = comparedCur.next\n      comparedCur.next = cur.next\n      cur.next = comparedCur\n      comparedCur = nextComparedCur\n    }\n    cur = cur.next\n  }\n  if (comparedCur) {\n    cur.next = comparedCur\n  }\n\n  return dummyNode.next\n}\n")),(0,u.kt)("p",null,"思路二: 优先队列"),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},"将数组中的队列加入进优先队列(基于最小堆);"),(0,u.kt)("li",{parentName:"ul"},"如果当前优先队列不为空:",(0,u.kt)("ul",{parentName:"li"},(0,u.kt)("li",{parentName:"ul"},"取出当前",(0,u.kt)("inlineCode",{parentName:"li"},"优先队列顶部队列元素"),"(最小值), 拼接到",(0,u.kt)("inlineCode",{parentName:"li"},"输出队列"),"中;"),(0,u.kt)("li",{parentName:"ul"},"同时在优先队列插入取出的顶部队列元素的下一个值;")))),(0,u.kt)("p",null,"由于在 JavaScrit 中没有封装好的优先队列, 在此先进行封装",(0,u.kt)("inlineCode",{parentName:"p"},"优先队列函数"),"(最小堆)。"),(0,u.kt)("pre",null,(0,u.kt)("code",p({parentName:"pre"},{className:"language-js"}),"var len\n\n/**\n * to build min heapify from bottom to top;\n * the last subscript's parent subscript is Math.floor((len - 1) / 2)\n */\nvar buildMinHeapify = function(arr) {\n  len = arr.length\n\n  for (let i = Math.floor((len - 1) / 2); i >= 0; i--) {\n    siftDown(arr, i)\n  }\n  return arr\n}\n\n/**\n * Insert a value into heap. It's an operation called sift up.\n */\nvar enqueue = function(arr, value) {\n  arr.splice(len, 0, value)\n  len++\n  siftUp()\n}\n\n/**\n * to keep min heap, it's an operation called sift up.\n */\nvar siftUp = function() {\n  let enqueueValSubscript = len - 1\n  let parent = Math.floor(enqueueValSubscript / 2)\n  while (parent > 0 && arr[parent] > arr[enqueueValSubscript]) {\n    swap(arr, parent, enqueueValSubscript)\n    enqueueValSubscript = parent\n    parent = Math.floor(enqueueValSubscript / 2)\n  }\n}\n\n/*\n * to pick the smallest or the biggest element from the heap and return it;\n * Then t'll swap the endest element with the first element, and then keep the\n * heap length reduce one. If so, only do once sift down operation in the first element to keep heapify.\n */\nvar dequeue = function() {\n  const maxValue = arr[0]\n  swap(arr, len - 1, 0)\n  len--\n  siftDown(arr, 0)\n  return maxValue\n}\n\n/**\n * to keep min heap, it's an operation called sift down.\n */\nvar siftDown = function(arr, i) {\n  const left = 2 * i + 1\n  const right = 2 * i + 2\n  let minSubscript = i\n\n  if (left < len && arr[left] < arr[minSubscript]) {\n    minSubscript = left\n  }\n\n  if (right < len && arr[right] < arr[minSubscript]) {\n    minSubscript = right\n  }\n\n  if (minSubscript !== i) {\n    swap(arr, minSubscript, i)\n    siftDown(arr, minSubscript)\n  }\n}\n\n// swap two value in arr\nvar swap = function(arr, pointOne, pointTwo) {\n  const tmp = arr[pointOne]\n  arr[pointOne] = arr[pointTwo]\n  arr[pointTwo] = tmp\n}\n")),(0,u.kt)("p",null,"Test case one:"),(0,u.kt)("pre",null,(0,u.kt)("code",p({parentName:"pre"},{className:"language-js"}),"input: var arr = [5, 2, 7, 3, 1, 8, 4]\n\n           8\n        ↙     ↘\n     3          7\n  ↙    ↘      ↙   ↘\n2        1  5       4\n\nbuildMinHeapify(arr) // [1, 2, 4, 3, 5, 8, 7]\n\n           1                                           1\n        ↙     ↘          enqueue(arr, 6)            ↙     ↘\n     2          4        ---------------\x3e         2          4\n  ↙    ↘      ↙   ↘                            ↙    ↘      ↙   ↘\n3        5  8       7                        3        5  8        7\n                                           ↙\n                                         6\n\n                                     2\n        return 1                  ↙     ↘\n        dequeue()               3         4\n    ----------------\x3e        ↙    ↘     ↙   ↘\n                           6       5   8      7\n")),(0,u.kt)("p",null,"在 JavaScript 中使用优先队列成本相对较高, 暂时不考虑。"))}c.isMDXComponent=!0}}]);