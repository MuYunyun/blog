(self.webpackChunkblog=self.webpackChunkblog||[]).push([[758],{30758:n=>{n.exports="## bind 函数实现\n\n### 第一版: 借助 call/apply\n\n```js\nFunction.prototype.bind1 = function (context) {\n  const self = this\n  return function () {\n    return self.call(context)\n  }\n}\n\n// 测试:\nconst obj = {\n  value: 'muyy',\n}\nfunction testBind() {\n  console.log(this.value)\n}\nconst resultBind = testBind.bind1(obj)\nresultBind() // muyy\n```\n\n### 第二版: 借助 arguments\n\n```js\nFunction.prototype.bind2 = function (context) {\n  const arr = Array.prototype.slice.call(arguments, 1)\n  const self = this\n  return function () {\n    const restArr = Array.prototype.slice.call(arguments)\n    return self.apply(context, arr.concat(restArr))\n  }\n}\n```\n\n> 这种方式的实现其实是函数柯里化的变版\n\n比如在监听事件时可以这样子用:\n\n```js\ndom.addEventListener('click', fn.bind(this))\n```\n\n进行如下测试:\n\n```js\nconst obj2 = {\n  value: 'muyy',\n}\nfunction testBind2(age, gender) {\n  console.log(this.value) // muyy\n  console.log(age)        // 23\n  console.log(gender)     // male\n}\nconst resultBind2 = testBind2.bind2(obj2, 23)\nresultBind2('male')\n```\n\n### 第三版: 区分环境, 是普通调用还是 new 调用\n\n```js\nFunction.prototype.bind3 = function (context) {\n  const arr = Array.prototype.slice.call(arguments, 1)\n  const self = this\n  return function () {\n    const restArr = Array.prototype.slice.call(arguments)\n    return self.apply(this !== windows ? this : context, arr.concat(restArr))\n  }\n}\n\n// 测试: 使用 new 以后 this 会指向 newObj\nconst obj3 = {\n  value: 'muyy',\n}\nfunction testBind3(age, gender) {\n  console.log(this.value)\n  console.log(age)\n  console.log(gender)\n}\nconst resultBind3 = testBind3.bind3(obj3, 23, 'male')\nconst newObj = new resultBind3()\n```"}}]);