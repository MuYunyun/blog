(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4461],{24461:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>c});var a=t(59713),l=t.n(a),p=t(6479),o=t.n(p),r=(t(67294),t(3905));function u(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function s(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?u(Object(t),!0).forEach((function(e){l()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):u(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var i={};function c(n){var e=n.components,t=o()(n,["components"]);return(0,r.kt)("wrapper",s(s(s({},i),t),{},{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h3",null,"从一个疑问点开始"),(0,r.kt)("p",null,"接上一章 ",(0,r.kt)("a",s({parentName:"p"},{href:"https://github.com/MuYunyun/blog/blob/master/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0React/8.HOC%E6%8E%A2%E7%B4%A2.md#%E5%B1%9E%E6%80%A7%E4%BB%A3%E7%90%86props-proxy"}),"HOC 探索")," 抛出的问题 ———— react 中的 onChange 事件和原生 DOM 事件中的 onchange 表现不一致, 举例说明如下:"),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-js"}),"// React 中的 onChange 事件\nclass App extends Component {\n  constructor(props) {\n    super(props)\n    this.onChange = this.onChange.bind(this)\n  }\n\n  onChange(e) {\n    console.log('键盘松开立刻执行')\n  }\n\n  render() {\n    return (\n      <input onChange={this.onChange} />\n    )\n  }\n}\n\n/*--------------分割线---------------*/\n\n// 原生 DOM 事件中的 onchange 事件: <input id='test'>\ndocument.getElementById('test').addEventListener('change', (e) => {\n  console.log('键盘松开以后还需按下回车键或者点下鼠标才会触发')\n})\n")),(0,r.kt)("h3",null,"拨云见雾"),(0,r.kt)("p",null,"我们来看下 React 的一个 issue ",(0,r.kt)("a",s({parentName:"p"},{href:"https://github.com/facebook/react/issues/13525"}),"React Fire: Modernizing React DOM"),"。有两点信息和这篇文章的话题相关。"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Drastically simplify the event system"),(0,r.kt)("li",{parentName:"ul"},"Migrate from onChange to onInput and don’t polyfill it for uncontrolled components")),(0,r.kt)("p",null,"从这两点内容我们可以得知下面的信息:"),(0,r.kt)("p",null,"React 实现了一套",(0,r.kt)("a",s({parentName:"p"},{href:"https://reactjs.org/docs/events.html#event-pooling"}),"合成事件机制"),", 也就是它的事件机制和原生事件间会有不同。比如它目前 onChange 事件其实对应着原生事件中的 input 事件。在这个 issue 中明确了未来会使用 onInput 事件替代 onChange 事件, 并且会大幅度地简化合成事件。"),(0,r.kt)("p",null,"有了以上信息后, 我们对 onChange 事件(将来的 onInput 事件)的代码作如下更改:"),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-js"}),"function setAttribute(dom, attr, value) {\n  ...\n  if (attr.match(/on\\w+/)) {        // 处理事件的属性:\n    let eventName = attr.toLowerCase().substr(2)\n    if (eventName === 'change') { eventName = 'input' } // 和现阶段的 react 统一\n    dom.addEventListener(eventName, value)\n  }\n  ...\n}\n")),(0,r.kt)("h3",null,"自由组件以及受控组件"),(0,r.kt)("p",null,"区分自由组件以及受控组件在于表单的值是否由 ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," 这个属性控制, 比较如下代码:"),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-js"}),"const case1 = () => <input />                    // 此时输入框内可以随意增减任意值\nconst case2 = () => <input defaultValue={123} /> // 此时输入框内显示 123, 能随意增减值\nconst case3 = () => <input value={123} />        // 此时输入框内显示 123, 并且不能随意增减值\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"case3")," 的情形即为简化版的受控组件。"),(0,r.kt)("h3",null,"受控组件的实现"),(0,r.kt)("p",null,"题目可以换个问法: 当 ",(0,r.kt)("inlineCode",{parentName:"p"},"input")," 的传入属性为 ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," 时(且没有 onChange 属性), 如何禁用用户的输入事件的同时又能获取焦点?"),(0,r.kt)("p",null,(0,r.kt)("img",s({parentName:"p"},{src:"http://with.muyunyun.cn/0fa301946b3f4bf315d742735c333562.jpg-200",alt:null}))),(0,r.kt)("p",null,"首先想到了 html 自带属性 readonly、disable, 它们都能禁止用户的输入, 但是它们不能满足获取焦点这个条件。结合前文 ",(0,r.kt)("inlineCode",{parentName:"p"},"onChange")," 的实现是监听 ",(0,r.kt)("inlineCode",{parentName:"p"},"input")," 事件, 代码分为以下两种情况:"),(0,r.kt)("p",null,"1.dom 节点包含 ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," 属性、",(0,r.kt)("inlineCode",{parentName:"p"},"onChange")," 属性\n2.dom 节点包含 ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," 属性, 不包含 ",(0,r.kt)("inlineCode",{parentName:"p"},"onChange")," 属性"),(0,r.kt)("p",null,"代码如下:"),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-js"}),"function vdomToDom(vdom) {\n  ...\n  if (vdom.attributes\n    && vdom.attributes.hasOwnProperty('onChange')\n    && vdom.attributes.hasOwnProperty('value')) { // 受控组件逻辑\n      ...\n      dom.addEventListener('input', (e) => {\n        changeCb.call(this, e)\n        dom.value = oldValue\n      })\n      ...\n    }\n  if (vdom.attributes\n    && !vdom.attributes.hasOwnProperty('onChange')\n    && vdom.attributes.hasOwnProperty('value')) { // 受控组件逻辑\n    ...\n    dom.addEventListener('input', (e) => {\n      dom.value = oldValue\n    })\n    ...\n  }\n  ...\n}\n")),(0,r.kt)("p",null,"可以发现它们的核心都在这段代码上:"),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-js"}),"dom.addEventListener('input', (e) => {\n  changeCb.call(this, e)\n  dom.value = oldValue\n})\n")),(0,r.kt)("p",null,"区别是当有 ",(0,r.kt)("inlineCode",{parentName:"p"},"onChange 属性")," 时, 能提供相应的回调函数 ",(0,r.kt)("inlineCode",{parentName:"p"},"changeCb")," 通过事件循环机制改变表单的值。看如下两个例子的比较:"),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-js"}),"const App = () => <input value={123} />\n")),(0,r.kt)("p",null,"效果如下:"),(0,r.kt)("p",null,(0,r.kt)("img",s({parentName:"p"},{src:"http://with.muyunyun.cn/353c8119b3c60a7f8f7696633c97ad28.jpg-200",alt:null}))),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-js"}),"class App extends Component {\n  constructor() {\n    super()\n    this.state = { num: 123 }\n    this.change = this.change.bind(this)\n  }\n\n  change(e) {\n    this.setState({\n      num: e.target.value\n    })\n  }\n\n  render() {\n    return (\n      <div>\n        <input value={this.state.num} onChange={this.change} />\n      </div>\n    )\n  }\n}\n")),(0,r.kt)("p",null,"这段代码中的 ",(0,r.kt)("inlineCode",{parentName:"p"},"change")," 函数即上个段落所谓的 ",(0,r.kt)("inlineCode",{parentName:"p"},"changeCb")," 函数, 通过 ",(0,r.kt)("inlineCode",{parentName:"p"},"setState")," 的事件循环机制改变表单的值。"),(0,r.kt)("p",null,"效果如下:"),(0,r.kt)("p",null,(0,r.kt)("img",s({parentName:"p"},{src:"http://with.muyunyun.cn/aec70ef0cebf603a0871d61f21e93532.gif",alt:null}))),(0,r.kt)("p",null,"至此, 模拟了受控组件的实现。"))}c.isMDXComponent=!0}}]);