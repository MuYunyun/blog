(self.webpackChunkblog=self.webpackChunkblog||[]).push([[677],{90677:n=>{n.exports="### Promise/A+ 核心\n\n![](http://with.muyunyun.cn/e1a0c15c44f9b014aa78d7b7620db474.jpg-200)\n\n在实现一个符合 Promise/A+ 规范的 promise 之前, 先了解下 Promise/A+ 核心, 想更全面地了解可以阅读 [Promise/A+规范](https://segmentfault.com/a/1190000002452115)\n\n* Promise 操作只会处在 3 种状态的一种: 未完成态(pending)、完成态(resolved)、失败态(rejected);\n* Promise 的状态只会出现从未完成态向完成态或失败态转化;\n* Promise 的状态一旦转化, 将不能被更改;\n\n### Promise api\n\n#### Promise.resolve()\n\nPromise.resolve() 括号内有 4 种情况\n\n```js\n/* 跟 Promise 对象 */\nPromise.resolve(Promise.resolve(1))\n// Promise {state: \"resolved\", data: 1, callbackQueue: Array(0)}\n\n/* 跟 thenable 对象 */\nvar thenable = {\n  then: function(resolve, reject) {\n    resolve(1)\n  }\n}\n\nPromise.resolve(thenable)\n// Promise {state: \"resolved\", data: 1, callbackQueue: Array(0)}\n\n/* 普通参数 */\nPromise.resolve(1)\n// Promise {state: \"resolved\", data: 1, callbackQueue: Array(0)}\n\n/* 不跟参数 */\nPromise.resolve()\n// Promise {state: \"resolved\", data: undefined, callbackQueue: Array(0)}\n```\n\n#### Promise.reject()\n\n相较于 Promise.resolve(), Promise.reject() 原封不动地返回参数值\n\n#### Promise.all(arr)\n\n对于 Promise.all(arr) 来说, 在参数数组中所有元素都变为决定态后, 然后才返回新的 promise。\n\n```js\n// 以下 demo, 请求两个 url, 当两个异步请求返还结果后, 再请求第三个 url\nconst p1 = request(`http://some.url.1`)\nconst p2 = request(`http://some.url.2`)\n\nPromise.all([p1, p2])\n  .then((datas) => { // 此处 datas 为调用 p1, p2 后的结果的数组\n    return request(`http://some.url.3?a=${datas[0]}&b=${datas[1]}`)\n  })\n  .then((data) => {\n    console.log(msg)\n  })\n```\n\n#### Promise.race(arr)\n\n对于 Promise.race(arr) 来说, 只要参数数组有一个元素变为决定态, 便返回新的 promise。\n\n```js\n// race 译为竞争, 同样是请求两个 url, 当且仅当一个请求返还结果后, 就请求第三个 url\nconst p1 = request(`http://some.url.1`)\nconst p2 = request(`http://some.url.2`)\n\nPromise.race([p1, p2])\n  .then((data) => { // 此处 data 取调用 p1, p2 后优先返回的结果\n    return request(`http://some.url.3?value=${data}`)\n  })\n  .then((data) => {\n    console.log(data)\n  })\n```\n\n#### Promise.wrap(fn) —— 回调函数转 Promise\n\n通过下面这个案例, 提供回调函数 Promise 化的思路。\n\n```js\nfunction foo(a, b, cb) {\n  ajax(\n    `http://some.url?a=${a}&b=${b}`,\n    cb\n  )\n}\n\nfoo(1, 2, function(err, data) {\n  if (err) {\n    console.log(err)\n  } else {\n    console.log(data)\n  }\n})\n```\n\n如上是一个传统回调函数使用案例, 假如现在有个函数 Promise.wrap(), 使用其包裹 foo 函数从而使之 promise 化, 用法如下:\n\n```js\nconst promiseFoo = Promise.wrap(foo)\n\npromiseFoo(1, 2)\n  .then((data) => {\n    console.log(data)\n  })\n  .catch((err) => {\n    console.log(err)\n  })\n```\n\n让我们来实现 Promise.wrap() 函数:\n\n```js\nPromise.wrap = function(fn) {\n  return funtion(...args) {\n    return new Promise((resolve, reject) => {\n      fn.apply(null, args.concat((err, data) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(data)\n        }\n      }))\n    })\n  }\n}\n```\n\n#### then/catch/done\n\n这几个 api 比较简单, 合起来一起带过\n\n```js\nPromise.resolve(1)\n  .then((data) => {console.log(data)}, (err) => {console.log(err)}) // 链式调用, 可以传一个参数(推荐), 也可以传两个参数\n  .catch((err) => {console.log(err)}) // 捕获链式调用中抛出的错误 || 捕获变为失败态的值\n  .done()                             // 能捕获前面链式调用的错误(包括 catch 中), 可以传两个参数也可不传\n```\n\n### 实现一个 Promise\n\n> 实践了一个符合 Promise/A+ 规范的 [repromise](https://github.com/MuYunyun/repromise)。\n\n#### 坑点 1: 事件循环\n\n> 事件循环: 同步队列执行完后, 在指定时间后再执行异步队列的内容。\n\n之所以要单列事件循环, 因为代码的执行顺序与其息息相关, 此处用 setTimeout 来模拟事件循环；\n\n下面代码片段中, ① 处执行完并不会马上执行 setTimeout() 中的代码(③), 而是此时有多少次 then 的调用, 就会重新进入 ② 处多少次后, 再进入 ③\n\n```js\nexcuteAsyncCallback(callback, value) {\n  const that = this\n  setTimeout(function() {\n    const res = callback(value) // ③\n    that.excuteCallback('fulfilled', res)\n  }, 4)\n}\n\nthen(onResolved, onRejected) {\n  const promise = new this.constructor()\n  if (this.state !== 'PENDING') {\n    const callback = this.state === 'fulfilled' ? onResolved : onRejected\n    this.excuteAsyncCallback.call(promise, callback, this.data)              // ①\n  } else {\n    this.callbackArr.push(new CallbackItem(promise, onResolved, onRejected)) // ②\n  }\n  return promise\n}\n```\n\n#### 坑点 2: this 的指向问题\n\nthis.callbackArr.push() 中的 this 指向的是 ‘上一个’ promise, 所以类 CallbackItem 中, this.promise 存储的是'下一个' promise(then 对象)。\n\n```js\nclass Promise {\n  ...\n  then(onResolved, onRejected) {\n    const promise = new this.constructor()\n    if (this.state !== 'PENDING') {        // 第一次进入 then, 状态是 RESOLVED 或者是 REJECTED\n      const callback = this.state === 'fulfilled' ? onResolved : onRejected\n      this.excuteAsyncCallback.call(promise, callback, this.data)  // 绑定 this 到 promise\n    } else {                               // 从第二次开始以后, 进入 then, 状态是 PENDING\n      this.callbackArr.push(new CallbackItem(promise, onResolved, onRejected)) // 这里的 this 也是指向‘上一个’ promise\n    }\n    return promise\n  }\n  ...\n}\n\nclass CallbackItem {\n  constructor(promise, onResolve, onReject) {\n    this.promise = promise // 相应地, 这里存储的 promise 是来自下一个 then 的\n    this.onResolve = typeof(onResolve) === 'function' ? onResolve : (resolve) => {}\n    this.onReject = typeof(onRejected) === 'function' ? onRejected : (rejected) => {}\n  }\n  ...\n}\n```\n\n### 拓展延伸\n\n```js\nsetTimeout(() => {\n  console.log('A')\n}, 0)\n\nPromise.resolve(\n  console.log('B')\n).then(() => {\n  console.log('C')\n})\n\nconsole.log('D')\n```\n\n正常情况下, 此 demo 应该输出 `B D C A`, 这里涉及到宏任务和微任务的知识点, 一个宏任务里可以有多个微任务。\n\n* 宏任务(macroTask): setTimeout、requestAnimationFrame\n* 微任务(microTask): promise、setImmediate、async/await\n\n> 由于此项目中的 promise 是用 setTimeout 实现的, 所以在上述 demo 中, 此项目输出的结果是 `B D A C`, 解决方法: 可以参考 [setImmediate.js](https://github.com/YuzuJS/setImmediate)。它的本质用了一些 hack 的手段, 比如借用了 `postMessage` 这个来操作事件循环。\n\n### 问题: promise.all 如何做到让多个 setTimeout 并发运行?\n\n这个就是 promise.all() 的本质了, 浏览器内部提供了一个事件循环机制来模拟成伪'并发'\n\n```js\nvar oldTime = Date.now()\nsetTimeout(() => {console.log(Date.now() - oldTime)}, 1000) // 1001 ~ 1005(存在 4ms 的波动)\nsetTimeout(() => {console.log(Date.now() - oldTime)}, 2000) // 2001 ~ 2005\n```"}}]);