(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6597],{66597:n=>{n.exports='### title\n\n给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。\n\n这里的「遵循」指完全匹配，例如 pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。\n\n示例 1:\n\n```js\n输入: pattern = "abba", str = "dog cat cat dog"\n输出: true\n```\n\n示例 2:\n\n```js\n输入:pattern = "abba", str = "dog cat cat fish"\n输出: false\n```\n\n示例 3:\n\n```js\n输入: pattern = "aaaa", str = "dog cat cat dog"\n输出: false\n```\n\n示例 4:\n\n```js\n输入: pattern = "abba", str = "dog dog dog dog"\n输出: false\n```\n\n说明:\n你可以假设 pattern 只包含小写字母，str 包含了由单个空格分隔的小写字母。    \n\n### 解题\n\n思路:\n\n使用 patternMap 与 strArrMap 分别存储 `pattern => strArrMap` 与 `strArrMap => pattern` 的映射, 当存在一对多映射的情况时, 则它们非完全匹配, 否则是完全匹配的。\n\n```js\n/**\n * @param {string} pattern\n * @param {string} str\n * @return {boolean}\n */\nvar wordPattern = function(pattern, str) {\n  const strArr = str.split(\' \')\n  if (pattern.length !== strArr.length) return false\n\n  const patternMap = new Map()\n  const strArrMap = new Map()\n\n  for (let i = 0; i < pattern.length; i++) {\n    const getPatternMap = patternMap.get(pattern[i])\n    const getStrArrMap = strArrMap.get(strArr[i])\n    if (!getPatternMap) {\n      patternMap.set(pattern[i], strArr[i])\n    } else if (getPatternMap !== strArr[i]) {\n      return false\n    }\n\n    if (!getStrArrMap) {\n      strArrMap.set(strArr[i], pattern[i])\n    } else if (getStrArrMap !== pattern[i]) {\n      return false\n    }\n  }\n\n  return true\n};\n```\n\n### 相关题目\n\n202、205、242、349、350、451'}}]);