(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9794],{19794:n=>{n.exports='### 79.Word Search\n\nGiven an `m x n` board and a word, find if the word exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells, where "adjacent" cells are horizontally or vertically neighboring. The `same letter cell may not be used more than once`.\n\nExample 1:\n\n![](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)\n\n```js\nInput: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"\nOutput: true\n```\n\nExample 2:\n\n![](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)\n\n```js\nInput: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"\nOutput: true\n```\n\nExample 3:\n\n![](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)\n\n```js\nInput: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"\nOutput: false\n```\n\nConstraints:\n\n* m === board.length\n* n === board[i].length\n* 1 <= m, n <= 200\n* 1 <= word.length <= 103\n* board and word consists only of lowercase and uppercase English letters.\n\n```js\n     y列\nx行   C  A  A\n      A  A  A\n      B  C  D\n```\n\nAAB -> true\n\n```js\n     y列\nx行   a  a  a  a\n      a  a  a  a\n      a  a  a  a\n```\n\n### Analyze\n\n```js\n     y列\nx行   A  B  C  E   word: ABCB\n      S  F  C  S\n      A  D  E  E\n```\n\n二维数组找路径适合用回溯法。每个节点根据`下、右、上、左`四个方向回溯查找元素。\n\n拿 `ABCCED` 作为例子, 括号中为淘汰的值。\n\nA(S) -> B(F) -> C -> C -> E(空、E、C) -> D\n\n```js\n/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nvar exist = function(board, word) {\n  for (let x = 0; x < board.length; x++) {\n    for (let y = 0; y < board[x].length; y++) {\n      if (word.length === 1 && word[0] === board[x][y]) {\n        return true\n      }\n      if (word[0] === board[x][y]) {\n        const ifValid = backTrace(board, word, 1, x, y, [])\n        if (ifValid) return ifValid\n      }\n    }\n  }\n  return false\n};\n\n/**\n * start: means start of word\n * x: row\n * y: column\n* */\nvar backTrace = (board, word, start, x, y, used) => {\n  used.push(`${x},${y}`)\n  const useBottom = used.indexOf(`${x + 1},${y}`) === -1 && word[start] === (board[x + 1] && board[x + 1][y])\n  const useRight = used.indexOf(`${x},${y + 1}`) === -1 && word[start] === (board[x] && board[x][y + 1])\n  const useTop = used.indexOf(`${x - 1},${y}`) === -1 && word[start] === (board[x - 1] && board[x - 1][y])\n  const useLeft = used.indexOf(`${x},${y - 1}`) === -1 && word[start] === (board[x] && board[x][y - 1])\n  if (start === word.length - 1 && (useRight || useBottom || useLeft || useTop)) {\n    return true\n  }\n\n  if (useBottom) {\n    const tag = backTrace(board, word, start + 1, x + 1, y, used)\n    used.pop()\n    if (tag) return tag\n  }\n  if (useRight) {\n    const tag = backTrace(board, word, start + 1, x, y + 1, used)\n    used.pop()\n    if (tag) return tag\n  }\n  if (useTop) {\n    const tag = backTrace(board, word, start + 1, x - 1, y, used)\n    used.pop()\n    if (tag) return tag\n  }\n  if (useLeft) {\n    const tag = backTrace(board, word, start + 1, x, y - 1, used)\n    used.pop()\n    if (tag) return tag\n  }\n  return false\n}\n```\n\n思考: 这道题的解法可以用来解决生活中部分「迷宫类」的问题。\n\n### 优化\n\n* 几个关键点\n  * 终止条件优化\n  * 使用 for 循环优化 4 个方向\n\n```js\n/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nvar exist = function(board, word) {\n  for (let x = 0; x < board.length; x++) {\n    for (let y = 0; y < board[x].length; y++) {\n      const ifValid = backTrace(board, word, 0, x, y, [])\n      if (ifValid) return true\n    }\n  }\n  return false\n};\n\nvar directions = [[1, 0], [0, 1], [-1, 0], [0, -1]] // 下、右、上、左\n\n/**\n * start: means start of word\n * x: row\n * y: column\n* */\nvar backTrace = (board, word, start, x, y, used) => {\n  const key = `${x},${y}`\n  if (start === word.length - 1 && used.indexOf(key) === -1 && word[start] === (board[x] && board[x][y])) {\n    return true\n  }\n\n  for (let i = 0; i < directions.length; i++) {\n    if (word[start] === (board[x] && board[x][y]) && used.indexOf(key) === -1) {\n      used.push(key)\n      const tag = backTrace(board, word, start + 1, x + directions[i][0], y + directions[i][1], used)\n      used.pop()\n      if (tag) return true\n    }\n  }\n\n  return false\n}\n```\n\n优化后代码量减少 32%。\n\n### sister title\n\n130、200'}}]);