(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6509],{76509:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>c});var o=t(59713),a=t.n(o),l=t(6479),r=t.n(l),p=(t(67294),t(3905));function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var u={};function c(e){var n=e.components,t=r()(e,["components"]);return(0,p.kt)("wrapper",s(s(s({},u),t),{},{components:n,mdxType:"MDXLayout"}),(0,p.kt)("h3",null,"观察者模式"),(0,p.kt)("p",null,"应用场景:"),(0,p.kt)("ol",null,(0,p.kt)("li",{parentName:"ol"},"场景一: 当观察的数据对象发生变化时, 自动调用相应函数。比如 vue 的双向绑定;"),(0,p.kt)("li",{parentName:"ol"},"场景二: 每当调用对象里的某个方法时, 就会调用相应'访问'逻辑。比如给测试框架赋能的 spy 函数;")),(0,p.kt)("h3",null,"场景一: 双向绑定"),(0,p.kt)("h4",null,"Object.defineProperty"),(0,p.kt)("p",null,"使用 ",(0,p.kt)("inlineCode",{parentName:"p"},"Object.defineProperty(obj, props, descriptor)")," 实现观察者模式, 其也是 ",(0,p.kt)("a",s({parentName:"p"},{href:"https://github.com/MuYunyun/blog/issues/11"}),"vue 双向绑定")," 的核心, 示例如下(当改变 obj 中的 value 的时候, 自动调用相应相关函数):"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-js"}),"var obj = {\n  data: { list: [] },\n}\n\nObject.defineProperty(obj, 'list', {\n  get() {\n    return this.data['list']\n  },\n  set(val) {\n    console.log('值被更改了')\n    this.data['list'] = val\n  }\n})\n")),(0,p.kt)("h4",null,"Proxy"),(0,p.kt)("p",null,"Proxy/Reflect 是 ES6 引入的新特性, 也可以使用其完成观察者模式, 示例如下(效果同上):"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-js"}),"var obj = {\n  value: 0\n}\n\nvar proxy = new Proxy(obj, {\n  set: function(target, key, value, receiver) { // {value: 0}  \"value\"  1  Proxy {value: 0}\n    console.log('调用相应函数')\n    Reflect.set(target, key, value, receiver)\n  }\n})\n\nproxy.value = 1 // 调用相应函数\n\n")),(0,p.kt)("h3",null,"场景二"),(0,p.kt)("p",null,"下面来实现 sinon 框架的 spy 函数:"),(0,p.kt)("pre",null,(0,p.kt)("code",s({parentName:"pre"},{className:"language-js"}),"const sinon = {\n  analyze: {},\n  spy: function(obj, fnName) {\n    const that = this\n    const oldFn = Object.getOwnPropertyDescriptor(obj, fnName).value\n    Object.defineProperty(obj, fnName, {\n      value: function() {\n        oldFn()\n        if (that.analyze[fnName]) {\n          that.analyze[fnName].count = ++that.analyze[fnName].count\n        } else {\n          that.analyze[fnName] = {}\n          that.analyze[fnName].count = 1\n        }\n        console.log(`${fnName} 被调用了 ${that.analyze[fnName].count} 次`)\n      }\n    })\n  }\n}\n\nconst obj = {\n  someFn: function() {\n    console.log('my name is someFn')\n  }\n}\n\nsinon.spy(obj, 'someFn')\n\nobj.someFn()\n// my name is someFn\n// someFn 被调用了 1 次\nobj.someFn()\n// my name is someFn\n// someFn 被调用了 2 次\n")),(0,p.kt)("h3",null,(0,p.kt)("inlineCode",{parentName:"h3"},"vue")," 在 3.0 版本上使用 ",(0,p.kt)("inlineCode",{parentName:"h3"},"Proxy")," 重构的原因"),(0,p.kt)("p",null,"首先罗列 ",(0,p.kt)("inlineCode",{parentName:"p"},"Object.defineProperty()")," 的缺点:"),(0,p.kt)("ol",null,(0,p.kt)("li",{parentName:"ol"},(0,p.kt)("inlineCode",{parentName:"li"},"Object.defineProperty()")," 不会监测到数组引用不变的操作(比如 ",(0,p.kt)("inlineCode",{parentName:"li"},"push/pop")," 等);"),(0,p.kt)("li",{parentName:"ol"},(0,p.kt)("inlineCode",{parentName:"li"},"Object.defineProperty()")," 只能监测到对象的属性的改变, 即如果有深度嵌套的对象则需要再次给之绑定 ",(0,p.kt)("inlineCode",{parentName:"li"},"Object.defineProperty()"),";")),(0,p.kt)("p",null,"关于 ",(0,p.kt)("inlineCode",{parentName:"p"},"Proxy")," 的优点"),(0,p.kt)("ol",null,(0,p.kt)("li",{parentName:"ol"},"可以劫持数组的改变;"),(0,p.kt)("li",{parentName:"ol"},(0,p.kt)("inlineCode",{parentName:"li"},"defineProperty")," 是对属性的劫持, ",(0,p.kt)("inlineCode",{parentName:"li"},"Proxy")," 是对对象的劫持;")))}c.isMDXComponent=!0}}]);