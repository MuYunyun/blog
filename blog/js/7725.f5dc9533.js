(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7725],{27725:n=>{n.exports="### 二叉树\n\n![](http://with.muyunyun.cn/c3bc86f87907fedaeba86b0f5b96a71a.jpg-300)\n\n这棵树中最多有两个分支, 因此是`二叉树`。\n\n* `根节点`: 一棵树最顶部的节点\n* `内部节点`: 在它上面还有其它内部节点或者叶节点的节点\n* `叶节点`: 处于一棵树根部的节点\n* `子树`: 由树中的内部节点和叶节点组成\n\n### 概念延伸\n\n* `完全二叉树`(compelete binary tree):\n  * 除了最后一行都满;\n  * 在最后一行不满的情况下不能只存有右子树而没有左子树;\n\n```js\n          1\n       ↙     ↘\n     2         3\n  ↙\n4\n```\n\n* `满二叉树`(full binary tree):\n  * 每一行都满;\n\n```js\n           1\n        ↙     ↘\n     2          3\n  ↙     ↘    ↙    ↘\n4        5  6       7\n```\n\n* `二叉搜索树`(Binary Search Tree)\n  * 左侧子节点的数字小于父节点, 右侧子节点的数字大于父节点\n\n```js\n           11\n        ↙     ↘\n     7          15\n  ↙    ↘      ↙    ↘\n8        9   13     20\n```\n\n* `平衡二叉树`\n\n二叉收缩树最好的情况下查找效率是比较高, 比如上图中时间复杂度为 `O(logn)`, 其访问性能近似于二分查找, 但最差时时间复杂度为 `O(n)`, 如下示意:\n\n```js\n7\n  ↘\n    8\n      ↘\n        9\n          ↘\n            11\n              ↘\n                13\n                  ↘\n                    15\n                      ↘\n                        20\n```\n\n基于此需要在二叉搜索树基础上做一下平衡,\n\n```js\n7                                    8\n  ↘              平衡后            ↙    ↘\n    8           -------\x3e         7        9\n      ↘\n        9\n```\n\n### 二叉搜索树的实现\n\n```js\nfunction BinarySearchTree() {\n  function Node(key) {\n    this.key = key\n    this.left = null\n    this.right = null\n  }\n\n  let root = null\n\n  // 插入元素\n  // 实现思路: 至顶向下插入, 先判断顶点是否为空；顶点为空则直接在该处插入, 若不为空, 则通过比较顶点的 key 和插入元素的 key 判断该插入到顶点的左侧还是右侧, 后面进行如上递归\n  this.insert = function(key) {\n    const node = new Node(key)\n    if (root === null) {\n      root = node\n    } else {\n      insertNode(root, node)\n    }\n    function insertNode(parent, node) {\n      if (parent.key > node.key) {\n        if (parent.left === null) {\n          parent.left = node\n        } else {\n          insertNode(parent.left, node)\n        }\n      } else if (parent.key < node.key) {\n        if (parent.right === null) {\n          parent.right = node\n        } else {\n          insertNode(parent.right, node)\n        }\n      }\n    }\n  }\n\n  // 中序遍历\n  this.inOrderTraverse = function(cb) {\n    inOrderTraverse(root, cb)\n    function inOrderTraverse(node, cb) {\n      if (node) {\n        inOrderTraverse(node.left, cb)\n        cb(node.key)\n        inOrderTraverse(node.right, cb)\n      }\n    }\n  }\n\n  // 先序遍历\n  this.preOrderTraverse = function(cb) {\n    preOrderTraverse(root, cb)\n    function preOrderTraverse(node, cb) {\n      if (node) {\n        cb(node.key)\n        preOrderTraverse(node.left, cb)\n        preOrderTraverse(node.right, cb)\n      }\n    }\n  }\n\n  // 后序遍历\n  this.postOrderTraverse = function(cb) {\n    postOrderTraverse(root, cb)\n    function postOrderTraverse(node, cb) {\n      if (node) {\n        postOrderTraverse(node.left, cb)\n        postOrderTraverse(node.right, cb)\n        cb(node.key)\n      }\n    }\n  }\n\n  // 最大值: 思路最右边\n  this.max = function() {\n    let maxResult = {}\n    function getMax(node) {\n      if (node && node.right) {\n        maxResult = node.right\n        getMax(node.right)\n      }\n    }\n    getMax(root)\n    return maxResult.key\n  }\n\n  // 最小值: 思路最左边\n  this.min = function() {\n    let minResult = {}\n    function getMin(node) {\n      if (node && node.left) {\n        minResult = node.left\n        getMin(node.left)\n      }\n    }\n    getMin(root)\n    return minResult.key\n  }\n\n  // 查找指定元素\n  this.search = function(key) {\n    const searchKey = function(node) {\n      if (!node) {\n        return false\n      }\n      if (key > node.key) {\n        return searchKey(node.right)\n      } else if (key < node.key) {\n        return searchKey(node.left)\n      } else {\n        return true\n      }\n    }\n\n    return searchKey(root)\n  }\n\n  // 移除指定 key 值\n  this.remove = function(key) {\n    const removeKey = function(node, key) {\n      if (key < node.key) {         // ① 如果 key 值在传入节点的左边\n        node.left = removeKey(node.left, key)\n        return node\n      } else if (key > node.key) {  // ② 如果 key 值在传入节点的右边\n        node.right = removeKey(node.right, key)\n        return node\n      } else {                      // ③ 如果找到了 key 值\n        if (node.left === null && node.right === null) { // 删除的节点为根节点\n          node = null\n          return node\n        }\n        if (node.left === null) {                        // 删除的节点下有一个分支\n          node = node.right\n          return node\n        } else if (node.right === null) {\n          node = node.left\n          return node\n        }\n        const minNode = findMinNode(node.right)          // 删除的节点下有两个分支\n        node.key = minNode.key\n        node.right = removeKey(node.right, minNode.key)\n        return node\n      }\n    }\n\n    // 查找最小的节点\n    const findMinNode = function(node) {\n      if (node.left) {\n        return findMinNode(node.left)\n      } else {\n        return node\n      }\n    }\n\n    removeKey(root, key)\n  }\n}\n\nvar tree = new BinarySearchTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(3)\ntree.insert(9)\ntree.insert(8)\ntree.insert(10)\ntree.insert(13)\ntree.insert(12)\ntree.insert(14)\ntree.insert(20)\ntree.insert(18)\ntree.insert(25)\ntree.insert(6)\n```\n\n### 三种遍历方式的不同\n\n* 中序遍历: 可用于`二叉搜索树的排序`\n\n![](http://with.muyunyun.cn/ceeb68f801304f9910073708dd35ae64.jpg-300)\n\n* 先序遍历: 可用于`打印结构化的文档`\n\n![](http://with.muyunyun.cn/65df3e9414f594107d95127f8ab5a9a1.jpg-300)\n\n* 后序遍历: 可用于查看文件夹目录\n\n![](http://with.muyunyun.cn/212607e3b24b52c0df959902ed8e4b1f.jpg-300)\n\n> 三者都为 DFS, 本质在于节点的访问时机不同。\n\n三种遍历的实现方式大同小异, 可在上面代码中观察到实现的差异。如下是 Leetcode 中对应三种不同遍历方式的题目:\n\n* [Binary Tree Preorder Traversal](https://github.com/MuYunyun/blog/blob/master/LeetCode/144.Binary_Tree_Preorder_Traversal/README.md)\n* [Binary Tree Inorder Traversal](https://github.com/MuYunyun/blog/blob/master/LeetCode/94.Binary_Tree_Inorder_Traversal/README.md)\n* [Binary Tree Postorder Traversal](https://github.com/MuYunyun/blog/blob/master/LeetCode/145.Binary_Tree_Postorder_Traversal/README.md)\n\n### remove 的几种情况\n\nremove 方法是二叉查找树中相对复杂的实现。思路仍然是递归。\n\n如果要删除的 key 在传入节点的左侧, 则递归调用 removeKey(node.left, key)；\n\n如果要删除的 key 在传入节点的右侧, 则递归调用 removeKey(node.right, key)；\n\n如果要删除的 key 与传入节点相等, 有如下三种情况:\n\n①: 删除的节点为根节点\n\n![](http://with.muyunyun.cn/65bd1b2b99db8a342423733d0480a7b6.jpg-300)\n\n②: 删除的节点下有一个分支\n\n![](http://with.muyunyun.cn/78707683d0498daa0115d445df11f83e.jpg-300)\n\n③: 删除的节点下有两个分支\n\n这里的思路是找到当前节点的右分支中最小的节点, 然后将该节点代替当前节点, 同时移除当前节点的右分支中最小的节点\n\n![](http://with.muyunyun.cn/4107c561ed1134093333e1b16c7350f4.jpg-300)\n\n### 测试用例\n\n```js\nvar tree = new BinarySearchTree()\ntree.insert(11)\ntree.insert(7)\ntree.insert(15)\ntree.insert(5)\ntree.insert(3)\ntree.insert(9)\ntree.insert(8)\ntree.insert(10)\ntree.insert(13)\ntree.insert(12)\ntree.insert(14)\ntree.insert(20)\ntree.insert(18)\ntree.insert(25)\ntree.insert(6)\n\nvar cb = (key) => console.log(key)\n\ntree.inOrderTraverse(cb)   // 中序遍历: 3 5 6 7 8 9 10 11 12 13 14 15 18 20 25\ntree.preOrderTraverse(cb)  // 先序遍历: 11 7 5 3 6 9 8 10 15 13 12 14 20 18 25\ntree.postOrderTraverse(cb) // 后序遍历: 3 6 5 8 10 9 7 12 14 13 18 25 20 15 11\n\ntree.max() // 25\ntree.max() // 3\n\ntree.search(6) // true\ntree.search(1) // false\n```"}}]);