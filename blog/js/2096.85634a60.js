(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2096],{62096:n=>{n.exports="### 77.Combinations\n\nGiven two integers n and k, return all possible combinations of k numbers out of 1 ... n.\nYou may return the answer in any order.\n\nExample 1:\n\n```js\nInput: n = 4, k = 2\nOutput:\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n```\n\nExample 2:\n\n```js\nInput: n = 1, k = 1\nOutput: [[1]]\n```\n\nConstraints:\n\n* 1 <= n <= 20\n* 1 <= k <= n\n\n### analyze\n\nn: 1, 2, 3, 4\nk: 2\n\n* 1\n  * 2\n  * 3\n  * 4\n* 2\n  * 3\n  * 4\n* 3\n  * 4\n\n组合问题中, 不同顺序的解为同一个。比如 `[1, 2], [2, 1]` 为相同解。\n\n此外可以发现规律, 保留所有`增序排列的解`即为组合的解。\n\n```js\n/**\n * @param {number} n\n * @param {number} k\n * @return {number[][]}\n */\nvar combine = function(n, k) {\n  const result = []\n  backTrace(n, k, 1, [], result)\n  return result\n};\n\nvar backTrace = function(n, k, index, temp, result) {\n  if (temp.length === k) {\n    if (ifIncrease(temp)) {\n      result.push([...temp])\n    }\n    return\n  }\n\n  for (let i = index; i <= n; i++) {\n    temp.push(i)\n    backTrace(n, k, index + 1, temp, result)\n    temp.pop()\n  }\n}\n\nvar ifIncrease = function(arr) {\n  for (let i = 0; i < arr.length - 1; i++) {\n    if (arr[i] >= arr[i + 1]) return false\n  }\n  return true\n}\n```\n\n提交, 此时报超时的错误。经排查发现, 截支的地方存在问题, 当前在 temp 中的值被重复使用了。修改如下\n\n```diff\n- backTrace(n, k, index + 1, temp, result)\n+ backTrace(n, k, i + 1, temp, result)\n```\n\n```js\n/**\n * @param {number} n\n * @param {number} k\n * @return {number[][]}\n */\nvar combine = function(n, k) {\n  const result = []\n  backTrace(n, k, 1, [], result)\n  return result\n};\n\nvar backTrace = function(n, k, index, temp, result) {\n  if (temp.length === k) {\n    result.push([...temp])\n    return\n  }\n\n  for (let i = index; i <= n; i++) {\n    temp.push(i)\n    backTrace(n, k, i + 1, temp, result)\n    temp.pop()\n  }\n}\n```\n\n### 回溯法剪支\n\n还是以 `n = 5, k = 3` 为例, 上述代码中, 实际遍历的顺序如下:\n\n```js\n* 1\n  * 2\n    * 3\n    * 4\n    * 5\n  * 3\n    * 4\n    * 5\n  * 4\n    * 5\n  * 5 // 减支\n* 2\n  * 3\n    * 4\n    * 5\n  * 4\n    * 5\n  * 5 // 减支\n* 3\n  * 4\n    * 5\n  * 5 // 减支\n* 4 // 减支\n```\n\n此时, 当第一列的值到达 3 时, 达到`搜索上界`, [3, 4, 5] 是其中一个解。如果再往后遍历, 4 作为解的开头, 则位数达不到 3 位, 不满足要求了。同理第二列的搜索上界为 4。第三列的搜索上界为 5。接着结合代码进行优化:\n\n```js\n/**\n * @param {number} n\n * @param {number} k\n * @return {number[][]}\n */\nvar combine = function(n, k) {\n  const result = []\n  backTrace(n, k, 1, [], result)\n  return result\n};\n\nvar backTrace = function(n, k, index, temp, result) {\n  if (temp.length === k) {\n    result.push([...temp])\n    return\n  }\n\n  // 题目可以转化为从搜索上界到 n 中要取的数字长度为 (k - temp.length)。\n  // 可以得出搜索上界为: n - (k - temp.length) + 1\n  for (let i = index; i <= n - (k - temp.length) + 1; i++) {\n    temp.push(i)\n    backTrace(n, k, i + 1, temp, result)\n    temp.pop()\n  }\n}\n```"}}]);