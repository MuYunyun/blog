(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4863],{84863:(t,n,e)=>{"use strict";e.r(n),e.d(n,{default:()=>m});var l=e(59713),r=e.n(l),a=e(6479),o=e.n(a),u=(e(67294),e(3905));function p(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);n&&(l=l.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,l)}return e}function s(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?p(Object(e),!0).forEach((function(n){r()(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):p(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}var i={};function m(t){var n=t.components,e=o()(t,["components"]);return(0,u.kt)("wrapper",s(s(s({},i),e),{},{components:n,mdxType:"MDXLayout"}),(0,u.kt)("h3",null,"61.Rotate List"),(0,u.kt)("p",null,"Given a linked list, rotate the list to the right by k places, where ",(0,u.kt)("inlineCode",{parentName:"p"},"k is non-negative"),"."),(0,u.kt)("p",null,"Example 1:"),(0,u.kt)("pre",null,(0,u.kt)("code",s({parentName:"pre"},{className:"language-js"}),"Input: 1->2->3->4->5->NULL, k = 2\nOutput: 4->5->1->2->3->NULL\n\nExplanation:\nrotate 1 steps to the right: 5->1->2->3->4->NULL\nrotate 2 steps to the right: 4->5->1->2->3->NULL\n")),(0,u.kt)("p",null,"Example 2:"),(0,u.kt)("pre",null,(0,u.kt)("code",s({parentName:"pre"},{className:"language-js"}),"Input: 0->1->2->NULL, k = 4\nOutput: 2->0->1->NULL\nExplanation:\nrotate 1 steps to the right: 2->0->1->NULL\nrotate 2 steps to the right: 1->2->0->NULL\nrotate 3 steps to the right: 0->1->2->NULL\nrotate 4 steps to the right: 2->0->1->NULL\n")),(0,u.kt)("h3",null,"Analyze"),(0,u.kt)("p",null,"分析: 该题可以转化为从尾部向前数到第 k 个元素, 将该元素作为头节点, 同时将初始尾节点的下一个节点指向初始头节点。"),(0,u.kt)("ol",null,(0,u.kt)("li",{parentName:"ol"},"第一步: 遍历一遍链表得到初始尾结点 last;"),(0,u.kt)("li",{parentName:"ol"},"第二步: l 与 r 距离保持为 modK + 1;"),(0,u.kt)("li",{parentName:"ol"},"第三步: l 与 r 同时向右移动, 直到 r 为 null, 则 l 为要分割的元素;")),(0,u.kt)("blockquote",null,(0,u.kt)("p",{parentName:"blockquote"},"此外如果链表长度为 0 或者链表长度与 k 相等时, 则链表实际上没有旋转交换位置。")),(0,u.kt)("pre",null,(0,u.kt)("code",s({parentName:"pre"},{className:"language-js"}),"  l                r\ndummy -> 1 -> 2 -> 3 -> 4 -> 5 -> NULL\n                   .\n                   .\n                   l               r\ndummy -> 1 -> 2 -> 3 -> 4 -> 5 -> NULL\n")),(0,u.kt)("pre",null,(0,u.kt)("code",s({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n  const dummy = new ListNode(0)\n  dummy.next = head\n  let count = 0\n  let last = dummy\n  while (last.next) {\n    last = last.next\n    count++\n  }\n\n  if (count === 0 || count === k) return dummy.next\n  const modK = k % count\n  let diff = modK + 1\n\n  let l = dummy\n  let r = dummy\n  while (diff--) {\n    r = r.next\n  }\n\n  while (r) {\n    r = r.next\n    l = l.next\n  }\n\n  last.next = dummy.next\n  dummy.next = l.next\n  l.next = null\n\n  return dummy.next\n}\n")),(0,u.kt)("h3",null,"Sister Title"),(0,u.kt)("p",null,"19"))}m.isMDXComponent=!0}}]);