(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9292],{69292:n=>{n.exports="### 437. Path Sum III\n\nYou are given a binary tree in which each node contains an integer value.\n\nFind the number of paths that sum to a given value.\n\n`The path does not need to start or end at the root or a leaf`, but it must go downwards (traveling only from parent nodes to child nodes).\n\nThe tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.\n\n`Example`:\n\n```js\nroot = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\n\n      10\n     /  \\\n    5   -3\n   / \\    \\\n  3   2   11\n / \\   \\\n3  -2   1\n\nReturn 3. The paths that sum to 8 are:\n\n1.  5 -> 3\n2.  5 -> 2 -> 1\n3. -3 -> 11\n```\n\n### 题解\n\n此题的难点需想清每个节点都要当作`根节点`来对待, 因此题解为如下三部分之和:\n\n1. `当前节点作为根节点`时相加为 sum 的路径之和。\n2. `当前节点左子树作为根节点`时相加为 sum 的路径之和。\n3. `当前节点右子树作为根节点`时相加为 sum 的路径之和。\n\n同时递归可以分为两个部分: `根节点的递归` 与 `分析总和的递归`。\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} sum\n * @return {number}\n */\nvar pathSum = function(root, sum) {\n  if (!root) return 0\n  // total means result value\n  // initialSum means init sum value\n  let result = { total: 0, initialSum: sum }\n  analyzeSum(root, result, sum)\n  return result.total\n};\n\nvar analyzeSum = function(node, result, sum) {\n  if (!node) return\n  const extraSum = sum - node.val\n  if (extraSum === 0) {\n    result.total = result.total + 1\n  }\n\n  analyzeSum(node.left, result, extraSum)\n  analyzeSum(node.right, result, extraSum)\n  // handle it as root node.\n  analyzeSum(node.left, result, result.initialSum)\n  analyzeSum(node.right, result, result.initialSum)\n}\n```\n\nsubmit 后, 卡在了如下测试用例中:\n\n```js\n输入:\n[1,null,2,null,3] // 该测试用例有点怪, 应该为 [1, null, 2, null, null, null, 3]\n3\n\n       1\n     /   \\\n  null    2\n        /   \\\n      null    3\n\n输出:\n3\n预期:\n2\n```\n\n经过排查, `analyzeSum` 函数存在冗余的调用, 并未将`根节点的递归`与`分析总和的递归`给解耦。调整如下:\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} sum\n * @return {number}\n */\n// recursive root node\nvar pathSum = function(root, sum) {\n  if (!root) return 0\n  const curTotal = analyzeSum(root, sum)\n  const leftChildTotal = pathSum(root.left, sum)\n  const rightChildTotal = pathSum(root.right, sum)\n  return curTotal + leftChildTotal + rightChildTotal\n};\n\n// recursive anlyze total value\nvar analyzeSum = function(node, expectSum) {\n  if (!node) return 0\n  const extraSum = expectSum - node.val\n  if (extraSum === 0) {\n    return 1 + analyzeSum(node.left, extraSum) + analyzeSum(node.right, extraSum)\n  } else {\n    return analyzeSum(node.left, extraSum) + analyzeSum(node.right, extraSum)\n  }\n}\n```\n"}}]);