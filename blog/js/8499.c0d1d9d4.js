(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8499],{98499:n=>{n.exports="### ref\n\n在 react 中并不建议使用 ref 属性, 而应该尽量使用[状态提升](https://doc.react-china.org/docs/lifting-state-up.html), 但是 react 还是提供了 ref 属性赋予了开发者操作 dom 的能力, react 的 ref 有 `string`、`callback`、`createRef` 三种形式, 分别如下:\n\n```js\n// string 这种写法未来会被抛弃\nclass MyComponent extends Component {\n  componentDidMount() {\n    this.refs.myRef.focus()\n  }\n  render() {\n    return <input ref=\"myRef\" />\n  }\n}\n\n// callback(比较通用)\nclass MyComponent extends Component {\n  componentDidMount() {\n    this.myRef.focus()\n  }\n  render() {\n    return <input ref={(ele) => {\n      this.myRef = ele\n    }} />\n  }\n}\n\n// react 16.3 增加, 其它 react-like 框架还没有同步\nclass MyComponent extends Component {\n  constructor(props) {\n    super(props)\n    this.myRef = React.createRef()\n  }\n  componentDidMount() {\n    this.myRef.current.focus()\n  }\n  render() {\n    return <input ref={this.myRef} />\n  }\n}\n```\n\n[React ref 的前世今生](https://zhuanlan.zhihu.com/p/40462264) 罗列了三种写法的差异, 下面对上述例子中的第二种写法(比较通用)进行实现。\n\n首先在 setAttribute 方法内补充上对 ref 的属性进行特殊处理,\n\n```js\nfunction setAttribute(dom, attr, value) {\n  ...\n  else if (attr === 'ref') {          // 处理 ref 属性\n    if (_.isFunction(value)) {\n      value(dom)\n    }\n  }\n  ...\n}\n```\n\n针对这个例子中 `this.myRef.focus()` 的 focus 属性需要异步处理, 因为调用 componentDidMount 的时候, 界面上还未添加 dom 元素。处理 renderComponent 函数:\n\n```js\nfunction renderComponent(component) {\n  ...\n  else if (component && component.componentDidMount) {\n    defer(component.componentDidMount.bind(component))\n  }\n  ...\n}\n```\n\n刷新页面, 可以发现 input 框已为选中状态。\n\n![](http://with.muyunyun.cn/d35589fbbff45a2437c6c13e24ba8058.jpg-200)\n\n处理完普通元素的 ref 后, 再来处理下自定义组件的 ref 的情况。之前默认自定义组件上是没属性的, 现在只要针对自定义组件的 ref 属性做相应处理即可。稍微修改 vdomToDom 函数如下:\n\n```js\nfunction vdomToDom(vdom) {\n  if (_.isFunction(vdom.nodeName)) { // 此时是自定义组件\n    ...\n    for (const attr in vdom.attributes) { // 处理自定义组件的 ref 属性\n      if (attr === 'ref' && _.isFunction(vdom.attributes[attr])) {\n        vdom.attributes[attr](component)\n      }\n    }\n    ...\n  }\n  ...\n}\n```\n\n跑如下测试用例:\n\n```js\nclass A extends Component {\n  constructor() {\n    super()\n    this.state = {\n      count: 0\n    }\n    this.click = this.click.bind(this)\n  }\n\n  click() {\n    this.setState({\n      count: ++this.state.count\n    })\n  }\n\n  render() {\n    return <div>{this.state.count}</div>\n  }\n}\n\nclass B extends Component {\n  constructor() {\n    super()\n    this.click = this.click.bind(this)\n  }\n\n  click() {\n    this.A.click()\n  }\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.click}>加1</button>\n        <A ref={(e) => { this.A = e }} />\n      </div>\n    )\n  }\n}\n```\n\n效果如下:\n\n![](http://with.muyunyun.cn/reactref%E6%B5%8B%E8%AF%951)\n\n### React.forwardRef 使用场景\n\n`React.forwardRef` 后面跟一个 `render` 函数。用法如下:\n\n```js\nfunction HOCComponent(WrapComponent) {\n  return class extends React.Component {\n    render() {\n      const { ref, ...rest } = this.props\n      return <WrapComponent ref={ref} { ...rest } />\n    }\n  }\n}\n\n// 此时的 ref 指向的是, 高阶组件里包裹的 WrapComponent 组件。\nconst Demo = React.forwardRef((props, ref) => {\n  return <HOCComponent { ...props } ref={ref} />\n})\n```\n\n使用场景: 需要引用高阶组件里的子组件节点的时候可以使用 `React.forwordRef`"}}]);