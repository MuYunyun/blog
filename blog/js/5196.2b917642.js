(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5196],{25196:n=>{n.exports='### 51. N-Queens\n\nThe n-queens puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven `an integer n`, return all distinct solutions to the n-queens puzzle.\n\nEach solution contains a distinct board configuration of the n-queens\' placement, where \'Q\' and \'.\' both indicate a queen and an empty space, respectively.\n\nExample 1:\n\n```js\nInput: n = 4\nOutput: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]\n\n. Q . .            . . Q .\n. . . Q     or     Q . . .\nQ . . .            . . . Q\n. . Q .            . Q . .\n```\n\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above.\n\nExample 2:\n\n```js\nInput: n = 1\nOutput: [["Q"]]\n```\n\n* Constraints:\n  * 1 <= n <= 9\n\n### Analyze\n\n```js\n    0   1   2   3\n0   .   Q   .   .\n\n1   .   .   .   Q\n\n2   Q   .   .   .\n\n3   .   .   Q   .\n```\n\n关于斜对角线上的限制可以得出以下两条规律。\n\n1. 罗列从`右上到左下`斜线点发现规律: `横坐标与纵坐标之和为定值`。\n\n* `(0, 0)`\n* `(0, 1)、(1, 0)`\n* `(0, 2)、(1, 1)、(2, 0)`\n* `(0, 3)、(1, 2)、(2, 1)、(3, 0)`\n* `(1, 3)、(2, 2)、(3, 1)`\n* `(2, 3)、(3, 2)`\n* `(3, 3)`\n\n2. 罗列从`左上到右下`斜线点发现规律: `横坐标与纵坐标之差为定值`。\n\n* `(3, 0)`\n* `(2, 0)、(3, 1)`\n* `(1, 0)、(2, 1)、(3, 2)`\n* `(0, 0)、(1, 1)、(2, 2)、(3, 3)`\n* `(0, 1)、(1, 2)、(2, 3)`\n* `(0, 2)、(1, 3)`\n* `(0, 3)`\n\n```js\n/**\n * @param {number} n\n * @return {string[][]}\n */\nvar solveNQueens = function(n) {\n  const result = []\n  const limit = {\n    used: [],\n    x: [],\n    y: [],\n    sum: [],\n    diff: []\n  }\n  handleNQueens(n, 0, limit, result)\n  return result\n};\n\n// eg: when n is 4, arr is [["0,1", "1,3", "2,0", "3,2"], ["0,2", "1,0", "2,3", "3,1"]]\nvar generate = (arr) => {\n  const xArr = []\n  for (let x = 0; x < arr.length; x++) {\n    const [queueX, queueY] = arr[x].split(\',\')\n    let yStr = \'\'\n    for (let y = 0; y < arr.length; y++) {\n      if (x === Number(queueX) && y === Number(queueY)) {\n        yStr = yStr + \'Q\'\n      } else {\n        yStr = yStr + \'.\'\n      }\n    }\n    xArr.push(yStr)\n  }\n  return xArr\n}\n\n// handle the position with the index row from n Queue.\nvar handleNQueens = (n, index, limit, result) => {\n  if (limit.x.length === n) {\n    result.push(generate([...limit.used]))\n    return\n  }\n\n  // 第 index 行安置在第几列中\n  for (let y = 0; y < n; y++) {\n    const sum = index + y\n    const diff = index - y\n    if (\n      limit.used.indexOf(`${index},${y}`) > -1\n      || limit.x.indexOf(index) > -1\n      || limit.y.indexOf(y) > -1\n      || limit.sum.indexOf(sum) > -1\n      || limit.diff.indexOf(diff) > -1\n    ) {\n      continue\n    }\n    limit.used.push(`${index},${y}`)\n    limit.x.push(index)\n    limit.y.push(y)\n    limit.sum.push(sum)\n    limit.diff.push(diff)\n\n    handleNQueens(n, index + 1, limit, result)\n    limit.used.pop()\n    limit.x.pop()\n    limit.y.pop()\n    limit.sum.pop()\n    limit.diff.pop()\n  }\n}\n```'}}]);