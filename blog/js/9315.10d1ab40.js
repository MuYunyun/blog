(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9315],{79315:n=>{n.exports="### 模板方法模式\n\n定义: 在继承的基础上, 在父类中定义好执行的算法。\n\n### 泡茶和泡咖啡\n\n来对比下泡茶和泡咖啡过程中的异同\n\n| 步骤 | 泡茶 | 泡咖啡 |\n| :-: | :-: | :-: |\n|1|烧开水|烧开水|\n|2|浸泡茶叶|冲泡咖啡|\n|3|倒入杯子|倒入杯子|\n|4|加柠檬|加糖|\n\n可以清晰地看出仅仅在步骤 2 和 4 上有细微的差别, 下面着手实现:\n\n```js\nconst Drinks = function() {}\n\nDrinks.prototype.firstStep = function() {\n  console.log('烧开水')\n}\n\nDrinks.prototype.secondStep = function() {}\n\nDrinks.prototype.thirdStep = function() {\n  console.log('倒入杯子')\n}\n\nDrinks.prototype.fourthStep = function() {}\n\nDrinks.prototype.init = function() { // 模板方法模式核心: 在父类上定义好执行算法\n  this.firstStep()\n  this.secondStep()\n  this.thirdStep()\n  this.fourthStep()\n}\n\nconst Tea = function() {}\n\nTea.prototype = new Drinks\n\nTea.prototype.secondStep = function() {\n  console.log('浸泡茶叶')\n}\n\nTea.prototype.fourthStep = function() {\n  console.log('加柠檬')\n}\n\nconst Coffee = function() {}\n\nCoffee.prototype = new Drinks\n\nCoffee.prototype.secondStep = function() {\n  console.log('冲泡咖啡')\n}\n\nCoffee.prototype.fourthStep = function() {\n  console.log('加糖')\n}\n\nconst tea = new Tea()\ntea.init()\n\n// 烧开水\n// 浸泡茶叶\n// 倒入杯子\n// 加柠檬\n\nconst coffee = new Coffee()\ncoffee.init()\n\n// 烧开水\n// 冲泡咖啡\n// 倒入杯子\n// 加糖\n```\n\n### 钩子\n\n假如客人不想加佐料(糖、柠檬)怎么办, 这时可以引人钩子来实现之, 实现逻辑如下:\n\n```js\n\n// ...\n\nDrinks.prototype.ifNeedFlavour = function() { // 加上钩子\n  return true\n}\n\nDrinks.prototype.init = function() { // 模板方法模式核心: 在父类上定义好执行算法\n  this.firstStep()\n  this.secondStep()\n  this.thirdStep()\n  if (this.ifNeedFlavour()) { // 默认是 true, 也就是要加调料\n    this.fourthStep()\n  }\n}\n\n// ...\nconst Coffee = function() {}\n\nCoffee.prototype = new Drinks()\n// ...\n\nCoffee.prototype.ifNeedFlavour = function() {\n  return window.confirm('是否需要佐料吗？') // 弹框选择是否佐料\n}\n```\n"}}]);