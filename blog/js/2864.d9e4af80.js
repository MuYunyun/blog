(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2864],{72864:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>i});var r=t(59713),a=t.n(r),p=t(6479),o=t.n(p),l=(t(67294),t(3905));function s(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function u(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?s(Object(t),!0).forEach((function(e){a()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var c={};function i(n){var e=n.components,t=o()(n,["components"]);return(0,l.kt)("wrapper",u(u(u({},c),t),{},{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h3",null,"HOC 实践"),(0,l.kt)("p",null,"高阶组件(Higher Order Component) 不属于 React API 范畴, 但是它在 React 中也是一种实用的技术, ",(0,l.kt)("inlineCode",{parentName:"p"},"它可以将常见任务抽象成一个可重用的部分"),"。这个小节算是番外篇, 会结合 ",(0,l.kt)("a",u({parentName:"p"},{href:"https://github.com/MuYunyun/cpreact"}),"cpreact"),"(前文实现的类 react 轮子) 与 HOC 进行相关的实践。"),(0,l.kt)("p",null,"它可以用如下公式表示:"),(0,l.kt)("pre",null,(0,l.kt)("code",u({parentName:"pre"},{className:"language-js"}),"y = f(x),\n\n// x: 原有组件\n// y: 高阶组件\n// f():\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"f()")," 的实现有两种方法, 下面进行实践。"),(0,l.kt)("h4",null,"属性代理(Props Proxy)"),(0,l.kt)("p",null,"属性代理是装饰器模式的一种运用, 通过装饰器函数给原来函数赋能。下面例子在装饰器函数中给被装饰的组件传递了额外的属性 ",(0,l.kt)("inlineCode",{parentName:"p"},"{ a: 1, b: 2 }"),"。"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"声明: 下文所展示的 demo 均已在 ",(0,l.kt)("a",u({parentName:"p"},{href:"https://github.com/MuYunyun/cpreact"}),"cpreact")," 测试通过")),(0,l.kt)("pre",null,(0,l.kt)("code",u({parentName:"pre"},{className:"language-js"}),"function ppHOC(WrappedComponent) {\n  return class extends Component {\n    render() {\n      const obj = { a: 1, b: 2 }\n      return (\n        <WrappedComponent { ...this.props } { ...obj } />\n      )\n    }\n  }\n}\n\n@ppHOC\nclass B extends Component {\n  render() {\n    return (\n      <div>\n        { this.props.a + this.props.b } { /* 输出 3 */ }\n      </div>\n    )\n  }\n}\n")),(0,l.kt)("p",null,"要是将 { a: 1, b: 2 } 替换成全局共享对象, 那么不就是 react-redux 中的 Connect 了么?"),(0,l.kt)("p",null,"改进上述 demo, 我们就可以实现可插拔的",(0,l.kt)("a",u({parentName:"p"},{href:"https://reactjs.org/docs/forms.html#controlled-components"}),"受控组件"),", 代码示意如下:"),(0,l.kt)("pre",null,(0,l.kt)("code",u({parentName:"pre"},{className:"language-js"}),"function ppDecorate(WrappedComponent) {\n  return class extends Component {\n    constructor() {\n      super()\n      this.state = {\n        value: ''\n      }\n      this.onChange = this.onChange.bind(this)\n    }\n\n    onChange(e) {\n      this.setState({\n        value: e.target.value\n      })\n    }\n\n    render() {\n      const obj = {\n        onChange: this.onChange,\n        value: this.state.value,\n      }\n\n      return (\n        <WrappedComponent { ...this.props } { ...obj } />\n      )\n    }\n  }\n}\n\n@ppDecorate\nclass B extends Component {\n  render() {\n    return (\n      <div>\n        <input { ...this.props } />\n        <div>{ this.props.value }</div>\n      </div>\n    )\n  }\n}\n")),(0,l.kt)("p",null,"效果如下图:"),(0,l.kt)("p",null,(0,l.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/hoc%E6%8E%A2%E7%B4%A2%E4%B9%8B%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6.gif",alt:null}))),(0,l.kt)("p",null,"这里有个坑点, 当我们在输入框输入字符的时候, 并不会立马触发 onChange 事件(我们想要让事件立即触发, 然而现在要按下回车键或者点下鼠标才触发), 在 react 中有个",(0,l.kt)("a",u({parentName:"p"},{href:"https://reactjs.org/docs/events.html"}),"合成事件")," 的知识点, 下篇文章 ",(0,l.kt)("a",u({parentName:"p"},{href:"https://github.com/MuYunyun/blog/blob/master/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0React/9.onChange%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B.md"}),"onChange 事件")," 对 react 中的 onChange 事件为何和原生 DOM 事件中的 onchange 表现不一致进行揭秘。"),(0,l.kt)("p",null,"顺带一提在这个 demo 中似乎看到了双向绑定的效果, 但是实际中 React 并没有双向绑定的概念, 但是我们可以运用 HOC 的知识点结合 setState 在 React 表单中实现伪双向绑定的效果。"),(0,l.kt)("h4",null,"继承反转(Inheritance Inversion)"),(0,l.kt)("p",null,"继承反转的核心是: 传入 HOC 的组件会作为返回类的父类来使用。然后在 render 中调用 ",(0,l.kt)("inlineCode",{parentName:"p"},"super.render()")," 来调用父类的 render 方法。"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"在 ",(0,l.kt)("a",u({parentName:"p"},{href:"https://github.com/MuYunyun/blog/blob/master/BasicSkill/readES6/%E7%BB%A7%E6%89%BF.md#%E4%BD%9C%E4%B8%BA%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E7%9A%84-super"}),"ES6 继承与 ES5 继承的差异"),"中提到了作为对象使用的 super 指向父类的实例。")),(0,l.kt)("pre",null,(0,l.kt)("code",u({parentName:"pre"},{className:"language-js"}),"function iiHOC(WrappedComponent) {\n  return class extends WrappedComponent {\n    render() {\n      const parentRender = super.render()\n      if (parentRender.nodeName === 'span') {\n        return (\n          <span>继承反转</span>\n        )\n      }\n    }\n  }\n}\n\n@iiHOC\nclass B extends Component {\n  render() {\n    return (\n      <span>Inheritance Inversion</span>\n    )\n  }\n}\n")),(0,l.kt)("p",null,"在这个 demo 中, 在 HOC 内实现了渲染劫持, 页面上最终显示如下:"),(0,l.kt)("p",null,(0,l.kt)("img",u({parentName:"p"},{src:"http://with.muyunyun.cn/e7dbedcefd9a61dcd12fbcff89dc19ef.jpg-200",alt:null}))),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"可能会有疑惑, 使用",(0,l.kt)("inlineCode",{parentName:"p"},"属性代理"),"的方式貌似也能实现渲染劫持呀, 但是那样做没有",(0,l.kt)("inlineCode",{parentName:"p"},"继承反转"),"这种方式纯粹。")),(0,l.kt)("h3",null,"相关链接"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",u({parentName:"li"},{href:"https://juejin.im/post/59818a485188255694568ff2"}),"带着三个问题深入浅出 React 高阶组件")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",u({parentName:"li"},{href:"https://zhuanlan.zhihu.com/p/24776678?refer=FrontendMagazine"}),"深入理解 React 高阶组件"))))}i.isMDXComponent=!0}}]);