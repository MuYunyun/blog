(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9721],{92391:n=>{n.exports='### 93.Restore IP Addresses\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be obtained from s. You can return them in any order.\n\nA valid IP address consists of exactly `four integers`, each integer is between 0 and 255, separated by single dots and `cannot have leading zeros`. For example, "0.1.2.201" and "192.168.1.1" are valid IP addresses and "0.011.255.245", "192.168.1.312" and "192.168@1.1" are invalid IP addresses.\n\nExample 1:\n\n```js\nInput: s = "25525511135"\nOutput: ["255.255.11.135","255.255.111.35"]\n```\n\nExample 2:\n\n```js\nInput: s = "0000"\nOutput: ["0.0.0.0"]\n```\n\nExample 3:\n\n```js\nInput: s = "1111"\nOutput: ["1.1.1.1"]\n```\n\nExample 4:\n\n```js\nInput: s = "010010"\nOutput: ["0.10.0.10","0.100.1.0"]\n```\n\nExample 5:\n\n```js\nInput: s = "101023"\nOutput: ["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]\n```\n\nConstraints:\n* 0 <= s.length <= 3000\n* s consists of digits only.\n\n### Analyze\n\n方法一: 遍历穷举法\n\n```js\n/**\n * @param {string} s\n * @return {string[]}\n */\nvar restoreIpAddresses = function (s) {\n  const arr = []\n  for (let i = 1; i < 4; i++) {\n    for (let j = i + 1; j < i + 5; j++) {\n      for (let z = j + 1; z < j + 5; z++) {\n        const a = s.slice(0, i)\n        const b = s.slice(i, j)\n        const c = s.slice(j, z)\n        const d = s.slice(z, s.length)\n        if (validate(a) && validate(b) && validate(c) && validate(d)) {\n          arr.push(`${a}.${b}.${c}.${d}`)\n        }\n      }\n    }\n  }\n  return arr\n};\n\nvar validate = function (value) {\n  if (value.length > 3 || value.length === 0 || +value > 255 || (value[0] === \'0\' && value.length > 1)) {\n    return false\n  }\n  return true\n}\n```\n\n方法二: 回溯法\n\n回溯是一种思想。DFS 也是回溯思想的一种实践案例。回溯法本质是一种穷举的递归算法, 既然是递归, 它就需要有终止条件。\n\n```js\n/**\n * @param {string} s\n * @return {string[]}\n */\nvar restoreIpAddresses = function(s) {\n  const res = []\n  backtracking(s, 0, \'\', res)\n  return res\n};\n\nvar backtracking = function(s, start, ipValue, res) {\n  const splitIpNode = ipValue.split(\'.\')\n  const ipNode = splitIpNode.length\n  // end condition\n  for (let i = 0; i < ipNode; i++) {\n    if (!isValid(splitIpNode[i])) return\n  }\n  if (ipValue.length === s.length + 3 && !ipValue.endsWith(\'.\')) {\n    // 比如 010010 存在两种相等的 case, 0100 + 1 + 0, 0100 + 10, 因此需要去重\n    if (res.indexOf(ipValue) === -1) res.push(ipValue)\n    return\n  } else if (ipValue.length === s.length + 3 && ipValue.endsWith(\'.\')) {\n    return\n  }\n\n  for (let i = start + 1; i < start + 4; i++) {\n    if (i >= s.length + 1) return\n    const str = s.slice(start, i)\n    const ipValueNew = ipNode <= 3 ? ipValue + str + \'.\' : ipValue + str\n    backtracking(s, i, ipValueNew, res)\n  }\n}\n\n// judge if the str value is valid for ip.\nvar isValid = function (value) {\n  if (value.length > 3 || +value > 255 || (value[0] === \'0\' && value.length > 1)) {\n    return false\n  }\n  return true\n}\n```\n\n针对此题, 方法一相对方法二较为容易。'}}]);