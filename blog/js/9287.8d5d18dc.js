(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9287],{9287:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>o});var r=t(59713),l=t.n(r),u=t(6479),a=t.n(u),c=(t(67294),t(3905));function p(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?p(Object(t),!0).forEach((function(n){l()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):p(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var i={};function o(e){var n=e.components,t=a()(e,["components"]);return(0,c.kt)("wrapper",s(s(s({},i),t),{},{components:n,mdxType:"MDXLayout"}),(0,c.kt)("h3",null,"title"),(0,c.kt)("p",null,"Reverse a singly linked list."),(0,c.kt)("p",null,"Example:"),(0,c.kt)("pre",null,(0,c.kt)("code",s({parentName:"pre"},{className:"language-js"}),"Input: 1->2->3->4->5->NULL\nOutput: 5->4->3->2->1->NULL\n")),(0,c.kt)("p",null,"Follow up:"),(0,c.kt)("p",null,"A linked list can be reversed either iteratively or recursively. Could you implement both?"),(0,c.kt)("h3",null,"Analyze"),(0,c.kt)("pre",null,(0,c.kt)("code",s({parentName:"pre"},{className:"language-js"}),"      prev  cur  next\n        1 -> 2 -> 3 -> 4 -> 5 -> null\nnull <- 1 -> 2 -> 3 -> 4 -> 5\n")),(0,c.kt)("p",null,"step:"),(0,c.kt)("ol",null,(0,c.kt)("li",{parentName:"ol"},"定义三个变量 prev, cur, next 表示上一个值, 当前值, 下一个值;"),(0,c.kt)("li",{parentName:"ol"},"如果存在 cur.next 则将 cur.next 指向 prev;"),(0,c.kt)("li",{parentName:"ol"},"将 cur 移动到 next 位置, prev 移动到 cur 位置, 重复步骤 2;")),(0,c.kt)("pre",null,(0,c.kt)("code",s({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function(head) {\n  let prev = null\n  let cur = head\n  if (head) {\n    let next = head.next\n    while (cur.next) {\n      cur.next = prev\n      prev = cur\n      cur = next\n      next = next.next\n    }\n    cur.next = prev\n  }\n  return cur\n};\n")),(0,c.kt)("p",null,"这样写存在一些冗余的代码, 比如需要判断 head 是否为空, 同时因为 while 中的条件是 cur.next, 因为末尾的 cur.next 需要单独处理一遍, 比较麻烦, 因此进而优化。"),(0,c.kt)("pre",null,(0,c.kt)("code",s({parentName:"pre"},{className:"language-js"}),"/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function(head) {\n  let prev = null\n  let cur = head\n  while (cur !== null) {\n    let next = cur.next\n    cur.next = prev\n    prev = cur\n    cur = next\n  }\n  return prev\n};\n")),(0,c.kt)("p",null,"根据题目的建议, 接着用递归的方式实现一遍(值得注意的是, 迭代与递归的写法都是能互相转换的。)"),(0,c.kt)("pre",null,(0,c.kt)("code",s({parentName:"pre"},{className:"language-js"}),"/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function(head) {\n  let prev = null\n  let cur = head\n\n  const recursiveFn = () => {\n    if (cur === null) return\n\n    let next = cur.next\n    cur.next = prev\n    prev = cur\n    cur = next\n\n    recursiveFn()\n  }\n  recursiveFn()\n  return prev\n};\n")),(0,c.kt)("h3",null,"Sister Title"),(0,c.kt)("p",null,"92"))}o.isMDXComponent=!0}}]);