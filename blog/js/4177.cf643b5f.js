(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4177],{4177:n=>{n.exports="### 70.Climbing Stairs\n\nYou are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\nExample 1:\n\n```js\nInput: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n```\n\nExample 2:\n\n```js\nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n```\n\n### Analyze\n\n* 到达当前的台阶的方法有两种:\n  * 一种方法是从`上一级台阶加一`;\n  * 另一种方法是从`上上一级台阶加二`;\n\n所以到达当前台阶的方法之和可以用以下式子表示: `f(n) = f(n - 1) + f(n - 2)`。\n\n因此该问题与解斐波那契数列是相同的场景。以下提供`记忆化递归`与`动态规划`两种解法:\n\n* 记忆化递归方法:\n\n```js\nconst arr = [1, 2]\n\n/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function (n) {\n  if (n === 1) return arr[0]\n  if (n === 2) return arr[1]\n\n  if (arr[n]) return arr[n]\n  arr[n] = climbStairs(n - 1) + climbStairs(n - 2)\n  return arr[n]\n}\n```\n\n* [动态规划](https://github.com/MuYunyun/blog/blob/main/Algorithm/algorithm/dynamic_programming.md)方法:\n\n```js\n/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function (n) {\n  const arr = [1, 2]\n  for (let i = 2; i < n; i++) {\n    arr[i] = arr[i - 1] + arr[i - 2]\n  }\n\n  return arr[n - 1]\n}\n```"}}]);