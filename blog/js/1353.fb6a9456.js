(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1353],{61353:n=>{n.exports="### title\n\nReverse a linked list from position m to n. Do it in one-pass.\n\nNote: 1 ≤ m ≤ n ≤ length of list.\n\nExample:\n\n```js\nInput: 1->2->3->4->5->NULL, m = 2, n = 4\nOutput: 1->4->3->2->5->NULL\n```\n\n### Analyze\n\n```js\n1 -> 2 -> 3 -> 4 -> 5\n    (4 -> 3 -> 2)\n```\n\n该题是[206.Reverse_Linked_ List](https://github.com/MuYunyun/blog/blob/master/BasicSkill/LeetCode/206.Reverse_Linked_List/README.md) 的扩展, [m, n] 区间内指针翻转的思路同 206 题, 剩下的就是将 m 的 next 指向 n 指针的 next, 同时将排在 m 前面一位的指针的 next 指向 n。\n\n会存在以下卡题的点:\n\n* 最终返回的值怎么定;\n* 如何借助中间变量;\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *   this.val = val;\n *   this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} m\n * @param {number} n\n * @return {ListNode}\n */\nvar reverseBetween = function(head, m, n) {\n  const originList = new ListNode(0)\n  originList.next = head\n\n  let listNode = originList\n\n  for (let i = 0; i < m - 1; i++) {\n    listNode = listNode.next\n  }\n\n  let prev = null\n  let cur = listNode.next\n\n  for (let i = 0; i < n - m + 1; i++) {\n    let next = cur.next\n    cur.next = prev\n    prev = cur\n    cur = next\n  }\n\n  // 将 m 的 next 指向 n 指针的 next, 同时将排在 m 前面一位的指针的 next 指向 n\n  listNode.next.next = cur\n  listNode.next = prev\n  return originList.next\n}\n```\n\n### Sister Title\n\n206"}}]);