(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7280],{47280:n=>{n.exports="\n### 同步 setState 的问题\n\n而在现有 setState 逻辑实现中, 每调用一次 setState 就会执行 render 一次。因此在如下代码中, 每次点击增加按钮, 因为 click 方法里调用了 10 次 setState 函数, 页面也会被渲染 10 次。而我们希望的是每点击一次增加按钮只执行 render 函数一次。\n\n```js\nexport default class B extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      count: 0\n    }\n    this.click = this.click.bind(this)\n  }\n\n  click() {\n    for (let i = 0; i < 10; i++) {\n      this.setState({ // 在先前的逻辑中, 没调用一次 setState 就会 render 一次\n        count: ++this.state.count\n      })\n    }\n  }\n\n  render() {\n    console.log(this.state.count)\n    return (\n      <div>\n        <button onClick={this.click}>增加</button>\n        <div>{this.state.count}</div>\n      </div>\n    )\n  }\n}\n```\n\n### 异步调用 setState\n\n查阅 setState 的 api, 其形式如下:\n\n```js\nsetState(updater, [callback])\n```\n\n它能接收两个参数, 其中第一个参数 updater 可以为对象或者为函数 (`(prevState, props) => stateChange`), 第二个参数为回调函数；\n\n确定优化思路为: 将多次 setState 后跟着的值进行浅合并, 并借助事件循环等所有值合并好之后再进行渲染界面。\n\n```js\nlet componentArr = []\n\n// 异步渲染\nfunction asyncRender(updater, component, cb) {\n  if (componentArr.length === 0) {\n    defer(() => render())       // 利用事件循环, 延迟渲染函数的调用\n  }\n\n  if (cb) defer(cb)             // 调用回调函数\n  if (_.isFunction(updater)) {  // 处理 setState 后跟函数的情况\n    updater = updater(component.state, component.props)\n  }\n  // 浅合并逻辑\n  component.state = Object.assign({}, component.state, updater)\n  if (componentArr.includes(component)) {\n    component.state = Object.assign({}, component.state, updater)\n  } else {\n    componentArr.push(component)\n  }\n}\n\nfunction render() {\n  let component\n  while (component = componentArr.shift()) {\n    renderComponent(component) // rerender\n  }\n}\n\n// 事件循环, 关于 promise 的事件循环和 setTimeout 的事件循环后续会单独写篇文章。\nconst defer = function(fn) {\n  return Promise.resolve().then(() => fn())\n}\n```\n\n此时, 每点击一次增加按钮 render 函数只执行一次了。"}}]);